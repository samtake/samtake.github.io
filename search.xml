<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dockerfile</title>
    <url>/2020/02/15/Dockerfile/</url>
    <content><![CDATA[<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h3 id="主要指令"><a href="#主要指令" class="headerlink" title="主要指令"></a>主要指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>定制的镜像都是基于 FROM 的镜像，例如nginx</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定下面的shell语句指定运行在哪个路径下</td>
</tr>
<tr>
<td>COPY</td>
<td>将宿主机下的目录文件复制到镜像中去</td>
</tr>
<tr>
<td>RUN</td>
<td>执行后面跟着的命令行命令</td>
</tr>
<tr>
<td>CMD</td>
<td>指定整个镜像运行起来后执行的脚本 (一般都是阻塞式的脚本)</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY src/  /app</span><br><span class="line">RUN <span class="built_in">echo</span> 321 &gt;&gt; 1.txt</span><br><span class="line">CMD tail -f 1.txt</span><br></pre></td></tr></table></figure>

<h3 id="COPY-vs-ADD"><a href="#COPY-vs-ADD" class="headerlink" title="COPY vs ADD"></a>COPY vs ADD</h3><p>两者功能差不多，但是ADD的源文件除了是本地文件资源，还可以是一个url</p>
<h3 id="CMD-vs-ENTRYPOINT"><a href="#CMD-vs-ENTRYPOINT" class="headerlink" title="CMD vs ENTRYPOINT"></a>CMD vs ENTRYPOINT</h3><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>
<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
<p>在 Dockerfile 文件的存放目录下，通过<code>docker build -t &lt;镜像名&gt;:&lt;版本号&gt;</code>命令来执行。</p>
<h4 id="当两者混用时"><a href="#当两者混用时" class="headerlink" title="当两者混用时"></a>当两者混用时</h4><ul>
<li>entrypoint非json，则以entrypoint为准。</li>
<li>如果entrypoint和cmd都是json，则以entrypoint+cmd拼接成的shell为准。</li>
</ul>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>expose仅仅只是声明端口。</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>标识（没实际作用）</p>
<h3 id="onbuild"><a href="#onbuild" class="headerlink" title="onbuild"></a>onbuild</h3><p><code>onbuild env C = 10</code></p>
<p>在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build </p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener">Dockerfile</a><br><a href="https://www.bilibili.com/video/av85895204?from=search&seid=4835159816508980526" target="_blank" rel="noopener">Dockerfile用法全解析</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Compose</title>
    <url>/2020/02/15/Docker-Compose/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2020/02/14/RPC/</url>
    <content><![CDATA[<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><img src="/2020/02/14/RPC/RPC.png" alt></p>
<h3 id="RPC与Restful接口的调用"><a href="#RPC与Restful接口的调用" class="headerlink" title="RPC与Restful接口的调用"></a>RPC与Restful接口的调用</h3><p>不关心调用方式，通过网络传输<br>RPC相对高效，http接口相对灵活 </p>
<p>restful接口更适合终端与服务端之间的交互，rpc更适合微服务的应用间通讯</p>
<h3 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h3><p>ProtoBuf是一种跨语言和跨平台的数据序列化协议；<br>与XML/JSON相比，序列化效率更快、体积更小、更安全；<br>与XML/JSON相比，可读性差、灵活性较低；<br>自带编译器，定义proto源文件，可编译成多种语言的代码；</p>
<h3 id="gRPC框架"><a href="#gRPC框架" class="headerlink" title="gRPC框架"></a>gRPC框架</h3><p><img src="/2020/02/14/RPC/gRPC.jpeg" alt></p>
<h3 id="框架go-micro"><a href="#框架go-micro" class="headerlink" title="框架go-micro"></a>框架go-micro</h3><p>专注于微服务的一种RPC框架；<br>提供分布式系统相关的接口集合；</p>
<p>服务发现：支持服务注册与发现</p>
<p>负载均衡：rpc服务间的请求调度均衡策略</p>
<p>同步通信：基于RPC通信，支持单项、双向流通信模式</p>
<p>异步通信：提供pub\sub通信模型的接口</p>
<p>高级接口：比如服务发现，提供调用的接口是一致的</p>
<p><img src="/2020/02/14/RPC/goMicro.png" alt></p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin基本了解</title>
    <url>/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin项目地址</a></p>
<h3 id="Gin运行流程"><a href="#Gin运行流程" class="headerlink" title="Gin运行流程"></a>Gin运行流程</h3><p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/gin.png" alt></p>
<p><code>engine</code>:实现了ServeHTTP接口的handler<br><code>methodTree</code>:根据http请求方法分别维护的路由树<br><code>routerGroup</code>:将路由表分组，方便中间件统一处理<br><code>Context</code>:Gin的上下文，在handler之间传递参数</p>
]]></content>
      <categories>
        <category>Gin</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Gin</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Docker安装RabbitMQ</title>
    <url>/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h3 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /Users/samtake/Documents/GitHub/www/rabbitmq目录可自定义，主要用于目录挂载</span></span><br><span class="line">➜  ~ mkdir -p /Users/samtake/Documents/GitHub/www/rabbitmq</span><br><span class="line">➜  ~ docker run -d --hostname rabbit-node1 --name rabbit-node1 -p 5672:5672 -p15672:15672 -v /Users/samtake/Documents/GitHub/www/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span><br><span class="line">Unable to find image <span class="string">'rabbitmq:management'</span> locally</span><br><span class="line">management: Pulling from library/rabbitmq</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>报错提示,手动添加一下docker分享目录即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The path /www/rabbitmq</span><br><span class="line">is not shared from OS X and is not known to Docker.</span><br><span class="line">You can configure shared paths from Docker -&gt; Preferences... -&gt; File Sharing.</span><br><span class="line">See https://docs.docker.com/docker-for-mac/osxfs/<span class="comment">#namespaces for more info.</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ docker ps | grep rabbit</span><br><span class="line">75d0ec6821fc        rabbitmq:management   <span class="string">"docker-entrypoint.s…"</span>   About a minute ago   Up About a minute   4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp   rabbit-node1</span><br></pre></td></tr></table></figure>


<p>浏览器打开登录rabbitmq, 入口:<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a><br>默认用户名: guest 密码: guest</p>
<h3 id="RabbitMQ的UI界面使用测试"><a href="#RabbitMQ的UI界面使用测试" class="headerlink" title="RabbitMQ的UI界面使用测试"></a>RabbitMQ的UI界面使用测试</h3><h3 id="RabbitMQ的工作原理和转发模式"><a href="#RabbitMQ的工作原理和转发模式" class="headerlink" title="RabbitMQ的工作原理和转发模式"></a>RabbitMQ的工作原理和转发模式</h3><p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/RabbitMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt></p>
<p>名词解析：<br><code>exchange</code>:消息交换机，决定消息按什么规则，路由到哪个队列。<br><code>queue</code>:消息载体，每个消息都会被投到一个或多个队列。<br><code>binding</code>:绑定，把exchange和queue按照路由规则绑定起来。<br><code>routing key</code>:路由关键字，exchange根据这关键字来投递消息。<br><code>channel</code>:消息通道，客户端的每个连接建立多个channnel。<br><code>producer</code>:消息生产者，用于投递消息的程序。<br><code>consumer</code>:消息消费者，用于接收消息的程序。</p>
<p>exchange的工作模式<br><code>fanout</code>:类似广播，转发到所有绑定交换机的queue。<br><code>direct</code>:类似单播，routing key 和bingding key完美匹配。<br><code>topic</code>:类似组播，转发到符合通配符的queue。<br><code>headers</code>:请求头与消息匹配，才能接收消息。</p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/fanout.png" alt></p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/direct.png" alt></p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/topic.jpeg" alt></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>1.配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">	// AsyncTransferEnable : 是否开启文件异步转移(默认同步)</span><br><span class="line">	AsyncTransferEnable = <span class="literal">true</span></span><br><span class="line">	// RabbitURL : rabbitmq服务的入口url</span><br><span class="line">	RabbitURL = <span class="string">"amqp://guest:guest@127.0.0.1:5672/"</span></span><br><span class="line">	// TransExchangeName : 用于文件transfer的交换机</span><br><span class="line">	TransExchangeName = <span class="string">"uploadserver.trans"</span></span><br><span class="line">	// TransOSSQueueName : oss转移队列名</span><br><span class="line">	TransOSSQueueName = <span class="string">"uploadserver.trans.oss"</span></span><br><span class="line">	// TransOSSErrQueueName : oss转移失败后写入另一个队列的队列名</span><br><span class="line">	TransOSSErrQueueName = <span class="string">"uploadserver.trans.oss.err"</span></span><br><span class="line">	// TransOSSRoutingKey : routingkey</span><br><span class="line">	TransOSSRoutingKey = <span class="string">"oss"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>2.生产者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	// 是否开启异步转移功能，开启时才初始化rabbitMQ连接</span><br><span class="line">	<span class="keyword">if</span> !config.AsyncTransferEnable &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="function"><span class="title">initChannel</span></span>() &#123;</span><br><span class="line">		channel.NotifyClose(notifyClose)</span><br><span class="line">	&#125;</span><br><span class="line">	// 断线自动重连</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> msg := &lt;-notifyClose:</span><br><span class="line">				conn = nil</span><br><span class="line">				channel = nil</span><br><span class="line">				log.Printf(<span class="string">"onNotifyChannelClosed: %+v\n"</span>, msg)</span><br><span class="line">				initChannel()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initChannel() bool &#123;</span><br><span class="line">	//1.判断channel是否已经创建</span><br><span class="line">	<span class="keyword">if</span> channel != nil &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.获得rabbitMQ的一个连接</span><br><span class="line">	conn, err := amqp.Dial(config.RabbitURL)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//3.打开一个channel，用于消息的发布与接收等</span><br><span class="line">	channel, err = conn.Channel()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Publish : 发布消息</span><br><span class="line">func Publish(exchange, routingKey string, msg []byte) bool &#123;</span><br><span class="line">	//1.判断channel是否正常</span><br><span class="line">	<span class="keyword">if</span> !<span class="function"><span class="title">initChannel</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.执行消息发布</span><br><span class="line">	err := channel.Publish(</span><br><span class="line">		exchange,</span><br><span class="line">		routingKey,</span><br><span class="line">		<span class="literal">false</span>, // 如果没有对应的queue, 就会丢弃这条消息</span><br><span class="line">		<span class="literal">false</span>, //</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ContentType: <span class="string">"text/plain"</span>, //明文编码</span><br><span class="line">			Body:        msg,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.消费者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">done</span> chan bool</span><br><span class="line"></span><br><span class="line">// StartConsume : 开始监听队列，获取消息</span><br><span class="line">func StartConsume(qName, cName string, callback func(msg []byte) bool) &#123;</span><br><span class="line">	//1.通过channel.Consume获得消息信道</span><br><span class="line">	msgs, err := channel.Consume(</span><br><span class="line">		qName,</span><br><span class="line">		cName,</span><br><span class="line">		<span class="literal">true</span>,  //自动应答</span><br><span class="line">		<span class="literal">false</span>, // 非唯一的消费者</span><br><span class="line">		<span class="literal">false</span>, // rabbitMQ只能设置为<span class="literal">false</span></span><br><span class="line">		<span class="literal">false</span>, // noWait, <span class="literal">false</span>表示会阻塞直到有消息过来</span><br><span class="line">		nil)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">done</span> = make(chan bool)</span><br><span class="line"></span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		// 2.循环读取channel的数据</span><br><span class="line">		<span class="keyword">for</span> d := range msgs &#123;</span><br><span class="line">			//3.调用callback方法来处理新的消息</span><br><span class="line">			processErr := callback(d.Body)</span><br><span class="line">			<span class="keyword">if</span> processErr &#123;</span><br><span class="line">				// TODO: 将任务写入另一个队列，用于异常情况的重试</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 接收<span class="keyword">done</span>的信号, 没有信息过来则会一直阻塞，避免该函数退出</span><br><span class="line">	&lt;-<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">	// 关闭通道</span><br><span class="line">	channel.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// StopConsume : 停止监听队列</span><br><span class="line">func <span class="function"><span class="title">StopConsume</span></span>() &#123;</span><br><span class="line">	<span class="keyword">done</span> &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">demo</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2020/02/12/Redis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="Docker-安装-Redis"><a href="#Docker-安装-Redis" class="headerlink" title="Docker 安装 Redis"></a>Docker 安装 Redis</h3><p><code>docker pull redis:latest</code><br>取最新版的 Redis 镜像</p>
<p><code>docker images</code><br>查看是否已安装了 redis</p>
<p>运行 redis 容器<br><code>docker run -itd --name redis-test -p 6379:6379 redis</code><br>或者运行redis并设置密码<br><code>docker run -d --name myredis -p 6379:6379 redis --requirepass &quot;mypassword&quot;</code></p>
<p>其中-p 6379:6379：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。</p>
<p><code>docker ps</code> 查看容器的运行信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Desktop docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                               NAMES</span><br><span class="line">d1f67d1e5fda        redis               <span class="string">"docker-entrypoint.s…"</span>   About a minute ago   Up About a minute   0.0.0.0:6379-&gt;6379/tcp              redis-test</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   8 hours ago          Up 8 hours          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br></pre></td></tr></table></figure>


<p>最后，通过过 redis-cli 连接测试使用 redis 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Desktop docker <span class="built_in">exec</span> -it redis-test /bin/bash</span><br><span class="line">root@d1f67d1e5fda:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> <span class="built_in">test</span> 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作；</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素；读取单个或者多个元素；进行修剪，只保留一个范围内的元素；</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素；</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、删除单个键值对；获取所有键值对；检查某个健是否存在；</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键的排名；</td>
</tr>
</tbody></table>
<h4 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取存储在给定健中的值</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定健中的值</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定健中的值（这个命令可以用于所有类型）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name longshan</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"longshan"</span></span><br><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h4 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>rpush</td>
<td>获取存储在给定键中的值</td>
</tr>
<tr>
<td>lrange</td>
<td>设置存储在给定键中的值</td>
</tr>
<tr>
<td>lindex</td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）</td>
</tr>
<tr>
<td>lpop</td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0-1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'lrange'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"item1"</span></span><br><span class="line">2) <span class="string">"item2"</span></span><br><span class="line">3) <span class="string">"item3"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'lrange'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 1</span><br><span class="line"><span class="string">"item2"</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line"><span class="string">"item1"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"item2"</span></span><br><span class="line">2) <span class="string">"item3"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><p>命令    | 行为<br>-|-|-<br>sadd    | 添加一个或多个元素到集合里<br>smembers |    获取集合里面的所有元素<br>sismember |    确定一个给定的值是一个集合的成员<br>srem    | 从集合里删除一个或多个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smember <span class="built_in">set</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `smember`, with args beginning with: `<span class="built_in">set</span>`, </span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"item3"</span></span><br><span class="line">2) <span class="string">"item1"</span></span><br><span class="line">3) <span class="string">"item2"</span></span><br><span class="line">127.0.0.1:6379&gt; sismember <span class="built_in">set</span> item5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smenbers <span class="built_in">set</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `smenbers`, with args beginning with: `<span class="built_in">set</span>`, </span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"item3"</span></span><br><span class="line">2) <span class="string">"item1"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h4 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h4><p>命令    | 行为<br>-|-|-<br>hset    | 设置 hash 里面一个字段的值<br>hget    | 获取 hash 中域的值<br>hgetall    | 从 hash 中读取全部的域和值<br>hdel    | 删除一个或多个域</p>
<h4 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h4><p>命令    | 行为<br>-|-|-<br>ZADD    | 添加到有序 set 的一个或多个成员，或更新的分数，如果它已经存在<br>ZRANGE    | 根据指定的 index 返回，返回 sorted set 的成员列表<br>ZRANGEBYSCORE    | 返回有序集合中指定分数区间内的成员，分数由低到高排序。<br>ZREM    | 从排序的集合中删除一个或多个成员</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>缓存 - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</p>
</li>
<li><p>计数器 - Redis 这种内存数据库能支持计数器频繁的读写操作。</p>
</li>
<li><p>应用限流 - 限制一个网站访问流量。</p>
</li>
<li><p>消息队列 - 使用 List 数据类型，它是双向链表。</p>
</li>
<li><p>查找表 - 使用 HASH 数据类型。</p>
</li>
<li><p>交集运算 - 使用 SET 类型，例如求两个用户的共同好友。</p>
</li>
<li><p>排行榜 - 使用 ZSET 数据类型。</p>
</li>
<li><p>分布式 Session - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</p>
</li>
<li><p>分布式锁 - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
</li>
</ul>
<h3 id="通过go语言使用Redis"><a href="#通过go语言使用Redis" class="headerlink" title="通过go语言使用Redis"></a>通过go语言使用Redis</h3><p>1.设置一下Redis密码然后测试连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  egoshop docker rm -f cd93e4361dff                                                 </span><br><span class="line">cd93e4361dff</span><br><span class="line"></span><br><span class="line">➜  egoshop docker run -d --name myredis -p 6379:6379 redis --requirepass <span class="string">"mypassword"</span></span><br><span class="line">f21ed92618bc5a48a95a05fcf73d1fb911b3020616dfd4950b4827dc9559814e</span><br><span class="line">➜  egoshop docker ps                                                                 </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">f21ed92618bc        redis               <span class="string">"docker-entrypoint.s…"</span>   3 seconds ago       Up 1 second         0.0.0.0:6379-&gt;6379/tcp              myredis</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   10 hours ago        Up 10 hours         0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br><span class="line">➜  egoshop docker <span class="built_in">exec</span> -it myredis /bin/bash</span><br><span class="line">root@f21ed92618bc:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; auth <span class="string">"mypassword"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>2.创建连接池</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func newRedisPool() *redis.Pool &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;redis.Pool&#123;</span><br><span class="line">		MaxIdle:     50,</span><br><span class="line">		MaxActive:   30,</span><br><span class="line">		IdleTimeout: 300 * time.Second,</span><br><span class="line">		Dial: func() (redis.Conn, error) &#123;</span><br><span class="line">			// 1. 打开连接</span><br><span class="line">			c, err := redis.Dial(<span class="string">"tcp"</span>, redisHost)</span><br><span class="line">			<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">				<span class="built_in">return</span> nil, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 2. 访问认证</span><br><span class="line">			<span class="keyword">if</span> _, err = c.Do(<span class="string">"AUTH"</span>, redisPass); err != nil &#123;</span><br><span class="line">				c.Close()</span><br><span class="line">				<span class="built_in">return</span> nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">return</span> c, nil</span><br><span class="line">		&#125;,</span><br><span class="line">		TestOnBorrow: func(conn redis.Conn, t time.Time) error &#123;</span><br><span class="line">			<span class="keyword">if</span> time.Since(t) &lt; time.Minute &#123;</span><br><span class="line">				<span class="built_in">return</span> nil</span><br><span class="line">			&#125;</span><br><span class="line">			_, err := conn.Do(<span class="string">"PING"</span>)</span><br><span class="line">			<span class="built_in">return</span> err</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	pool = newRedisPool()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RedisPool() *redis.Pool &#123;</span><br><span class="line">	<span class="built_in">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">UploadHandler</span></span>() &#123;</span><br><span class="line">	// 获得redis的一个连接</span><br><span class="line">	rConn := rPool.RedisPool().Get()</span><br><span class="line">	defer rConn.Close()</span><br><span class="line"></span><br><span class="line">	// 将初信息写入到redis缓存</span><br><span class="line">	rConn.Do(<span class="string">"sadd"</span>, <span class="string">"set"</span>, <span class="string">"uploadHandler"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.查看是否有添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"upload1"</span></span><br><span class="line">2) <span class="string">"uploadHandler"</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">具体demo源码</a></p>
<p>参考资料<br><a href="https://www.runoob.com/redis/redis-intro.html" target="_blank" rel="noopener">Redis 简介</a><br><a href="https://www.runoob.com/docker/docker-install-redis.html" target="_blank" rel="noopener">Docker 安装 Redis</a><br><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1581497616&ver=2153&signature=wJL6PdenqSUgK7dgiXas*bbrDcJzwBzrYoKKYFFfsxW*dYcRnVHqpFKbcYqLDd-bp7DY50iIvxGq8jNMAbQXau-uLB0hPqUJc4erX3MDhbuOrvvtCbw7KY3147aW3KBr&new=1" target="_blank" rel="noopener">Redis 入门指南</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat使用资料</title>
    <url>/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>实操一下</p>
<p>通过docker来启动一个mysql容器应用<br><code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</code></p>
<h3 id="通过docker-exec-it-容器id-bash-来操作mysql"><a href="#通过docker-exec-it-容器id-bash-来操作mysql" class="headerlink" title="通过docker exec -it 容器id bash 来操作mysql"></a>通过docker exec -it 容器id bash 来操作mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blogs docker ps                      </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   41 minutes ago      Up 41 minutes       0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br><span class="line">➜  blogs docker <span class="built_in">exec</span> -it  0eee2c1708be bash            </span><br><span class="line">root@0eee2c1708be:/<span class="comment"># mysql -uroot -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 765627</span><br><span class="line">Server version: 5.7.29 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; status;</span><br><span class="line">--------------</span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.29, <span class="keyword">for</span> Linux (x86_64) using  EditLine wrapper</span><br><span class="line"></span><br><span class="line">Connection id:		765627</span><br><span class="line">Current database:	</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not <span class="keyword">in</span> use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		<span class="string">''</span></span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.7.29 MySQL Community Server (GPL)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	latin1</span><br><span class="line">Db     characterset:	latin1</span><br><span class="line">Client characterset:	latin1</span><br><span class="line">Conn.  characterset:	latin1</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			1 hour 2 min 0 sec</span><br><span class="line"></span><br><span class="line">Threads: 2  Questions: 6  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.001</span><br><span class="line">--------------</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>


<h3 id="通过navicat连接MySQL"><a href="#通过navicat连接MySQL" class="headerlink" title="通过navicat连接MySQL"></a>通过navicat连接MySQL</h3><p>创建数据表时，一般字符集选择utf8，排序规则选择utf8_general_ci </p>
<p><a href="https://zhuanlan.zhihu.com/p/44348694" target="_blank" rel="noopener">在Navicat中如何新建数据库和表并做查询</a><br><a href="https://www.navicat.com.cn/manual/online_manual/cn/navicat/win_manual/index.html#/about_0" target="_blank" rel="noopener">Navicat使用手册</a> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中通过Docker安装配置MySQL主从节点</title>
    <url>/2020/02/09/Ubuntu%E4%B8%AD%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="1-拉取MySQL5-7镜像到本地"><a href="#1-拉取MySQL5-7镜像到本地" class="headerlink" title="1.拉取MySQL5.7镜像到本地"></a>1.拉取MySQL5.7镜像到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你只需要跑一个mysql实例，不做主从，那么执行以下命令即可，不用再做后面的参考步骤: docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 </span></span><br><span class="line"><span class="comment"># 然后用shell或客户端软件通过配置( 用户名:root 密码:132456 IP:你的本机ip 端口:3306)来登录即可</span></span><br></pre></td></tr></table></figure>

<h3 id="2-准备MySQL的配置文件"><a href="#2-准备MySQL的配置文件" class="headerlink" title="2.准备MySQL的配置文件"></a>2.准备MySQL的配置文件</h3><p>MySQL5.7安装之后的默认配置文件在/etc/mysql/my.cnf，而自定义的配置文件一般放在/etc/mysql/config.d这个路径下。<br>在本地host主机上自定义的某个目录下（如/data/mysql/conf/），先创建两个文件master.conf和slave.conf，分别用于配置主从两个节点。</p>
<ul>
<li>/data/mysql/conf/master.conf<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysqld] </span><br><span class="line">log_bin = <span class="built_in">log</span> <span class="comment">#开启二进制日志，用于从节点的历史复制回放 </span></span><br><span class="line">collation-server = utf8_unicode_ci </span><br><span class="line">init-connect=<span class="string">'SET NAMES utf8'</span> </span><br><span class="line">character-set-server = utf8 </span><br><span class="line">server_id = 1 <span class="comment">#需保证主库和从库的server_id不同， 假设主库设为1 </span></span><br><span class="line">replicate-do-db=fileserver <span class="comment">#需要复制的数据库名，需复制多个数据库的话则重复设置这个选项</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>/data/mysql/conf/slave.conf<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysqld] </span><br><span class="line">log_bin = <span class="built_in">log</span> <span class="comment">#开启二进制日志，用于从节点的历史复制回放 </span></span><br><span class="line">collation-server = utf8_unicode_ci </span><br><span class="line">init-connect=<span class="string">'SET NAMES utf8'</span> </span><br><span class="line">character-set-server = utf8 </span><br><span class="line">server_id = 2 <span class="comment">#需保证主库和从库的server_id不同， 假设从库设为2 </span></span><br><span class="line">replicate-do-db=fileserver <span class="comment">#需要复制的数据库名，需复制多个数据库的话则重复设置这个选项</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-Docker分别运行MySQL主-从两个容器"><a href="#3-Docker分别运行MySQL主-从两个容器" class="headerlink" title="3. Docker分别运行MySQL主/从两个容器"></a>3. Docker分别运行MySQL主/从两个容器</h3><p>将mysql主节点运行起来 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/mysql/datam </span><br><span class="line">docker run -d --name mysql-master -p 13306:3306 -v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /data/mysql/datam:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>
<p>运行参数说明:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">–name mysql-master: 容器的名称设为mysql-master </span><br><span class="line">-p 13306:3306: 将host的13306端口映射到容器的3306端口 </span><br><span class="line">-v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf ： master.conf配置文件挂载 </span><br><span class="line">-v /data/mysql/datam:/var/lib/mysql ： mysql容器内数据挂载到host的/data/mysql/datam， 用于持久化 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 : mysql的root登录密码为123456</span><br></pre></td></tr></table></figure>

<p> 将mysql从节点运行起来<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/mysql/datas </span><br><span class="line">docker run -d --name mysql-slave -p 13307:3306 -v /data/mysql/conf/slave.conf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /data/mysql/datas:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure></p>
<p> 运行参数说明: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">–name mysql-slave: 容器的名称设为mysql-slave </span><br><span class="line">-p 13307:3306: 将host的13307端口映射到容器的3306端口 </span><br><span class="line">-v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf ： master.conf配置文件挂载</span><br><span class="line">-v /data/mysql/datam:/var/lib/mysql ： mysql容器内数据挂载到host的/data/mysql/datam， 用于持久化 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 : mysql的root登录密码为123456</span><br></pre></td></tr></table></figure>

<h3 id="4-登录MySQL主节点配置同步信息"><a href="#4-登录MySQL主节点配置同步信息" class="headerlink" title="4.登录MySQL主节点配置同步信息"></a>4.登录MySQL主节点配置同步信息</h3><p>宿主机安装mysql客户端 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y mysql-client</span><br></pre></td></tr></table></figure>

<p>登录mysql </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.1.xx 是你本机的内网ip </span></span><br><span class="line">mysql -u root -h 192.168.1.xx -P13306 -p123456</span><br></pre></td></tr></table></figure>

<p>在mysql client中执行 (创建用于访问主节点来同步数据的帐号) </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create user slave identified by <span class="string">'slave'</span>; </span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'slave'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'slave'</span>; </span><br><span class="line">mysql&gt; flush privileges; </span><br><span class="line">mysql&gt; create database fileserver default character <span class="built_in">set</span> utf8mb4;</span><br></pre></td></tr></table></figure>
<p>再获取status, 得到类似如下的输出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status\G; </span><br><span class="line">*************************** 1. row *************************** </span><br><span class="line">File: log.000025 </span><br><span class="line">Position: 155 Binlog_Do_DB: </span><br><span class="line">Binlog_Ignore_DB: </span><br><span class="line">Executed_Gtid_Set: 1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>


<h3 id="5-登录MySQL从节点配置同步信息"><a href="#5-登录MySQL从节点配置同步信息" class="headerlink" title="5.登录MySQL从节点配置同步信息"></a>5.登录MySQL从节点配置同步信息</h3><ul>
<li><p>查看mysql master的容器独立ip地址 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> mysql-master </span><br><span class="line"><span class="comment"># 比如输出得到: 172.17.0.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另开一个tab登录mysql </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.1.xx 是你本机的内网ip </span></span><br><span class="line">mysql -u root -h 192.168.1.xx -P13307 -p123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>在mysql client中操作: </p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave; </span><br><span class="line">mysql&gt; create database fileserver default character <span class="built_in">set</span> utf8mb4; </span><br><span class="line"><span class="comment">#注意其中的日志文件和数值要和上面show master status的值对应 </span></span><br><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST=<span class="string">'前两个步骤中获得的mysql master ip'</span>,MASTER_PORT=3306,MASTER_USER=<span class="string">'slave'</span>,MASTER_PASSWORD=<span class="string">'slave'</span>,MASTER_LOG_FILE=<span class="string">'log.000025'</span>,MASTER_LOG_POS=155; </span><br><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure>

<p>再获取status, 正常应该得到类似如下的输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status G; </span><br><span class="line">// ... </span><br><span class="line">Slave_IO_Running: Yes </span><br><span class="line">Slave_SQL_Running: Yes </span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>



<p>到这时说明主从配置已经完成，可以尝试在主mysql的fileserver数据库里建表操作下，然后在从节点上检查数据是否已经同步过来。</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>通过docker启动mysql容器</title>
    <url>/2019/12/20/%E9%80%9A%E8%BF%87docker%E5%90%AF%E5%8A%A8mysql%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>拉取mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<p>在后台启动mysql容器(–name指定了容器的名称，方便之后进入容器的命令行，MYSQL_ROOT_PASSWORD=hls123指定了mysql的root密码，-d表示在后台运行)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --name=mysql -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>

<p>进入容器bash并进入mysql命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br></pre></td></tr></table></figure>
<p>验证容器状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>



<p>创建mysql容器 1master+1个slave</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=mysql-master -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=mysql-slave1 -it -p 3307:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习</title>
    <url>/2019/12/11/docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>安装<br>1.通过<a href="官网">wwww.docker.com</a>下载桌面版docker<br>2.<a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">配置Docker镜像站</a><br>3.执行<code>docker run hello-world</code>，看输出完美运行～</p>
<p>基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>常用操作</p>
<p>拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//下载官方nginx镜像源，等同于docker pull docker.io/nginx</span><br><span class="line">//也等同于docker pull docker.io/nginx.io/nginx:latest</span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//下载国内镜像源的ubuntu镜像，并制定版本</span><br><span class="line">docker pull registry.docker-cn.com/library/ubuntu:18.04</span><br></pre></td></tr></table></figure>

<p>推送镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//推送镜像到docker hub,需要先注册账号</span><br><span class="line">docker push &lt;你的用户名&gt;/&lt;你打包时定义的镜像名&gt;:&lt;标签，版本号&gt;</span><br><span class="line"></span><br><span class="line">//推送镜像到私有镜像库，需要提前搭建好仓库服务（比如用harbor来搭建）</span><br><span class="line">docker push &lt;私有镜像库域名，如a.b.com&gt;/&lt;项目名称&gt;/镜像名:&lt;标签&gt;</span><br></pre></td></tr></table></figure>

<p>打包镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//提前准备好一个Dockerfile，在Dockerfile相同路径下执行：</span><br><span class="line">docker build -t &lt;指定一个完整的镜像名，比如testdemo:v1.0&gt;</span><br><span class="line">//即可打包出一个本地镜像，然后再通过docker push 就可以推送到远端镜像仓库</span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d //-d 表示通过daemon方式来启动</span><br><span class="line">-p 13306:3306 //端口映射，将host主机的13306端口和docker容器的3306端口映射起来</span><br><span class="line">-v /etc/mysql:/var/mysql //目录挂载，将容器内的/var/mysql目录挂载到host主机的/etc/mysql目录，可以实现容器内这个目录下的数据持久化，mysql为镜像名（指定加载哪个镜像）</span><br></pre></td></tr></table></figure>

<p>重启或停止或删除容器应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps  //列出目前正在运行的容器列表</span><br><span class="line">docker ps -a //列出所有的容器列表</span><br><span class="line">docker start &lt;容器id&gt;  //通过容器id来重启某个容器，批量操作的话，直接在参数后面再跟对应容器id即可</span><br><span class="line">docker stop &lt;容器id&gt;  //通过容器id来关闭某个容器，批量操作的话，直接在参数后面再跟对应容器id即可</span><br><span class="line">docker rm &lt;容器id&gt;  //通过容器id来删除掉某个已经停止的容器</span><br><span class="line">docker rm -f &lt;容器id&gt;  //通过容器id来删除掉某个正在运行的容器</span><br><span class="line">docker container rm  [trusting_newton]</span><br></pre></td></tr></table></figure>

<p>删除本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmo &lt;镜像id&gt;</span><br><span class="line">docker rmi -f &lt;镜像id&gt; //强制删除</span><br></pre></td></tr></table></figure>

<p>查看容器日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f &lt;容器id&gt;</span><br><span class="line">docker inspect &lt;容器id&gt; //从返回结果中找到LogPath,运行的历史日志会在这个文件里找到</span><br></pre></td></tr></table></figure>

<p>进入容器内</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt;  /bin/bash  //进入容器内并进入它的shell终端</span><br><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt; &lt;shell命令&gt;  //在容器内执行shell命令</span><br><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt; ls -l        //查看容器内系统跟目录下所有文件或文件夹</span><br><span class="line"><span class="comment"># 进入容器后，可以直接通过exit命令推出容器</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器Linux下安装Docker社区版-Centos7为例"><a href="#服务器Linux下安装Docker社区版-Centos7为例" class="headerlink" title="服务器Linux下安装Docker社区版(Centos7为例)"></a>服务器Linux下安装Docker社区版(Centos7为例)</h3><ul>
<li>yum源使用阿里云的源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"><span class="comment"># 下载阿里云的yum源</span></span><br><span class="line">wget http<span class="string">"mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="string">mv CentOS-Base.repo CentOS-Base.repo.back</span></span><br><span class="line"><span class="string">mv Centos-7.repo CentOS-Base.repo</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重置yum源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo http://mirros.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装docker</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看阿里云上docker 源信息</span></span><br><span class="line">yum list docker-ce</span><br><span class="line"><span class="comment">#安装docker最新社区版</span></span><br><span class="line">yum -y install docker-ce</span><br><span class="line"><span class="comment">#查看docker信息</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment">#查看docker详细状态信息</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>








<p>参考资料<br><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">Docker — 从入门到实践</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2019/12/11/ElasticSearch/</url>
    <content><![CDATA[<p>ElasticSearch：全文搜索引擎，它可以快速存储，搜索和分析海量数据，用户包括：维基百科、Stack Overflow、GitHub</p>
<p>特点：不需要简表，配置字段等；只需要存json的文档；</p>
<p>通过docker安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span> docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span><br></pre></td></tr></table></figure>

<p>安装成功之后访问<code>http://localhost:9200/</code>即可见到对应信息</p>
<p>链接参考<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html" target="_blank" rel="noopener">docker安装ElasticSearch</a></p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Go仿百度网盘学习笔记</title>
    <url>/2019/12/10/Go%E4%BB%BF%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>数据库分表<br>水平分表：假设分成256张文件表，按文件Sha1值后两位来切分，则以：tb_${FILE_SHA1}[:-2]的规则到对应表进行存取。</p>
<p>// OnFileUploadFinished : 文件上传完成，保存meta （插入）<br>// GetFileMeta : 从mysql获取文件元信息（查询）<br>// UpdateFileLocation : 更新文件的存储地址(如文件被转移了)  （更新）<br>涉及源码：db(file.go   mysql(conn.go))</p>
<p>使用MySQL小结：<br>通过sql.DB来管理数据连接对象<br>通过sql.Open来创建协程安全的sql.DB<br>优先使用Prepared Statement</p>
<h3 id="4-1用户系统用户表设计-注册和登录"><a href="#4-1用户系统用户表设计-注册和登录" class="headerlink" title="4-1用户系统用户表设计(注册和登录)"></a>4-1用户系统用户表设计(注册和登录)</h3><p>由于原有情况下,唯一索引用在了字段phone上. 而当前插入表的sql语句中, user_name才是应该要保持唯一的, 因此相对于视频所演示的建表语句进行了更新, 具体如下: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tbl_user` ( </span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT, </span><br><span class="line">    `user_name` varchar(64) NOT NULL DEFAULT <span class="string">''</span> COMMENT <span class="string">'用户名'</span>, </span><br><span class="line">    `user_pwd` varchar(256) NOT NULL DEFAULT <span class="string">''</span> COMMENT <span class="string">'用户encoded密码'</span>, </span><br><span class="line">    `email` varchar(64) DEFAULT <span class="string">''</span> COMMENT <span class="string">'邮箱'</span>, </span><br><span class="line">    `phone` varchar(128) DEFAULT <span class="string">''</span> COMMENT <span class="string">'手机号'</span>, </span><br><span class="line">    `email_validated` tinyint(1) DEFAULT 0 COMMENT <span class="string">'邮箱是否已验证'</span>, </span><br><span class="line">    `phone_validated` tinyint(1) DEFAULT 0 COMMENT <span class="string">'手机号是否已验证'</span>, </span><br><span class="line">    `signup_at` datetime DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'注册日期'</span>, </span><br><span class="line">    `last_active` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">'最后活跃时间戳'</span>, </span><br><span class="line">    `profile` text COMMENT <span class="string">'用户属性'</span>, </span><br><span class="line">    `status` int(11) NOT NULL DEFAULT <span class="string">'0'</span> COMMENT <span class="string">'账户状态(启用/禁用/锁定/标记删除等)'</span>, </span><br><span class="line">    PRIMARY KEY (`id`), </span><br><span class="line">    UNIQUE KEY `idx_username` (`user_name`), </span><br><span class="line">    KEY `idx_status` (`status`) </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>

<p>登录<br>// 1. 校验用户名及密码<br>// 2. 生成访问凭证(token)<br>// 3. 登录成功后重定向到首页<br>涉及源码：<br>db(user.go )<br>handle(user.go)</p>
<p>访问鉴权（验证token的拦截器）<br>handler(auth.go)</p>
<h3 id="5-hash算法对比以及秒传原理"><a href="#5-hash算法对比以及秒传原理" class="headerlink" title="5.hash算法对比以及秒传原理"></a>5.hash算法对比以及秒传原理</h3><h3 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6.Redis"></a>6.Redis</h3><p>分块上传与断点续传<br>分块上传：文件切成多块，独立上传，上传完成后合并（初始化上传-&gt;上传分块（并行）-&gt;通知上传完成）<br>断点续传：传输暂停或一场终端后，可基于原来进度重传</p>
<p>小文件不建议分块上传<br>可以并行上传分块，并且可以无序传输<br>分块上传能极大提高传输效率<br>减少传输失败后重试的流量和时间</p>
<h3 id="7-Ceph"><a href="#7-Ceph" class="headerlink" title="7.Ceph"></a>7.Ceph</h3><p>Ceph:redhat开源出来的分布式存储系统</p>
<h3 id="8-阿里云对象存储OSS"><a href="#8-阿里云对象存储OSS" class="headerlink" title="8.阿里云对象存储OSS"></a>8.阿里云对象存储OSS</h3><h3 id="9-RabbitMQ"><a href="#9-RabbitMQ" class="headerlink" title="9.RabbitMQ"></a>9.RabbitMQ</h3><p>RabbitMQ:一种开源的消息代理</p>
<h3 id="10-微服务"><a href="#10-微服务" class="headerlink" title="10.微服务"></a>10.微服务</h3>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Go仿百度网盘学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>golang练习笔记</title>
    <url>/2019/11/21/golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableZeroValue</span></span>() &#123;</span><br><span class="line">	var a int</span><br><span class="line">	var s string</span><br><span class="line">	fmt.Printf(<span class="string">"%d %q\n"</span>, a, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableInitialValue</span></span>() &#123;</span><br><span class="line">	var a, b int = 3, 4</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型推断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableTypeDeduction</span></span>() &#123;</span><br><span class="line">	var a, b, c, d = 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>利用冒号定义的简单写法  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableShorter</span></span>() &#123;</span><br><span class="line">	a, b, c, d := 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	b = 6</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数外的变量定义(不能使用冒号定义，且它的作用域只在该包内部)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var aa = 55</span><br><span class="line">var ss = <span class="string">"llll"</span></span><br><span class="line">var bb = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">	bbb = 666</span><br><span class="line">	sss = <span class="string">"jjj"</span></span><br><span class="line">	ttt = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h2><p><code>bool</code>, <code>string</code>,</p>
<p><code>(u)int</code>, <code>(u)int8</code>, <code>(u)int16</code>, <code>(u)int32</code>, <code>(u)int64</code>, <code>uintptr</code>,</p>
<p><code>byte</code>, <code>rune</code>,</p>
<p><code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>,</p>
<h2 id="常量与枚举"><a href="#常量与枚举" class="headerlink" title="常量与枚举"></a>常量与枚举</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> func <span class="function"><span class="title">consts</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	const a, b = 3, 4</span><br><span class="line">	var c int</span><br><span class="line">	c = int(math.Sqrt(a*a + b + b))</span><br><span class="line">	fmt.Println(filename, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">enums</span></span>() &#123;</span><br><span class="line">	const (</span><br><span class="line">		cpp = iota</span><br><span class="line">		java</span><br><span class="line">		golang</span><br><span class="line">		swift</span><br><span class="line">		_</span><br><span class="line">		C</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	const (</span><br><span class="line">		b = 1 &lt;&lt; (10 * iota)</span><br><span class="line">		bb</span><br><span class="line">		bbb</span><br><span class="line">		bbbb</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	fmt.Println(cpp, java, golang, C)</span><br><span class="line">	fmt.Println(b, bb, bbb, bbbb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abc.txt 4</span><br><span class="line">0 1 2 5</span><br><span class="line">1 1024 1048576 1073741824</span><br></pre></td></tr></table></figure>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if的条件里可以赋值<br>if的条件里赋值的变量作用域就在这个if语句里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	<span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch后面可以没有表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func grade(score int) string &#123;</span><br><span class="line">	g := <span class="string">""</span></span><br><span class="line">	switch &#123;</span><br><span class="line">	<span class="keyword">case</span> score &lt; 0 || score &gt; 100:</span><br><span class="line">		panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	<span class="keyword">case</span> score &lt; 60:</span><br><span class="line">		g = <span class="string">"F"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 80:</span><br><span class="line">		g = <span class="string">"C"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 90:</span><br><span class="line">		g = <span class="string">"B"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 100:</span><br><span class="line">		g = <span class="string">"A"</span></span><br><span class="line">		// default:</span><br><span class="line">		// 	panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func convertToBin(n int) string &#123;</span><br><span class="line">	res := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> ; n &gt; 0; n /= 2 &#123;</span><br><span class="line">		lsb := n % 2</span><br><span class="line">		res = strconv.Itoa(lsb) + res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printFile(filename string) &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	scanner := bufio.NewScanner(file)</span><br><span class="line">	<span class="keyword">for</span> scanner.<span class="function"><span class="title">Scan</span></span>() &#123;</span><br><span class="line">		fmt.Println(scanner.Text)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">forever</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"abc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func div(a, b int) (q, r int) &#123;</span><br><span class="line">	// <span class="built_in">return</span> a / b, a % b</span><br><span class="line">	q = a / b</span><br><span class="line">	r = a % b</span><br><span class="line">	<span class="built_in">return</span> q, r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func pow(a, b int) int &#123;</span><br><span class="line">	<span class="built_in">return</span> int(math.Pow(float64(a), float64(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func apply(op func(int, int) int, a, b int) int &#123;</span><br><span class="line">	p := reflect.ValueOf(op).Pointer()</span><br><span class="line">	opName := runtime.FuncForPC(p).Name()</span><br><span class="line">	fmt.Printf(<span class="string">"Calling function %s with args "</span>+<span class="string">"(%d,%d)"</span>, opName, a, b)</span><br><span class="line">	<span class="built_in">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	q, r := div(8, 6)</span><br><span class="line">	fmt.Println(q, r)</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(pow, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者以匿名函数的形式进行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(</span><br><span class="line">		func(a int, b int) int &#123;</span><br><span class="line">			<span class="built_in">return</span> int(math.Pow(</span><br><span class="line">				float64(a), float64(b)))</span><br><span class="line">		&#125;, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func sum(numbers ...int) int &#123;</span><br><span class="line">	s := 0</span><br><span class="line">	<span class="keyword">for</span> i := range numbers &#123;</span><br><span class="line">		s += numbers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>参数传递</p>
<ul>
<li><p>go语言只有值传递一种方式<br><code>var a int</code> 当参数传递给<code>fun f(pa *int)</code>它其实就是将a的指针&amp;a拷贝一份传递给pa,pa也跟&amp;a一样，同时指向a</p>
</li>
<li><p>再如：<code>var cache Cache</code> 当参数传递给<code>func f(cache Cache)</code>,参数Cache那么大不可能拷贝一份的，实际上Cache也只是一个指向data的指针，所以cache当参数的时候，它只是拷贝了一份指针，它同时也指向了data</p>
</li>
</ul>
<p>交换两个变量的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func swap(a, b int) &#123;</span><br><span class="line">	b, a = a, b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(a, b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  hello go run point.go</span><br><span class="line">3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>我们发现值没有变，这是需要使用指针，将a,b所指向的值改变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) &#123;</span><br><span class="line">	*b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(&amp;a, &amp;b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var arr1 [5]int</span><br><span class="line">	arr2 := [3]int&#123;1, 2, 3&#125;      //冒号等于的定义，需要给数组一个初值</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; //或者不指定数组个数</span><br><span class="line">	fmt.Println(arr1, arr2, arr3)</span><br><span class="line"></span><br><span class="line">	//二维数组定义</span><br><span class="line">	var grid [4][5]int</span><br><span class="line">	fmt.Println(grid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := 0; i &lt; len(arr3); i++ &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>下标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := range arr3 &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>下标和值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>数组是值类型的，所以当参数用的时候需要指定长度<code>cannot use arr1 (type [5]int) as type [4]int in argument to printArray</code>，且在函数里面再次赋值后，它在外面是不会改变的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printArray(arr [4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，依旧是1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以，[10]int和[20]int 是不同类型；调用func f(arr [10]int)会拷贝数组。需要改变它就需要用到指针了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; </span><br><span class="line"></span><br><span class="line">	printArray(&amp;arr3)</span><br><span class="line">	fmt.Println(arr3, arr3[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printArray(arr *[4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，改变为100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	//s := arr[2:6]</span><br><span class="line">	fmt.Println(<span class="string">"arr[2:6] ="</span>, arr[2:6])</span><br><span class="line">	fmt.Println(<span class="string">"arr[:6] ="</span>, arr[:6])</span><br><span class="line">	fmt.Println(<span class="string">"arr[2:] ="</span>, arr[2:])</span><br><span class="line">	fmt.Println(<span class="string">"arr[:] ="</span>, arr[:])</span><br><span class="line"></span><br><span class="line">	s1 := arr[2:]</span><br><span class="line">	s2 := arr[:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s1"</span>)</span><br><span class="line">	updateSlice(s1)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s2"</span>)</span><br><span class="line">	updateSlice(s2)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"printArray"</span>)</span><br><span class="line">	printArray(arr[:])</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"reslice"</span>)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[:5]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[2:]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr[2:6] = [2 3 4 5]</span><br><span class="line">arr[:6] = [0 1 2 3 4 5]</span><br><span class="line">arr[2:] = [2 3 4 5 6 7]</span><br><span class="line">arr[:] = [0 1 2 3 4 5 6 7]</span><br><span class="line">after updateSlice(s1</span><br><span class="line">[100 3 4 5 6 7]</span><br><span class="line">[0 1 100 3 4 5 6 7]</span><br><span class="line">after updateSlice(s2</span><br><span class="line">[100 1 100 3 4 5 6 7]</span><br><span class="line">[100 1 100 3 4 5 6 7]</span><br><span class="line">printArray</span><br><span class="line">0 100</span><br><span class="line">1 50</span><br><span class="line">2 100</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">reslice</span><br><span class="line">[100 50 100 3 4 5 6 7]</span><br><span class="line">[100 50 100 3 4]</span><br><span class="line">[100 3 4]</span><br></pre></td></tr></table></figure>
<p>slice可以向后扩展，不可以向前扩展<br>s[i]不可以超越len(s)，向后扩展不可以超越底层数组 cap(s)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceExtension</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"sliceExtension"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]</span><br><span class="line">	s2 := s1[3:5]</span><br><span class="line">	fmt.Println(<span class="string">"s1="</span>, s1)</span><br><span class="line">	fmt.Println(<span class="string">"s2="</span>, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sliceExtension</span><br><span class="line">s1= [2 3 4 5]</span><br><span class="line">s2= [5 6]</span><br></pre></td></tr></table></figure>


<p>向slice添加元素时，如果超越了cap，系统会重新分配更大的底层数组<br>新的slice里面， ptr len cap都会变掉，所以必须接收append的返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceAppend</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"slice append"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]       //2 3 4 5</span><br><span class="line">	s2 := s1[3:5]        //5 6</span><br><span class="line">	s3 := append(s2, 10) //5 6 10</span><br><span class="line">	s4 := append(s3, 11) //5 6 10 11</span><br><span class="line">	s5 := append(s4, 12) //5 6 10 11 12</span><br><span class="line">	fmt.Println(<span class="string">"s3="</span>, s3)</span><br><span class="line">	fmt.Println(<span class="string">"s4="</span>, s4)</span><br><span class="line">	fmt.Println(<span class="string">"s5="</span>, s5)</span><br><span class="line">	fmt.Println(<span class="string">"arr="</span>, arr) //0, 1, 2, 3, 4, 5, 6 10  数组长度不变的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice的创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceCreate</span></span>() &#123;</span><br><span class="line">	var s []int</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		printSlice(s)</span><br><span class="line">		s = append(s, 2*i+1)</span><br><span class="line">	&#125;</span><br><span class="line">	println(s)</span><br><span class="line"></span><br><span class="line">	s1 := []int&#123;2, 3, 5, 6, 8, 2, 5&#125;</span><br><span class="line">	println(s1)</span><br><span class="line"></span><br><span class="line">	s2 := make([]int, 16)</span><br><span class="line">	s3 := make([]int, 10, 32) //32是开辟的空间<span class="built_in">cap</span></span><br><span class="line">	println(<span class="string">"print Slice  s2 s3"</span>)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">	printSlice(s3)</span><br><span class="line"></span><br><span class="line">	println(<span class="string">"Slice copy"</span>)</span><br><span class="line">	copy(s2, s1) //将s1复制给s2</span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">	//如何删除8</span><br><span class="line">	println(<span class="string">"Slice delete"</span>)</span><br><span class="line">	s2 = append(s2[:4], s2[5:]...)</span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//删除头尾</span><br><span class="line">	fmt.Println(<span class="string">"pop from front"</span>)</span><br><span class="line">	front := s2[0]</span><br><span class="line">	s2 = s2[1:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"pop from back"</span>)</span><br><span class="line">	back := s2[len(s2)-1]</span><br><span class="line">	s2 = s2[:len(s2)-1]</span><br><span class="line">	fmt.Println(front, back)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> Slice  s2 s3</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0], len=10, <span class="built_in">cap</span>= 32</span><br><span class="line">Slice copy</span><br><span class="line">[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">Slice delete</span><br><span class="line">[2 3 5 6 2 5 0 0 0 0 0 0 0 0 0], len=15, <span class="built_in">cap</span>= 16</span><br><span class="line">pop from front</span><br><span class="line">pop from back</span><br><span class="line">2 0</span><br><span class="line">[3 5 6 2 5 0 0 0 0 0 0 0 0], len=13, <span class="built_in">cap</span>= 15</span><br></pre></td></tr></table></figure>



<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	m := map[string]string&#123;</span><br><span class="line">		<span class="string">"name"</span>:  <span class="string">"sam"</span>,</span><br><span class="line">		<span class="string">"class"</span>: <span class="string">"go"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	m2 := make(map[string]int)</span><br><span class="line"></span><br><span class="line">	var m3 map[string]int</span><br><span class="line"></span><br><span class="line">	fmt.Println(m2, m3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>遍历，key在map里是无序的～</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := range m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当key打错了，获取到的是空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取值</span><br><span class="line">	fmt.Println(<span class="string">"getting values"</span>)</span><br><span class="line">	name := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name)</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">	println(name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	println(<span class="string">"key does not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//删除</span><br><span class="line">	fmt.Println(<span class="string">"delete values"</span>)</span><br><span class="line">	name1, ok := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name1, ok)</span><br></pre></td></tr></table></figure>

<p>map的key的类型可以是<br>除了slice,map,function的内建类型都可以作为key<br>struct类型不包含上述字段，也可以作为key</p>
<h2 id="字符和字符串的处理"><a href="#字符和字符串的处理" class="headerlink" title="字符和字符串的处理"></a>字符和字符串的处理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	s := <span class="string">"yes中文中文"</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	<span class="keyword">for</span> _, b := range []byte(s) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%X  "</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := range s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"(%d %X)"</span>, i, ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">"rune count:"</span>, utf8.RuneCountInString(s))</span><br><span class="line"></span><br><span class="line">	//单个字符转义</span><br><span class="line">	bytes := []byte(s)</span><br><span class="line">	<span class="keyword">for</span> len(bytes) &gt; 0 &#123;</span><br><span class="line">		ch, size := utf8.DecodeRune(bytes)</span><br><span class="line">		bytes = bytes[size:]</span><br><span class="line">		fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yes中文中文</span><br><span class="line">79  65  73  E4  B8  AD  E6  96  87  E4  B8  AD  E6  96  87  </span><br><span class="line">(0 79)(1 65)(2 73)(3 4E2D)(6 6587)(9 4E2D)(12 6587)</span><br><span class="line">rune count: 7</span><br><span class="line">y e s 中 文 中 文</span><br></pre></td></tr></table></figure>
<p>rune相当于go的char<br>使用range遍历string，rune对<br>使用utf8.RuneCountInString(s)获得字符数量<br>使用len获得字节长度<br>使用[]byte获得所有的字节</p>
<p>寻找最长不含重复字符的字串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func lengthOfNonRepeatSubStr(s string) int &#123;</span><br><span class="line">	lastOccurred := make(map[rune]int)</span><br><span class="line">	start := 0</span><br><span class="line">	maxLength := 0</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := range []rune(s) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123;</span><br><span class="line">			start = lastI + 1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i-start+1 &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start + 1</span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其它字符串操作<br>Fields Split Join<br>Contains Index<br>ToLower ToUpper<br>Trim TrimRight TrimLeft</p>
<h2 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>go仅支持封装，不支持继承和多态</p>
<p>结构体的创建：不论地址还是结构本身，一律使用<code>.</code>来访问成员</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定义</span><br><span class="line"><span class="built_in">type</span> treeNode struct &#123;</span><br><span class="line">	value       int</span><br><span class="line">	left, right *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂函数创建</span><br><span class="line">func createNode(value int) *treeNode &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;treeNode&#123;value: value&#125; //这里返回的是局部变量的地址给外部使用，在go依旧是可以的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var root treeNode</span><br><span class="line">	fmt.Println(root)</span><br><span class="line"></span><br><span class="line">	//创建</span><br><span class="line">	root = treeNode&#123;value: 3&#125;</span><br><span class="line">	root.left = &amp;treeNode&#123;&#125;</span><br><span class="line">	root.right = &amp;treeNode&#123;5, nil, nil&#125;</span><br><span class="line">	root.right.left = new(treeNode)</span><br><span class="line">	fmt.Println(root)</span><br><span class="line">	nodes := []treeNode&#123;</span><br><span class="line">		&#123;value: 3&#125;,</span><br><span class="line">		&#123;&#125;, </span><br><span class="line">		&#123;6, nil, &amp;root&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(nodes)</span><br><span class="line"></span><br><span class="line">	root.left.right = createNode(2)</span><br><span class="line">	fmt.Println(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给结构定义方法:<br>func后面括号的是方法接收者（其实就跟函数的返回值一样）<br>只有使用指针才可以改变结构的内容<br>nil指针也可以调用方法（可以将值传进来，但是nil的赋值会报错，需要做return处理）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//树的遍历:给结构定义方法</span><br><span class="line">func (node *treeNode) setValue(value int) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == nil &#123;</span><br><span class="line">		fmt.Println(<span class="string">"setting value to nil node"</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	node.value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//值不会变</span><br><span class="line">// func (node treeNode) setValue(value int) &#123;</span><br><span class="line">// 	node.value = value</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">func (node *treeNode) setValue(value int) &#123;</span><br><span class="line">	node.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">"print\n"</span>)</span><br><span class="line">	root.print()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\nsetValue\n"</span>)</span><br><span class="line">	root.right.left.setValue(9)</span><br><span class="line">	root.right.left.print()</span><br></pre></td></tr></table></figure>


<p>中序遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"> 总结：</span><br><span class="line"> 要改变内容必须使用指针接收者</span><br><span class="line"> 结构过大也考虑使用指针接收者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 包和封装</span></span><br><span class="line"></span><br><span class="line">封装</span><br><span class="line">名字一般使用驼峰命名</span><br><span class="line">首字母大写：public（针对于包）</span><br><span class="line">首字母小写：private（针对于包）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">包</span><br><span class="line">每个目录一个包</span><br><span class="line">main包包含可执行入口</span><br><span class="line">为结构定义的方法必须放在同一个包内</span><br><span class="line">一个包可以放不同的文件</span><br><span class="line">建议结构体都不需要前缀包名（TreeNode改为Node即可）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 拓展已有类型</span></span><br><span class="line"></span><br><span class="line">定义别名</span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">type</span> myTreeNode struct &#123;</span><br><span class="line">	node *tree.TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后序遍历</span><br><span class="line">func (myNode *myTreeNode) <span class="function"><span class="title">postOrder</span></span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> myNode == nil || myNode.node == nil &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	left := myTreeNode&#123;myNode.node.Left&#125;</span><br><span class="line">	left.postOrder()</span><br><span class="line"></span><br><span class="line">	right := myTreeNode&#123;myNode.node.Right&#125;</span><br><span class="line">	right.postOrder()</span><br><span class="line"></span><br><span class="line">	myNode.node.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用组合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package queue</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Queue []int</span><br><span class="line"></span><br><span class="line">func (q *Queue) Push(v int) &#123;</span><br><span class="line">	*q = append(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Pop() int &#123;</span><br><span class="line">	head := (*q)[0]</span><br><span class="line">	*q = (*q)[1:]</span><br><span class="line">	<span class="built_in">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) IsEmpty() bool &#123;</span><br><span class="line">	<span class="built_in">return</span> len(*q) == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/queue"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	q := queue.Queue&#123;1&#125;</span><br><span class="line">	q.Push(2)</span><br><span class="line">	q.Push(3)</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.IsEmpty())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.IsEmpty())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用内嵌来扩展已有类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> myTreeNode struct &#123;</span><br><span class="line">	*tree.Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>GOPATH</li>
<li>GOVENDOR</li>
<li>go mod</li>
</ul>
<p>go mod的使用</p>
<p>引入需要的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>直接运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run zaptest.go</span><br></pre></td></tr></table></figure>


<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u 库名 </span><br><span class="line"></span><br><span class="line">go mod init modtest</span><br><span class="line"></span><br><span class="line">go build ./...</span><br></pre></td></tr></table></figure>

<p>增加依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get</span><br></pre></td></tr></table></figure>

<p>更新依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get [@version]</span><br><span class="line"></span><br><span class="line">go mod tidy  //更新版本之后，使用该命令可以去除多余的文件</span><br></pre></td></tr></table></figure>

<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>每个单独目录只有一个mian函数</p>
<p>build当前目录的所有子文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build ./...</span><br></pre></td></tr></table></figure>

<p>产生结果, 结果放在GOPATH的bin目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install ./...</span><br><span class="line">go env GOPATH</span><br></pre></td></tr></table></figure>

<h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>infra</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package infra</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (Retriver) Get(url string) string &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> string(bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>testing</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package testing</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (Retriver) Get(url string) string &#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">"fake content"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>download</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/downloader/infra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func getRetriver() retriver &#123;</span><br><span class="line">	// <span class="built_in">return</span> testing.Retriver&#123;&#125;//测试</span><br><span class="line">	<span class="built_in">return</span> infra.Retriver&#123;&#125;//真实数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//是infra还是testing的Retriver呢？如何判断呢：通过接口</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> retriver interface &#123;</span><br><span class="line">	Get(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var r retriver = getRetriver()</span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, r.Get(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck typing"></a>duck typing</h2><h2 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h2><p>接口的定义(接口由使用者定义)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/retriever/mock"</span></span><br><span class="line">	<span class="string">"learngo/retriever/real"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver interface &#123;</span><br><span class="line">	Get(url string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func download(r Retriver) string &#123;</span><br><span class="line">	<span class="built_in">return</span> r.Get(<span class="string">"http://www.imooc.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var r Retriver</span><br><span class="line">	r = mock.Retriver&#123;<span class="string">"this is a fake imooc.com"</span>&#125;</span><br><span class="line">	r = real.Retriver&#123;&#125;</span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的实现（不需要实现Retriver接口，只需要实现接口里的方法）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package real</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct &#123;</span><br><span class="line">	UserAgent string</span><br><span class="line">	TimeOut   time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Retriver) Get(url string) string &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> string(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口的值类型"><a href="#接口的值类型" class="headerlink" title="接口的值类型"></a>接口的值类型</h2><p>switch判断类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func inspect(r Retriver) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"类型=%T 值=%v\n"</span>, r, r)</span><br><span class="line">	switch v := r.(<span class="built_in">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> mock.Retriver:</span><br><span class="line">		fmt.Println(<span class="string">"Contents:"</span>, v.Contents)</span><br><span class="line">	<span class="keyword">case</span> *real.Retriver:</span><br><span class="line">		fmt.Println(<span class="string">"UserAgent:"</span>, v.UserAgent)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type assertion</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">type</span> assertion</span><br><span class="line"></span><br><span class="line">	//real</span><br><span class="line">	realRetriver := r.(*real.Retriver)</span><br><span class="line">	fmt.Println(realRetriver.TimeOut)</span><br><span class="line"></span><br><span class="line">	//出错写法</span><br><span class="line">	realRetriver := r.(real.Retriver)</span><br><span class="line">	fmt.Println(realRetriver.TimeOut)</span><br><span class="line"></span><br><span class="line">	//防止出错</span><br><span class="line">	<span class="keyword">if</span> mockRetriver, ok := r.(mock.Retriver); ok &#123;</span><br><span class="line">		fmt.Println(mockRetriver.Contents)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not a mock retriver"</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>表示任何类型:interface{}</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//改为支持任何类型</span><br><span class="line"><span class="built_in">type</span> Queue []interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Push(v interface&#123;&#125;) &#123;</span><br><span class="line">	*q = append(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	head := (*q)[0]</span><br><span class="line">	*q = (*q)[1:]</span><br><span class="line">	<span class="built_in">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) IsEmpty() bool &#123;</span><br><span class="line">	<span class="built_in">return</span> len(*q) == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Retriver interface &#123;</span><br><span class="line">	Get(url string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Poster interface &#123;</span><br><span class="line">	Post(url string, form map[string]string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const url = <span class="string">"http://www.imooc.com"</span></span><br><span class="line"></span><br><span class="line">func download(r Retriver) string &#123;</span><br><span class="line">	<span class="built_in">return</span> r.Get(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func poster(poster Poster) &#123;</span><br><span class="line">	poster.Post(url,</span><br><span class="line">		map[string]string&#123;</span><br><span class="line">			<span class="string">"name"</span>:     <span class="string">"sam"</span>,</span><br><span class="line">			<span class="string">"language"</span>: <span class="string">"golang"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> RetriverPoster interface &#123;</span><br><span class="line">	Retriver</span><br><span class="line">	Poster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func session(s RetriverPoster) string &#123;</span><br><span class="line">	s.Post(url, map[string]string&#123;</span><br><span class="line">		<span class="string">"contents"</span>: <span class="string">"another facked imooc.com"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">return</span> s.Get(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="常用的系统接口"><a href="#常用的系统接口" class="headerlink" title="常用的系统接口"></a>常用的系统接口</h2><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>参数、变量、返回值都可以是函数<br>高阶函数（函数的参数依旧是个函数）<br>函数闭包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//返回一个函数</span><br><span class="line">func adder() func(int) int &#123;</span><br><span class="line">	sum := 0</span><br><span class="line">	<span class="built_in">return</span> func(v int) int &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		<span class="built_in">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	a := adder()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		fmt.Println((a(i)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>斐波那契数列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">	a, b := 0, 1</span><br><span class="line">	<span class="built_in">return</span> func() int &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">		<span class="built_in">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>为函数实现接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> intGen func() int</span><br><span class="line"></span><br><span class="line">func (g intGen) Read(</span><br><span class="line">	p []byte) (n int, err error) &#123;</span><br><span class="line">	next := g()</span><br><span class="line">	<span class="keyword">if</span> next &gt; 10000 &#123;</span><br><span class="line">		<span class="built_in">return</span> 0, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line">	s := fmt.Sprintf(<span class="string">"%d\n"</span>, next)</span><br><span class="line"></span><br><span class="line">	// TODO: incorrect <span class="keyword">if</span> p is too small!</span><br><span class="line">	<span class="built_in">return</span> strings.NewReader(s).Read(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func printFileContents(reader io.Reader) &#123;</span><br><span class="line">	scanner := bufio.NewScanner(reader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> scanner.<span class="function"><span class="title">Scan</span></span>() &#123;</span><br><span class="line">		fmt.Println(scanner.Text())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var f intGen = fib.Fibonacci()</span><br><span class="line">	printFileContents(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>利用函数遍历二叉树</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>确保调用在函数结束时发生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	defer fmt.Println(2)</span><br><span class="line">	defer fmt.Println(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defer是一个栈，先进后出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	defer fmt.Println(2)</span><br><span class="line">	defer fmt.Println(3)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">		defer fmt.Println(i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i == 30 &#123;</span><br><span class="line">			panic(<span class="string">"printed too many"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeFle(filename string) &#123;</span><br><span class="line">	file, err := os.Create(filename)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	defer writer.Flush()</span><br><span class="line"></span><br><span class="line">	f := fib.Fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		fmt.Fprintln(writer, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	writeFle(<span class="string">"fib.txt"</span>)</span><br><span class="line"></span><br><span class="line">	tryDefer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  defer go run defer.go</span><br><span class="line">30</span><br><span class="line">29</span><br><span class="line">28</span><br><span class="line">27</span><br><span class="line">26</span><br><span class="line">25</span><br><span class="line">24</span><br><span class="line">23</span><br><span class="line">22</span><br><span class="line">21</span><br><span class="line">20</span><br><span class="line">19</span><br><span class="line">18</span><br><span class="line">17</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">14</span><br><span class="line">13</span><br><span class="line">12</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">panic: printed too many</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.tryDefer()</span><br><span class="line">        /Users/samtake/Desktop/learngo/hello/errHandling/defer/defer.go:19 +0x2fc</span><br><span class="line">main.main()</span><br><span class="line">        /Users/samtake/Desktop/learngo/hello/errHandling/defer/defer.go:43 +0x3b</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p>何时调用defer</p>
<ul>
<li><p>Open/Close</p>
</li>
<li><p>Lock/Unlock</p>
</li>
<li><p>PrintHeader/PrintFooter</p>
</li>
</ul>
<p>错误处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">		defer fmt.Println(i)</span><br><span class="line">		<span class="keyword">if</span> i == 30 &#123;</span><br><span class="line">			// Uncomment panic to see</span><br><span class="line">			// how it works with defer</span><br><span class="line">			// panic(<span class="string">"printed too many"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeFle(filename string) &#123;</span><br><span class="line">	file, err := os.OpenFile(filename,</span><br><span class="line">		os.O_EXCL|os.O_CREATE|os.O_WRONLY, 0666)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		<span class="keyword">if</span> pathError, ok := err.(*os.PathError); !ok &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%s, %s, %s\n"</span>,</span><br><span class="line">				pathError.Op,</span><br><span class="line">				pathError.Path,</span><br><span class="line">				pathError.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	defer writer.Flush()</span><br><span class="line"></span><br><span class="line">	f := fib.Fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		fmt.Fprintln(writer, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器统一出错处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> appHandler func(writer http.ResponseWriter,</span><br><span class="line">	request *http.Request) error</span><br><span class="line"></span><br><span class="line">func errWrapper(</span><br><span class="line">	handler appHandler) func(</span><br><span class="line">	http.ResponseWriter, *http.Request) &#123;</span><br><span class="line">	<span class="built_in">return</span> func(writer http.ResponseWriter,</span><br><span class="line">		request *http.Request) &#123;</span><br><span class="line">		// panic</span><br><span class="line">		defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			<span class="keyword">if</span> r := recover(); r != nil &#123;</span><br><span class="line">				log.Printf(<span class="string">"Panic: %v"</span>, r)</span><br><span class="line">				http.Error(writer,</span><br><span class="line">					http.StatusText(http.StatusInternalServerError),</span><br><span class="line">					http.StatusInternalServerError)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		err := handler(writer, request)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			log.Printf(<span class="string">"Error occurred "</span>+</span><br><span class="line">				<span class="string">"handling request: %s"</span>,</span><br><span class="line">				err.Error())</span><br><span class="line"></span><br><span class="line">			// user error</span><br><span class="line">			<span class="keyword">if</span> userErr, ok := err.(userError); ok &#123;</span><br><span class="line">				http.Error(writer,</span><br><span class="line">					userErr.Message(),</span><br><span class="line">					http.StatusBadRequest)</span><br><span class="line">				<span class="built_in">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// system error</span><br><span class="line">			code := http.StatusOK</span><br><span class="line">			switch &#123;</span><br><span class="line">			<span class="keyword">case</span> os.IsNotExist(err):</span><br><span class="line">				code = http.StatusNotFound</span><br><span class="line">			<span class="keyword">case</span> os.IsPermission(err):</span><br><span class="line">				code = http.StatusForbidden</span><br><span class="line">			default:</span><br><span class="line">				code = http.StatusInternalServerError</span><br><span class="line">			&#125;</span><br><span class="line">			http.Error(writer,</span><br><span class="line">				http.StatusText(code), code)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> userError interface &#123;</span><br><span class="line">	error</span><br><span class="line">	Message() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>,</span><br><span class="line">		errWrapper(filelisting.HandleFileList))</span><br><span class="line"></span><br><span class="line">	err := http.ListenAndServe(<span class="string">":8888"</span>, nil)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><p>panic<br>停止当前函数执行<br>一直向上返回，执行每一层的defer<br>如果没有遇见recover，程序就退出</p>
<p>recover<br>仅在defer调用中使用<br>获取panic的值<br>如果无法处理，可重新panic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryRecover</span></span>() &#123;</span><br><span class="line">	defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		r := recover()</span><br><span class="line">		<span class="keyword">if</span> r == nil &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Nothing to recover. "</span> +</span><br><span class="line">				<span class="string">"Please try uncomment errors "</span> +</span><br><span class="line">				<span class="string">"below."</span>)</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Error occurred:"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			panic(fmt.Sprintf(</span><br><span class="line">				<span class="string">"I don't know what to do: %v"</span>, r))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>go test 会自动执行路径包下面的“_test.go”文件（包括文件名包含 “_test.go” 的源文件），我们管称这些是测试文件，里面包含着你的测试函数，测试用例等。更多用法可以输入 “go help test” 查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="代码覆盖率和性能测试"><a href="#代码覆盖率和性能测试" class="headerlink" title="代码覆盖率和性能测试"></a>代码覆盖率和性能测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用pprof进行性能调优</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="测试http服务器"><a href="#测试http服务器" class="headerlink" title="测试http服务器"></a>测试http服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成文档和实力代码</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>轻量级“线程”<br>非抢占式多任务处理，由协程主动交出控制权（Printf是个IO操作，内部做了控制权切换）<br>多个协程可能在一个或多个线程上运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"hello form goroutine %d\n"</span>, i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">tryGoroutine</span></span>() &#123;</span><br><span class="line">	var a [10]int</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func(ii int) &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				a[ii]++</span><br><span class="line">				runtime.Gosched()//主动交出控制权</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据访问的冲突</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run -race goroutine.go</span><br></pre></td></tr></table></figure>

<p>查看cpu占用率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p>go语言的调度器</p>
<p>任何函数只需加上go就能送给调度器运行<br>不需要在定义时区分是否是异步函数<br>调度器在合适的点进行切换<br>使用-race来检测数据访问冲突</p>
<p>goroutine 可能的切换点<br>I/O、select<br>channel<br>等待锁<br>函数调用（有时会）<br>runtime.Gosched()<br>以上所列只是参考～真实情况就不一定～</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	// var c chan int //c == nil</span><br><span class="line">	c := make(chan int)</span><br><span class="line"></span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n := &lt;-c</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	c &lt;- 2 //如果main退出了，2是没有输出的</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func worker(c chan int) &#123;</span><br><span class="line">	<span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n := &lt;-c</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	// var c chan int //c == nil</span><br><span class="line">	c := make(chan int)</span><br><span class="line"></span><br><span class="line">	go worker(c)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	c &lt;- 2 //如果main退出了，2是没有输出的</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>channel作为参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func worker(id int, c chan int) &#123;</span><br><span class="line">	<span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var channels [10]chan int</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] = make(chan int)</span><br><span class="line">		go worker(i, channels[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>channel作为返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func creatWorker(id int) chan&lt;- int &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var channels [10]chan&lt;- int</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] = creatWorker(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存channel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">bufferedChannel</span></span>() &#123;</span><br><span class="line">	c := make(chan int, 3) //给个缓存3</span><br><span class="line">	go work(0, c)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>关闭通道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">channelClose</span></span>() &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go work(0, c)</span><br><span class="line">	c &lt;- <span class="string">'a'</span></span><br><span class="line">	c &lt;- <span class="string">'b'</span></span><br><span class="line">	c &lt;- <span class="string">'c'</span></span><br><span class="line">	c &lt;- <span class="string">'d'</span></span><br><span class="line">	close(c)</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭之后，依旧能收到（空串，0）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Worker 0 received a</span><br><span class="line">Worker 0 received b</span><br><span class="line">Worker 0 received c</span><br><span class="line">Worker 0 received d</span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 r</span><br></pre></td></tr></table></figure>

<p>解决关闭之后不再输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, ok := &lt;-c</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="built_in">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> n := range c &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用channel等待goroutine结束（重点）"><a href="#使用channel等待goroutine结束（重点）" class="headerlink" title="使用channel等待goroutine结束（重点）"></a>使用channel等待goroutine结束（重点）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func doWork(id int,</span><br><span class="line">	w worker) &#123;</span><br><span class="line">	<span class="keyword">for</span> n := range w.in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>,</span><br><span class="line">			id, n)</span><br><span class="line">		w.done()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> worker struct &#123;</span><br><span class="line">	<span class="keyword">in</span>   chan int</span><br><span class="line">	<span class="keyword">done</span> func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createWorker(</span><br><span class="line">	id int, wg *sync.WaitGroup) worker &#123;</span><br><span class="line">	w := worker&#123;</span><br><span class="line">		<span class="keyword">in</span>: make(chan int),</span><br><span class="line">		<span class="keyword">done</span>: <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	go doWork(id, w)</span><br><span class="line">	<span class="built_in">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	var workers [10]worker</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		workers[i] = createWorker(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Add(20)</span><br><span class="line">	<span class="keyword">for</span> i, worker := range workers &#123;</span><br><span class="line">		worker.in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, worker := range workers &#123;</span><br><span class="line">		worker.in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	chanDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Worker 7 received h</span><br><span class="line">Worker 5 received f</span><br><span class="line">Worker 0 received a</span><br><span class="line">Worker 1 received b</span><br><span class="line">Worker 1 received B</span><br><span class="line">Worker 4 received e</span><br><span class="line">Worker 9 received j</span><br><span class="line">Worker 8 received i</span><br><span class="line">Worker 2 received c</span><br><span class="line">Worker 0 received A</span><br><span class="line">Worker 6 received g</span><br><span class="line">Worker 3 received d</span><br><span class="line">Worker 9 received J</span><br><span class="line">Worker 6 received G</span><br><span class="line">Worker 7 received H</span><br><span class="line">Worker 2 received C</span><br><span class="line">Worker 4 received E</span><br><span class="line">Worker 8 received I</span><br><span class="line">Worker 3 received D</span><br><span class="line">Worker 5 received F</span><br></pre></td></tr></table></figure>


<p>使用Channel进行书的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用Select进行调度（重点）"><a href="#使用Select进行调度（重点）" class="headerlink" title="使用Select进行调度（重点）"></a>使用Select进行调度（重点）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func generator() chan int &#123;</span><br><span class="line">	out := make(chan int)</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		i := 0</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(</span><br><span class="line">				time.Duration(rand.Intn(1500)) *</span><br><span class="line">					time.Millisecond)</span><br><span class="line">			out &lt;- i</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func worker(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> n := range c &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %d\n"</span>,</span><br><span class="line">			id, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createWorker(id int) chan&lt;- int &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go worker(id, c)</span><br><span class="line">	<span class="built_in">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var c1, c2 = generator(), generator()</span><br><span class="line">	var worker = createWorker(0)</span><br><span class="line"></span><br><span class="line">	var values []int</span><br><span class="line">	tm := time.After(10 * time.Second)</span><br><span class="line">	tick := time.Tick(time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		var activeWorker chan&lt;- int</span><br><span class="line">		var activeValue int</span><br><span class="line">		<span class="keyword">if</span> len(values) &gt; 0 &#123;</span><br><span class="line">			activeWorker = worker</span><br><span class="line">			activeValue = values[0]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		select &#123;</span><br><span class="line">		<span class="keyword">case</span> n := &lt;-c1:</span><br><span class="line">			values = append(values, n)</span><br><span class="line">		<span class="keyword">case</span> n := &lt;-c2:</span><br><span class="line">			values = append(values, n)</span><br><span class="line">		<span class="keyword">case</span> activeWorker &lt;- activeValue:</span><br><span class="line">			values = values[1:]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(800 * time.Millisecond):</span><br><span class="line">			fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-tick:</span><br><span class="line">			fmt.Println(</span><br><span class="line">				<span class="string">"queue len ="</span>, len(values))</span><br><span class="line">		<span class="keyword">case</span> &lt;-tm:</span><br><span class="line">			fmt.Println(<span class="string">"bye"</span>)</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>WaitGroup<br>Mutex<br>Cond</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 迷宫算法</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="http标准库"><a href="#http标准库" class="headerlink" title="http标准库"></a>http标准库</h2><p>使用http客户端发送请求<br>使用http.Client控制请求头部等<br>使用httputil简化工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	request, err := http.NewRequest(</span><br><span class="line">		http.MethodGet,</span><br><span class="line">		<span class="string">"http://www.imooc.com"</span>, nil)</span><br><span class="line">	request.Header.Add(<span class="string">"User-Agent"</span>,</span><br><span class="line">		<span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1"</span>)</span><br><span class="line"></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		CheckRedirect: func(</span><br><span class="line">			req *http.Request,</span><br><span class="line">			via []*http.Request) error &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Redirect:"</span>, req)</span><br><span class="line">			<span class="built_in">return</span> nil</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pprof</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...../debug/pprof/</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof [地址]</span><br></pre></td></tr></table></figure>



<h2 id="其它标准库"><a href="#其它标准库" class="headerlink" title="其它标准库"></a>其它标准库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bufio</span><br><span class="line"><span class="built_in">log</span></span><br><span class="line">encoding/json</span><br><span class="line">regexp</span><br><span class="line">time</span><br><span class="line">strings/math/rand</span><br></pre></td></tr></table></figure>

<p>获取文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">godoc -http :8888</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://docscn.studygolang.com/</span><br></pre></td></tr></table></figure>



<h2 id="gin-amp-增加middleware"><a href="#gin-amp-增加middleware" class="headerlink" title="gin&amp;增加middleware"></a>gin&amp;增加middleware</h2><p>拉取gin和日志库zap</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br><span class="line">go get -u go.uber.org/zap</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/ping</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen tcp :8080: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use 问题解决</span><br><span class="line">命令行 lsof -i:8080 这里8080是我要释放的端口号</span><br><span class="line"></span><br><span class="line">可以看到，该端口被id为51217的进程所占用，这个时候直接在命令行输入</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 51217</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	logger, err := zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Use(func(c *gin.Context) &#123;</span><br><span class="line">		logger.Info(<span class="string">"incoming request"</span>, zap.String(<span class="string">"path"</span>, c.Request.URL.Path))</span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/hello"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"hello"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const keyRequestId = <span class="string">"requestId"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	logger, err := zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Use(func(c *gin.Context) &#123;</span><br><span class="line">		s := time.Now()</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		logger.Info(<span class="string">"incoming request"</span>,</span><br><span class="line">			zap.String(<span class="string">"path"</span>, c.Request.URL.Path),</span><br><span class="line">			zap.Int(<span class="string">"status"</span>, c.Writer.Status()),</span><br><span class="line">			zap.Duration(<span class="string">"elapsed"</span>, time.Now().Sub(s)))</span><br><span class="line">	&#125;, func(c *gin.Context) &#123;</span><br><span class="line">		c.Set(keyRequestId, rand.Int())</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		h := gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> rid, exists := c.Get(keyRequestId); exists &#123;</span><br><span class="line">			h[keyRequestId] = rid</span><br><span class="line">		&#125;</span><br><span class="line">		c.JSON(200, h)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">"/hello"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"hello"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`)</span><br><span class="line">	match := re.FindAllString(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[sam@gmail.com 5555@qq.com 5555@163.com]</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`([a-zA-Z0-9]+)@([a-zA-Z0-9]+)\.([a-zA-Z0-9]+)`)</span><br><span class="line">	match := re.FindAllStringSubmatch(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, m := range match &#123;</span><br><span class="line">		fmt.Println(m)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[sam@gmail.com sam gmail com] [5555@qq.com 5555 qq com] [5555@163.com 5555 163 com]]</span><br><span class="line">[sam@gmail.com sam gmail com]</span><br><span class="line">[5555@qq.com 5555 qq com]</span><br><span class="line">[5555@163.com 5555 163 com]</span><br></pre></td></tr></table></figure>

<h2 id="包管理-包引入"><a href="#包管理-包引入" class="headerlink" title="包管理(包引入)"></a>包管理(包引入)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init [crawler-single-task]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  crawler git:(master) ✗ cat go.mod                     </span><br><span class="line">module crawler-single-task</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        golang.org/x/net v0.0.0-20191207000613-e7e4b65ae663</span><br><span class="line">        golang.org/x/text v0.3.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>以项目当前目录为起点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"crawler-single-task/engine"</span></span><br><span class="line">	<span class="string">"crawler-single-task/zhenai/parser"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="单任务爬虫要点笔记"><a href="#单任务爬虫要点笔记" class="headerlink" title="单任务爬虫要点笔记"></a>单任务爬虫要点笔记</h2><h3 id="转换-UTF-8-与-GBK-编码的文本"><a href="#转换-UTF-8-与-GBK-编码的文本" class="headerlink" title="转换 UTF-8 与 GBK 编码的文本"></a>转换 UTF-8 与 GBK 编码的文本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get golang.org/x/text</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">utf8Reader := transform.NewReader(resp.Body, simplifiedchinese.GBK.NewDecoder())</span><br></pre></td></tr></table></figure>

<h3 id="确定编码库"><a href="#确定编码库" class="headerlink" title="确定编码库"></a>确定编码库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get golang.org/x/net/html</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//确定编码</span><br><span class="line">func determinEncoding(r io.Reader) encoding.Encoding &#123;</span><br><span class="line">	bytes, err := bufio.NewReader(r).Peek(1024)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	e, _, _ := charset.DetermineEncoding(bytes, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//转码</span><br><span class="line">	e := determinEncoding(resp.Body)</span><br><span class="line">	utf8Reader := transform.NewReader(resp.Body, e.NewDecoder())</span><br></pre></td></tr></table></figure>

<h3 id="获取城市名和链接的方式"><a href="#获取城市名和链接的方式" class="headerlink" title="获取城市名和链接的方式"></a>获取城市名和链接的方式</h3><p>使用css选择器<code>$(&#39;#cityList&gt;dd&gt;a&#39;)</code></p>
<p>使用xpath</p>
<p>使用正则表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`)</span><br><span class="line">	match := re.FindAllString(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>AFN表单形式提交图片</title>
    <url>/2019/11/15/AFN%E8%A1%A8%E5%8D%95%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BA%A4%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>PromiseKit</title>
    <url>/2019/11/05/PromiseKit/</url>
    <content><![CDATA[<h1 id="then-and-done"><a href="#then-and-done" class="headerlink" title="then and done"></a><code>then</code> and <code>done</code></h1><p>典型使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这段代码使用了<code>completion handlers</code>，它将如下所示:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> creds = creds &#123;</span><br><span class="line">        fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> image = image &#123;</span><br><span class="line">                <span class="keyword">self</span>.imageView = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>then</code> 只是构造<code>completion handlers</code>的另一种方式, 但也远不止如此。在我们理解的最初阶段，它主要有助于可读性。上面的<code>promise链</code>很容易浏览和理解:一个异步操作一行一行地通向另一个。鉴于Swift的当前状态，它尽可能接近程序代码。</p>
<p><code>done</code> 和 <code>then</code> ，但是你不能返回一个<code>promise</code>. 这通常是链条中<code>success</code>部分的终点. 上面, 您可以看到我们在 <code>done</code> 时收到了最终的图像，并使用它来设置用户界面。</p>
<p>两种实现方法的比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Creds</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Compared with:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(completion: <span class="params">(Creds?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">                        <span class="comment">// ^^ ugh. Optionals. Double optionals.</span></span><br></pre></td></tr></table></figure>

<p>区别在于，对于<code>Promise</code>，您的函数返回<code>Promise</code>，而不是接受和运行回调。链中的每个<code>handler</code>都会返回一个<code>Promise</code>。<code>Promise</code>对象定义了<code>then</code>方法，该方法在链的执行之前等待<code>Promise</code>的完成。锁链按程序解决，一次一个<code>Promise</code>。</p>
<p><code>Promise</code> 代表异步任务的返回值。它有一个表示它包装的对象类型的类型。例如，在上面的例子中，<code>login</code>是一个返回<code>Promise</code>的函数，该<code>Promise</code>将代表Creds实例。</p>
<blockquote>
<p><em>Note</em>: <code>done</code> is new to PromiseKit 5. We previously defined a variant of <code>then</code> that<br>did not require you to return a promise. Unfortunately, this convention often confused<br>Swift and led to odd and hard-to-debug error messages. It also made using PromiseKit<br>more painful. The introduction of <code>done</code> lets you type out promise chains that<br>compile without additional qualification to help the compiler figure out type information.</p>
</blockquote>
<hr>
<p>您可能会注意到，与completion模式不同，promise链似乎<br>忽略errors。事实并非如此！事实上，它有相反的效果:promise<br>链使得errors处理更容易访问，也使得errors更难忽略。</p>
<h1 id="catch"><a href="#catch" class="headerlink" title="catch"></a><code>catch</code></h1><p>有了promise，errors就会沿着promise链级联，确保你的应用程序<br>健壮，代码清晰:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// any errors in the whole chain land here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Swift emits a warning if you forget to <code>catch</code> a chain. But we’ll<br>talk about that in more detail later.</p>
</blockquote>
<p>每个promise都是一个对象，代表一个单独的异步任务。<br>如果任务失败， promise就会变成rejected。 Chains that contain rejected<br>包含rejected的promise链跳过所有后续的promise。相反，执行下一个捕获。<br>(严格来说，所有后续的捕获处理程序都会被执行。)</p>
<p><code>completion handler</code>与<code>promise</code>的比较</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>guard</code>和<code>error handler</code>的使用有所帮助，但是promise链<br>可读性不言自明。</p>
<h1 id="ensure"><a href="#ensure" class="headerlink" title="ensure"></a><code>ensure</code></h1><p>我们已经学会了合成异步性。接下来，让我们扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> login()</span><br><span class="line">&#125;.then &#123;</span><br><span class="line">    fetch(avatar: $<span class="number">0</span>.user)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView = $<span class="number">0</span></span><br><span class="line">&#125;.ensure &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管你的链条的结果是什么——失败还是成功 <code>ensure</code><br>handler 总是被调用.</p>
<p><code>ensure</code>模式与其等价的完成处理程序进行比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">        <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对某人来说，修改这个代码并忘记取消设置是非常容易的<br>导致错误的活动指示器。有了promises，这种类型的错误是<br>几乎不可能:Swift编译器拒绝你在没有<br>使用promises。您几乎不需要审查拉动式请求。</p>
<blockquote>
<p><em>Note</em>: PromiseKit has perhaps capriciously switched between the names <code>always</code><br>and <code>ensure</code> for this function several times in the past. Sorry about this. We suck.</p>
</blockquote>
<p>You can also use <code>finally</code> as an <code>ensure</code> that terminates the promise chain and does not return a value:<br>您也可以使用<code>finally</code>作为结束的promise链且不返回值的<code>ensure</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spinner(visible: true)</span><br><span class="line"></span><br><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.catch &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.finally &#123;</span><br><span class="line">    self.spinner(visible: false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h1><p>对多个异步操作的completion handlers反应是缓慢的，意味着连续执行:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operation1 &#123; result1 <span class="keyword">in</span></span><br><span class="line">    operation2 &#123; result2 <span class="keyword">in</span></span><br><span class="line">        finish(result1, result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速(<em>parallel</em>)路径代码使代码不太清晰</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result1: …!</span><br><span class="line"><span class="keyword">var</span> result2: …!</span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">group.enter()</span><br><span class="line">group.enter()</span><br><span class="line">operation1 &#123;</span><br><span class="line">    result1 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">operation2 &#123;</span><br><span class="line">    result2 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    finish(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用Promises就更清晰了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    when(fulfilled: operation1(), operation2())</span><br><span class="line">&#125;.done &#123; result1, result2 <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>when</code> promise代表：等待它们解决并返回包含结果的promise。</p>
<p>与任何promise链一样，如果任何组件promise失败，该链将调用下一个<code>catch</code>。</p>
<h1 id="PromiseKit-Extensions"><a href="#PromiseKit-Extensions" class="headerlink" title="PromiseKit Extensions"></a>PromiseKit Extensions</h1><p>当我们使用PromiseKit, 我们是想想通过promise来实现<br>异步行为。因此，只要有可能，我们会对苹果的APIs进行扩展，重新构建<br>promise方面的应用编程接口。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">CLLocationManager</span>.promise()</span><br><span class="line">&#125;.then &#123; location <span class="keyword">in</span></span><br><span class="line">    <span class="type">CLGeocoder</span>.reverseGeocode(location)</span><br><span class="line">&#125;.done &#123; placemarks <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.placemark.text = <span class="string">"\(placemarks.first)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用这些扩展，您需要指定子代码:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">"PromiseKit"</span></span><br><span class="line">pod <span class="string">"PromiseKit/CoreLocation"</span></span><br><span class="line">pod <span class="string">"PromiseKit/MapKit"</span></span><br></pre></td></tr></table></figure>

<p>All of these extensions are available at the <a href="https://github.com/PromiseKit" target="_blank" rel="noopener">PromiseKit organization</a>.<br>Go there to see what’s available and to read the source code and documentation. Every file and function<br>has been copiously documented.</p>
<blockquote>
<p>We also provide extensions for common libraries such as <a href="https://github.com/PromiseKit/Alamofire-" target="_blank" rel="noopener">Alamofire</a>.</p>
</blockquote>
<h1 id="Making-Promises"><a href="#Making-Promises" class="headerlink" title="Making Promises"></a>Making Promises</h1><p>The standard extensions will take you a long way, but sometimes you’ll still need to start chains<br>of your own. Maybe you’re using a third party API that doesn’t provide promises, or perhaps you wrote<br>your own asynchronous system. Either way, it’s easy to add promises. If you look at the code of the<br>standard extensions, you’ll see that it uses the same approach  described below.</p>
<p>标准的扩展会让你走很长一段路，但是有时候你仍然需要启动链<br>你自己的。也许你使用的是不提供promises的第三方应用编程接口，或者你写道<br>你自己的异步系统。不管怎样，添加promises都很容易。如果你看看<br>标准扩展，您会看到它使用了下面描述的相同方法。</p>
<p>Let’s say we have the following method:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(completion: <span class="params">(String?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>

<p>How do we convert this to a promise? Well, it’s easy:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; fetch(completion: $<span class="number">0</span>.resolve) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You may find the expanded version more readable:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result, error <span class="keyword">in</span></span><br><span class="line">            seal.resolve(result, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>seal</code> object that the <code>Promise</code> initializer provides to you defines<br>many methods for handling garden-variety completion handlers. It even<br>covers a variety of rarer situations, thus making it easy for you to add<br>promises to an existing codebase.</p>
<blockquote>
<p><em>Note</em>: We tried to make it so that you could just do <code>Promise(fetch)</code>, but we<br>were not able to make this simpler pattern work universally without requiring<br>extra disambiguation for the Swift compiler. Sorry; we tried.</p>
</blockquote>
<blockquote>
<p><em>Note</em>: In PMK 4, this initializer provided two parameters to your closure:<br><code>fulfill</code> and <code>reject</code>. PMK 5 and 6 give you an object that has both <code>fulfill</code> and<br><code>reject</code> methods, but also many variants of the method <code>resolve</code>. You can<br>typically just pass completion handler parameters to <code>resolve</code> and let Swift figure<br>out which variant to apply to your particular case (as shown in the example above).</p>
</blockquote>
<blockquote>
<p><em>Note</em> <code>Guarantees</code> (below) have a slightly different initializer (since they<br>cannot error) so the parameter to the initializer closure is just a closure. Not<br>a <code>Resolver</code> object. Thus do <code>seal(value)</code> rather than <code>seal.fulfill(value)</code>. This<br>is because there is no variations in what guarantees can be sealed with, they can<br><em>only</em> fulfill.</p>
</blockquote>
<h1 id="Guarantee-lt-T-gt"><a href="#Guarantee-lt-T-gt" class="headerlink" title="Guarantee&lt;T&gt;"></a><code>Guarantee&lt;T&gt;</code></h1><p>Since PromiseKit 5, we have provided <code>Guarantee</code> as a supplementary class to<br><code>Promise</code>. We do this to complement Swift’s strong error handling system.</p>
<p>Guarantees <em>never</em> fail, so they cannot be rejected. A good example is <code>after</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    after(seconds: 0.1)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    // there is no way to add a `catch` because after cannot fail.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift warns you if you don’t terminate a regular <code>Promise</code> chain (i.e., not<br>a <code>Guarantee</code> chain). You’re expected to silence this warning by supplying<br>either a <code>catch</code> or a <code>return</code>. (In the latter case, you will then have to <code>catch</code><br>at the point where you receive that promise.)</p>
<p>Use <code>Guarantee</code>s wherever possible so that your code has error handling where<br>it’s required and no error handling where it’s not required.</p>
<p>In general, you should be able to use <code>Guarantee</code>s and <code>Promise</code>s interchangeably,<br>We have gone to great lengths to try and ensure this, so please open a ticket<br>if you find an issue.</p>
<hr>
<p>If you are creating your own guarantees the syntax is simpler than that of promises;</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result <span class="keyword">in</span></span><br><span class="line">            seal(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which could be reduced to:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span>(resolver: fetch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map-compactMap-etc"><a href="#map-compactMap-etc" class="headerlink" title="map, compactMap, etc."></a><code>map</code>, <code>compactMap</code>, etc.</h1><p><code>then</code> provides you with the result of the previous promise and requires you to return<br>another promise.</p>
<p><code>map</code> provides you with the result of the previous promise and requires you to return<br>an object or value type.</p>
<p><code>compactMap</code> provides you with the result of the previous promise and requires you<br>to return an <code>Optional</code>. If you return <code>nil</code>, the chain fails with<br><code>PMKError.compactMap</code>.</p>
<blockquote>
<p><em>Rationale</em>: Before PromiseKit 4, <code>then</code> handled all these cases, and it was<br>painful. We hoped the pain would disappear with new Swift versions. However,<br>it has become clear that the various pain points are here to stay. In fact, we<br>as library authors are expected to disambiguate at the naming level of our API.<br>Therefore, we have split the three main kinds of <code>then</code> into <code>then</code>, <code>map</code> and<br><code>done</code>. After using these new functions, we realized this is much nicer in practice,<br>so we added <code>compactMap</code> as well (modeled on <code>Optional.compactMap</code>).</p>
</blockquote>
<p><code>compactMap</code> facilitates quick composition of promise chains. For example:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">URLSession</span>.shared.dataTask(.promise, with: rq)</span><br><span class="line">&#125;.compactMap &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject($<span class="number">0</span>.data) <span class="keyword">as</span>? [<span class="type">String</span>]</span><br><span class="line">&#125;.done &#123; arrayOfStrings <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// Foundation.JSONError if JSON was badly formed</span></span><br><span class="line">    <span class="comment">// PMKError.compactMap if JSON was of different type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>Tip</em>: We also provide most of the functional methods you would expect for sequences,<br>e.g., <code>map</code>, <code>thenMap</code>, <code>compactMapValues</code>, <code>firstValue</code>, etc.</p>
</blockquote>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h1><p>We provide <code>get</code> as a <code>done</code> that returns the value fed to <code>get</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.<span class="keyword">get</span> &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.done &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// same foo!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="tap"><a href="#tap" class="headerlink" title="tap"></a><code>tap</code></h1><p>We provide <code>tap</code> for debugging. It’s the same as <code>get</code> but provides the<br><code>Result&lt;T&gt;</code> of the <code>Promise</code> so you can inspect the value of the chain at this<br>point without causing any side effects:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.tap &#123;</span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Supplement"><a href="#Supplement" class="headerlink" title="Supplement"></a>Supplement</h1><h2 id="firstly"><a href="#firstly" class="headerlink" title="firstly"></a><code>firstly</code></h2><p>We’ve used <code>firstly</code> several times on this page, but what is it, really? In fact,<br>it is just <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener">syntactic sugar</a>.<br>You don’t really need it, but it </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>PromiseKit</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift</title>
    <url>/2019/11/04/RxSwift/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/11/04/Vue/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>C++重温</title>
    <url>/2019/11/04/C++%E9%87%8D%E6%B8%A9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础</title>
    <url>/2019/11/04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC</title>
    <url>/2019/11/04/WebRTC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg</title>
    <url>/2019/11/04/FFmpeg/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础01</title>
    <url>/2019/11/02/Python%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基础01</title>
    <url>/2019/11/01/Swift%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="使用let关键字来声明常量"><a href="#使用let关键字来声明常量" class="headerlink" title="使用let关键字来声明常量"></a>使用let关键字来声明常量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="使用var关键字来声明变量"><a href="#使用var关键字来声明变量" class="headerlink" title="使用var关键字来声明变量"></a>使用var关键字来声明变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var temp = 0</span><br><span class="line">temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="可以在一行中声明多个变量或常量，用逗号分隔"><a href="#可以在一行中声明多个变量或常量，用逗号分隔" class="headerlink" title="可以在一行中声明多个变量或常量，用逗号分隔"></a>可以在一行中声明多个变量或常量，用逗号分隔</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var x=0.1, y=10.1, z=1.0</span><br></pre></td></tr></table></figure>
<h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><p>在声明一个变量或常量的时候提供类型标注，来明确变量或常量能够储存值的类型</p>
<p>添加类型标注的方法是在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称</p>
<p>可以在一行中定义多个相关的变量为相同类型，用逗号分隔，只要在最后的变量名字后边加上类型标注</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var msg: String</span><br><span class="line">msg = <span class="string">"message"</span></span><br></pre></td></tr></table></figure>

<h3 id="变量和常量命名"><a href="#变量和常量命名" class="headerlink" title="变量和常量命名"></a>变量和常量命名</h3><p>几乎可以使用任何自负，甚至包括Unicode字符</p>
<p>不能包括空白字符、数学符号、箭头、保留的（或无效的）Unicode码位、连线和制表符。也不能以数字开头。</p>
<h3 id="打印常量和变量"><a href="#打印常量和变量" class="headerlink" title="打印常量和变量"></a>打印常量和变量</h3><p>print</p>
<p>字符串插值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">"show string"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"显示str\(str)"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>8，16，32，64位编码的有符号和无符号整数（例如：UInt8,Int8）</p>
<p>通过min和max属性访问每个整数类型的最小值和最大值</p>
<p>Int，拥有与当前平台的原生字相同的长度；UInt，与平台长度相关的无符号整数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"UInt8 min \(UInt8.min), UInt8 max \(UInt8.max)"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p> Double 64位浮点数，至少有15位数字的精度</p>
<p> Float 32位浮点数，至少有6位数字的精度</p>
<h3 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h3><p>表示true和false</p>
<p>Swift的类型安全机制会阻止你用一个非布尔量的值替代掉Bool</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p><img src="/2019/11/01/Swift%E5%9F%BA%E7%A1%8001/Swift_%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4.png" alt="Swift_数值范围"></p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p> 类型别名是一个为已存在类型定义的一个可选择的名字<br> <code>typealias</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typealias AudioSample = UInt8</span><br><span class="line"><span class="built_in">let</span> sample: AudioSample = 32</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><h3 id="使用Tuple组合多个值"><a href="#使用Tuple组合多个值" class="headerlink" title="使用Tuple组合多个值"></a>使用Tuple组合多个值</h3><p>元组把多个值合并成单一的复合型的值</p>
<p>元组内的值可以是任何类型，而且可以不必是同一类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.0)</span><br><span class="line"><span class="built_in">print</span>(error.1)</span><br></pre></td></tr></table></figure>
<h3 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h3><p>元组中的每一个元素可以制定对应的元素名称</p>
<p>如果没有制定名称的元素也可以使用下标的方式来引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (error: 1,  errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.error)</span><br><span class="line"><span class="built_in">print</span>(error.errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="Tuple修改"><a href="#Tuple修改" class="headerlink" title="Tuple修改"></a>Tuple修改</h3><p>用var定义的元组就是可变元组，let定义的就是不可变元组</p>
<p><code>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</code></p>
<p>可以对可变元组的元素进行修改，但是不能改变其类型</p>
<p>Any类型可以改为任何类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var error:(errorCode: Int, errorMsg:Any) = (errorCode: 1, errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMsg = 3</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>可以将一个元组的内容分解成单独的常量或变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (error, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<p>如果只需要使用其中的一部分数据，不需要的数据可以用下划线<code>_</code>代替</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (_, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h3><p>使用Tuple为函数返回多个值</p>
<p>返回值的Tuple可以在函数的返回类型部分被命名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func requestWithUrl(url: String) -&gt; (errorCode: Int, errorMsg: String) &#123;</span><br><span class="line">    <span class="built_in">return</span> (1, <span class="string">"没有权限"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> error = requestWithUrl(url: <span class="string">""</span>)</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>通过在变量类型后面加<code>?</code>表示：这里有一个值，它表示x，或者这里根本没有值</p>
<p>可以通过给可选变量赋值一个nil来将之设置为没有值</p>
<p>在Swift中，nil不是指针，他是值缺失的一种特殊类型，任何类型的可选类项都可以设置成nil而不仅仅是对西那个类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = nil</span><br></pre></td></tr></table></figure>

<h3 id="Optional-if"><a href="#Optional-if" class="headerlink" title="Optional-if"></a>Optional-if</h3><p>可选项是没法直接食用的，需要用!展开之后才能使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> str != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h3><p>可以使用可选项的绑定来判断是否包含值，如果包含就把值赋给一个临时的常量或者变量</p>
<p>可选绑定可以与if和while的语句使用来检查可选项内部的值，并赋值给一个变量或常量 </p>
<p>同一个if语句中包含多个可选项绑定时，用逗号分隔开即可。如果人一个选项绑定结果是nil或者布尔值为false，那么整个if判断会被看作false</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> actualStr = str &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-隐式展开"><a href="#Optional-隐式展开" class="headerlink" title="Optional-隐式展开"></a>Optional-隐式展开</h3><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开</p>
<p>通过在声明的类型后边添加一个叹号<code>!</code>而非问好来书写隐式展开可选项</p>
<p>隐式展开可选项主要被用于Swift类的初始化过程中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String! = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str!.count</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<h3 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h3><p>可选项后面加问号</p>
<p>如果可选项不为nil，返回一个可选项结果，否则返回nil</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str?.count</span><br><span class="line"><span class="keyword">if</span> count != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> lastIndex = count! - 1</span><br><span class="line">    <span class="built_in">print</span>(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var emptyString = <span class="string">""</span></span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(Noting<span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字符串字面亮是被双引号<code>&quot;</code>包裹的固定顺序的文本字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str = <span class="string">"some string"</span></span><br></pre></td></tr></table></figure>

<h3 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h3><p>字多行符串字面量是被三个双引号<code>&quot;&quot;&quot;</code>引起来的一系列字符</p>
<p>开始和结束默认不会有换行符</p>
<p>反斜杠只会在代码阅读上方便，输出时没有实际的换行功能<code>\</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">""</span><span class="string">"var emptyString = "</span><span class="string">" \</span></span><br><span class="line"><span class="string">var anotherEmptyString = String() \</span></span><br><span class="line"><span class="string">if emptyString.isEmpty &#123; \</span></span><br><span class="line"><span class="string">    print(Noting"</span>) \</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">print(str)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h3><p>转义特殊字符</p>
<p>任意的Unicode标量  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展字符串分隔符"><a href="#扩展字符串分隔符" class="headerlink" title="扩展字符串分隔符"></a>扩展字符串分隔符</h3><p>在字符串字面量中放置扩展分隔符来在字符串中包含特殊字符而不让它们真的生效</p>
<p>将字符串放在双引号内并由井号#包裹</p>
<p>如果字符串里有”#则首尾需要两个##(首尾##与包含的”#不一样即可)</p>
<p>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的#号数量的#号，并在前面添加转义符号\</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\n\n444"#</span></span><br><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\#n\n444"#</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的可变形"><a href="#字符串的可变形" class="headerlink" title="字符串的可变形"></a>字符串的可变形</h3><p>var 可修改<br>let 不可修改</p>
<h3 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h3><p>String 值在传递给方法或者函数的时候会被复制过去</p>
<p>赋值给常量和变量的时候也是一样</p>
<h3 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h3><p>for-in 循环遍历String中的每一个独立的Character</p>
<p>Character类型</p>
<p>String值可以通过传入Character 数组来构造</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"abcdef"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> tempCharacters: [Character] = [<span class="string">"d"</span>,<span class="string">"f"</span>,<span class="string">"d"</span>,<span class="string">"h"</span>]</span><br><span class="line"><span class="built_in">let</span> str = String(tempCharacters)</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>通过加运算符<code>+</code>创建新字符串</p>
<p>使用加赋值符号<code>+=</code>在已经存在的String值末尾追加一个String值</p>
<p>使用String类型的<code>append()</code>方法来给一个String变量的末尾追加character值</p>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p><code>\(some)</code> some代表：混合常量、变量、字面量和表达式的字符串面量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="comment">#"1 * 3 = \#(1*3)."#)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>每个String值都有相关的索引类型，String.index，它相当于每个Character在字符串重的位置</p>
<p>startIndex属性来访问String中第一个Character的位置。endIndex属性就是String中最后一个字符后的位置</p>
<p>endIndex属性并不是字符串下表脚本的合法实际参数</p>
<p>如果String为空，则startIndex与endIndex相等</p>
<p>使用index(before:)和index(after:)方法来访问给定索引的前后</p>
<p>要访问给定索引更远的索引，你可以使用index(_:offsetBy:)</p>
<p>使用indices属性来访问字符串中每个字符的索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> hello = <span class="string">"hello"</span></span><br><span class="line">hello[hello.startIndex]</span><br><span class="line">hello[hello.index(before: hello.endIndex)]</span><br><span class="line">hello[hello.index(after: hello.startIndex)]</span><br><span class="line"><span class="built_in">let</span> index = hello.index(hello.startIndex, offsetBy: 2)</span><br><span class="line">hello[index]</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入字符，使用insert(_:at:)方法</p>
<p>插入另一个字符串的内容到特定的索引，使用insert(contentsOs:at:)方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, at: welcome.endIndex)</span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf: <span class="string">"ererer"</span>, at: welcome.index(before: welcome.endIndex))</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>移除字符串remove(at:)</p>
<p>移除特定范围的字符串removeSubrange(range)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> range = welcome.index(welcome.endIndex, offsetBy: -1)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br></pre></td></tr></table></figure>

<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>使用下表或者累死prefix(_:)的方法得到的子字符串是SubString类型</p>
<p>SubString拥有String的大部分方法</p>
<p>SubString可以转成String类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> index3 = hello.lastIndex(of: <span class="string">"o"</span>) ?? hello.endIndex</span><br><span class="line"><span class="built_in">let</span> begin = hello[..&lt;index3]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> newHello = String(begin)</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>字符串和字符相等性(==和==)</p>
<p>前缀相等hasPrefix(_:)</p>
<p>后缀相等hasSuffix(_:)</p>
<h2 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a>赋值和算术运算符</h2><p>一元运算符、二元运算符、三元运算符</p>
<p>赋值运算符不会返回值</p>
<h2 id="如何处理算术结果溢出"><a href="#如何处理算术结果溢出" class="headerlink" title="如何处理算术结果溢出"></a>如何处理算术结果溢出</h2><p>在默认情况下，当一个整数赋超过它容量的值时，Swift会报错而不是生成一个无效的数，给我们操作过大或者过小的数的时候提供了额外的安全性</p>
<p>同时提供了三个算术溢出运算符来让系统支持整数溢出的运算</p>
<p>溢出加法<code>&amp;+</code></p>
<p>溢出减法<code>&amp;-</code></p>
<p>溢出乘法<code>&amp;*</code></p>
<h3 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h3><p>溢出也会发生在有符号整形数值上</p>
<p>对于无符号与有符号整形数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
<h2 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符??"></a>合并空值运算符<code>??</code></h2><p>合并空值运算符(a??b)如果选项a有值则展开，如果没有值，是nil，则返回默认值b</p>
<p>表达式a必须是一个可选类型。表达式b必须与a的存储类型相同。</p>
<p>实际上它就是相当于三目运算符<code>_?_:_</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func addTwoNum(num1: Int?, num2: Int2?) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> (num1 ?? 0) +(num2 ?? 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><h3 id="闭区间运算符a-b"><a href="#闭区间运算符a-b" class="headerlink" title="闭区间运算符a...b"></a>闭区间运算符<code>a...b</code></h3><p>定义了从a到b的一组范围，并且包含a和b</p>
<p>a的值不能大于b的值</p>
<h3 id="半开区间运算符a-lt-b"><a href="#半开区间运算符a-lt-b" class="headerlink" title="半开区间运算符a..&lt;b"></a>半开区间运算符<code>a..&lt;b</code></h3><p>定义了从a到b但不包含b的区间</p>
<p>a的值不能大于b的值，如果a与b的值相等，那返回的区间将会是空的</p>
<h3 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h3><p>比如说，一个包含数组所有的元素的区间，从索引2到数组的结束。在这种情况下，你可以省略区间运算符一侧的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[2...] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[...2] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倒序索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (0..&lt;10&gt;).<span class="function"><span class="title">reversed</span></span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间运算符在字符串上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> range = welcome.startIndex...welcome.index(welcome.endIndex, offsetBy: -6)</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(welcome)]</span><br></pre></td></tr></table></figure>

<p>区间运算符在比较类型上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> interval = <span class="string">"a"</span>...<span class="string">"z"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> welcome &#123;</span><br><span class="line">    <span class="keyword">if</span> !interval.contains(String(c)) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(c)不是小写字母"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符"></a>位取反运算符</h3><p>位取反运算符(~)是对所有位的数字进行取反操作</p>
<h3 id="位与运算符"><a href="#位与运算符" class="headerlink" title="位与运算符"></a>位与运算符</h3><p>位与运算符(&amp;)是对两个数的比特位进行合并。它会返回一个新的数，只有当这两个数都是1的时候才能返回1。</p>
<h3 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符"></a>位或运算符</h3><p>位或运算符(|)是对两个数的比特位进行比较。它会返回一个新的数，只要两个操作位任意一个为1时，那么对应的位数就为1。</p>
<h3 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符"></a>位异或运算符</h3><p>位异或运算符(^))，当两个操作数的对应位不相同时，那么该数对应的位数就为1。</p>
<h3 id="位左移和右移运算符"><a href="#位左移和右移运算符" class="headerlink" title="位左移和右移运算符"></a>位左移和右移运算符</h3><p>位左移(&lt;&lt;)和右移运算符(&gt;&gt;)可以吧所有位数的数字向左或向右移动一个确定的位数。</p>
<p>位座椅和右移具有给整数乘以或除以二的效果。将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。</p>
<h3 id="无符号整数的唯一操作"><a href="#无符号整数的唯一操作" class="headerlink" title="无符号整数的唯一操作"></a>无符号整数的唯一操作</h3><p>用0填充左移或右移后产生的空白位</p>
<h3 id="有符号整数的移位操作"><a href="#有符号整数的移位操作" class="headerlink" title="有符号整数的移位操作"></a>有符号整数的移位操作</h3><p>第一位表示整数还是负数（0正数，1负数）</p>
<h3 id="位运算符应用"><a href="#位运算符应用" class="headerlink" title="位运算符应用"></a>位运算符应用</h3><ul>
<li>两个数字交换</li>
<li>求赋符号整形数二进制中1的个数</li>
<li>判断一个整数是否为为2的整数次幂</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"></span><br><span class="line">$ hexo d --g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
