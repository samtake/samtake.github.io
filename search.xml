<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>golang练习笔记</title>
    <url>/2019/11/21/golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableZeroValue</span></span>() &#123;</span><br><span class="line">	var a int</span><br><span class="line">	var s string</span><br><span class="line">	fmt.Printf(<span class="string">"%d %q\n"</span>, a, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableInitialValue</span></span>() &#123;</span><br><span class="line">	var a, b int = 3, 4</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型推断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableTypeDeduction</span></span>() &#123;</span><br><span class="line">	var a, b, c, d = 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>利用冒号定义的简单写法  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableShorter</span></span>() &#123;</span><br><span class="line">	a, b, c, d := 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	b = 6</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数外的变量定义(不能使用冒号定义，且它的作用域只在该包内部)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var aa = 55</span><br><span class="line">var ss = <span class="string">"llll"</span></span><br><span class="line">var bb = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">	bbb = 666</span><br><span class="line">	sss = <span class="string">"jjj"</span></span><br><span class="line">	ttt = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h2><p><code>bool</code>, <code>string</code>,</p>
<p><code>(u)int</code>, <code>(u)int8</code>, <code>(u)int16</code>, <code>(u)int32</code>, <code>(u)int64</code>, <code>uintptr</code>,</p>
<p><code>byte</code>, <code>rune</code>,</p>
<p><code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>,</p>
<h2 id="常量与枚举"><a href="#常量与枚举" class="headerlink" title="常量与枚举"></a>常量与枚举</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> func <span class="function"><span class="title">consts</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	const a, b = 3, 4</span><br><span class="line">	var c int</span><br><span class="line">	c = int(math.Sqrt(a*a + b + b))</span><br><span class="line">	fmt.Println(filename, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">enums</span></span>() &#123;</span><br><span class="line">	const (</span><br><span class="line">		cpp = iota</span><br><span class="line">		java</span><br><span class="line">		golang</span><br><span class="line">		swift</span><br><span class="line">		_</span><br><span class="line">		C</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	const (</span><br><span class="line">		b = 1 &lt;&lt; (10 * iota)</span><br><span class="line">		bb</span><br><span class="line">		bbb</span><br><span class="line">		bbbb</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	fmt.Println(cpp, java, golang, C)</span><br><span class="line">	fmt.Println(b, bb, bbb, bbbb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abc.txt 4</span><br><span class="line">0 1 2 5</span><br><span class="line">1 1024 1048576 1073741824</span><br></pre></td></tr></table></figure>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if的条件里可以赋值<br>if的条件里赋值的变量作用域就在这个if语句里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	<span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch后面可以没有表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func grade(score int) string &#123;</span><br><span class="line">	g := <span class="string">""</span></span><br><span class="line">	switch &#123;</span><br><span class="line">	<span class="keyword">case</span> score &lt; 0 || score &gt; 100:</span><br><span class="line">		panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	<span class="keyword">case</span> score &lt; 60:</span><br><span class="line">		g = <span class="string">"F"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 80:</span><br><span class="line">		g = <span class="string">"C"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 90:</span><br><span class="line">		g = <span class="string">"B"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 100:</span><br><span class="line">		g = <span class="string">"A"</span></span><br><span class="line">		// default:</span><br><span class="line">		// 	panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func convertToBin(n int) string &#123;</span><br><span class="line">	res := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> ; n &gt; 0; n /= 2 &#123;</span><br><span class="line">		lsb := n % 2</span><br><span class="line">		res = strconv.Itoa(lsb) + res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printFile(filename string) &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	scanner := bufio.NewScanner(file)</span><br><span class="line">	<span class="keyword">for</span> scanner.<span class="function"><span class="title">Scan</span></span>() &#123;</span><br><span class="line">		fmt.Println(scanner.Text)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">forever</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"abc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func div(a, b int) (q, r int) &#123;</span><br><span class="line">	// <span class="built_in">return</span> a / b, a % b</span><br><span class="line">	q = a / b</span><br><span class="line">	r = a % b</span><br><span class="line">	<span class="built_in">return</span> q, r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func pow(a, b int) int &#123;</span><br><span class="line">	<span class="built_in">return</span> int(math.Pow(float64(a), float64(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func apply(op func(int, int) int, a, b int) int &#123;</span><br><span class="line">	p := reflect.ValueOf(op).Pointer()</span><br><span class="line">	opName := runtime.FuncForPC(p).Name()</span><br><span class="line">	fmt.Printf(<span class="string">"Calling function %s with args "</span>+<span class="string">"(%d,%d)"</span>, opName, a, b)</span><br><span class="line">	<span class="built_in">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	q, r := div(8, 6)</span><br><span class="line">	fmt.Println(q, r)</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(pow, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者以匿名函数的形式进行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(</span><br><span class="line">		func(a int, b int) int &#123;</span><br><span class="line">			<span class="built_in">return</span> int(math.Pow(</span><br><span class="line">				float64(a), float64(b)))</span><br><span class="line">		&#125;, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func sum(numbers ...int) int &#123;</span><br><span class="line">	s := 0</span><br><span class="line">	<span class="keyword">for</span> i := range numbers &#123;</span><br><span class="line">		s += numbers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>参数传递</p>
<ul>
<li><p>go语言只有值传递一种方式<br><code>var a int</code> 当参数传递给<code>fun f(pa *int)</code>它其实就是将a的指针&amp;a拷贝一份传递给pa,pa也跟&amp;a一样，同时指向a</p>
</li>
<li><p>再如：<code>var cache Cache</code> 当参数传递给<code>func f(cache Cache)</code>,参数Cache那么大不可能拷贝一份的，实际上Cache也只是一个指向data的指针，所以cache当参数的时候，它只是拷贝了一份指针，它同时也指向了data</p>
</li>
</ul>
<p>交换两个变量的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func swap(a, b int) &#123;</span><br><span class="line">	b, a = a, b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(a, b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  hello go run point.go</span><br><span class="line">3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>我们发现值没有变，这是需要使用指针，将a,b所指向的值改变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) &#123;</span><br><span class="line">	*b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(&amp;a, &amp;b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var arr1 [5]int</span><br><span class="line">	arr2 := [3]int&#123;1, 2, 3&#125;      //冒号等于的定义，需要给数组一个初值</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; //或者不指定数组个数</span><br><span class="line">	fmt.Println(arr1, arr2, arr3)</span><br><span class="line"></span><br><span class="line">	//二维数组定义</span><br><span class="line">	var grid [4][5]int</span><br><span class="line">	fmt.Println(grid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := 0; i &lt; len(arr3); i++ &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>下标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := range arr3 &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>下标和值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>数组是值类型的，所以当参数用的时候需要指定长度<code>cannot use arr1 (type [5]int) as type [4]int in argument to printArray</code>，且在函数里面再次赋值后，它在外面是不会改变的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printArray(arr [4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，依旧是1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以，[10]int和[20]int 是不同类型；调用func f(arr [10]int)会拷贝数组。需要改变它就需要用到指针了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; </span><br><span class="line"></span><br><span class="line">	printArray(&amp;arr3)</span><br><span class="line">	fmt.Println(arr3, arr3[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printArray(arr *[4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，改变为100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	//s := arr[2:6]</span><br><span class="line">	fmt.Println(<span class="string">"arr[2:6] ="</span>, arr[2:6])</span><br><span class="line">	fmt.Println(<span class="string">"arr[:6] ="</span>, arr[:6])</span><br><span class="line">	fmt.Println(<span class="string">"arr[2:] ="</span>, arr[2:])</span><br><span class="line">	fmt.Println(<span class="string">"arr[:] ="</span>, arr[:])</span><br><span class="line"></span><br><span class="line">	s1 := arr[2:]</span><br><span class="line">	s2 := arr[:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s1"</span>)</span><br><span class="line">	updateSlice(s1)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s2"</span>)</span><br><span class="line">	updateSlice(s2)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"printArray"</span>)</span><br><span class="line">	printArray(arr[:])</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"reslice"</span>)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[:5]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[2:]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr[2:6] = [2 3 4 5]</span><br><span class="line">arr[:6] = [0 1 2 3 4 5]</span><br><span class="line">arr[2:] = [2 3 4 5 6 7]</span><br><span class="line">arr[:] = [0 1 2 3 4 5 6 7]</span><br><span class="line">after updateSlice(s1</span><br><span class="line">[100 3 4 5 6 7]</span><br><span class="line">[0 1 100 3 4 5 6 7]</span><br><span class="line">after updateSlice(s2</span><br><span class="line">[100 1 100 3 4 5 6 7]</span><br><span class="line">[100 1 100 3 4 5 6 7]</span><br><span class="line">printArray</span><br><span class="line">0 100</span><br><span class="line">1 50</span><br><span class="line">2 100</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">reslice</span><br><span class="line">[100 50 100 3 4 5 6 7]</span><br><span class="line">[100 50 100 3 4]</span><br><span class="line">[100 3 4]</span><br></pre></td></tr></table></figure>
<p>slice可以向后扩展，不可以向前扩展<br>s[i]不可以超越len(s)，向后扩展不可以超越底层数组 cap(s)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceExtension</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"sliceExtension"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]</span><br><span class="line">	s2 := s1[3:5]</span><br><span class="line">	fmt.Println(<span class="string">"s1="</span>, s1)</span><br><span class="line">	fmt.Println(<span class="string">"s2="</span>, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sliceExtension</span><br><span class="line">s1= [2 3 4 5]</span><br><span class="line">s2= [5 6]</span><br></pre></td></tr></table></figure>


<p>向slice添加元素时，如果超越了cap，系统会重新分配更大的底层数组<br>新的slice里面， ptr len cap都会变掉，所以必须接收append的返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceAppend</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"slice append"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]       //2 3 4 5</span><br><span class="line">	s2 := s1[3:5]        //5 6</span><br><span class="line">	s3 := append(s2, 10) //5 6 10</span><br><span class="line">	s4 := append(s3, 11) //5 6 10 11</span><br><span class="line">	s5 := append(s4, 12) //5 6 10 11 12</span><br><span class="line">	fmt.Println(<span class="string">"s3="</span>, s3)</span><br><span class="line">	fmt.Println(<span class="string">"s4="</span>, s4)</span><br><span class="line">	fmt.Println(<span class="string">"s5="</span>, s5)</span><br><span class="line">	fmt.Println(<span class="string">"arr="</span>, arr) //0, 1, 2, 3, 4, 5, 6 10  数组长度不变的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice的创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceCreate</span></span>() &#123;</span><br><span class="line">	var s []int</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		printSlice(s)</span><br><span class="line">		s = append(s, 2*i+1)</span><br><span class="line">	&#125;</span><br><span class="line">	println(s)</span><br><span class="line"></span><br><span class="line">	s1 := []int&#123;2, 3, 5, 6, 8, 2, 5&#125;</span><br><span class="line">	println(s1)</span><br><span class="line"></span><br><span class="line">	s2 := make([]int, 16)</span><br><span class="line">	s3 := make([]int, 10, 32) //32是开辟的空间<span class="built_in">cap</span></span><br><span class="line">	println(<span class="string">"print Slice  s2 s3"</span>)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">	printSlice(s3)</span><br><span class="line"></span><br><span class="line">	println(<span class="string">"Slice copy"</span>)</span><br><span class="line">	copy(s2, s1) //将s1复制给s2</span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">	//如何删除8</span><br><span class="line">	println(<span class="string">"Slice delete"</span>)</span><br><span class="line">	s2 = append(s2[:4], s2[5:]...)</span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//删除头尾</span><br><span class="line">	fmt.Println(<span class="string">"pop from front"</span>)</span><br><span class="line">	front := s2[0]</span><br><span class="line">	s2 = s2[1:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"pop from back"</span>)</span><br><span class="line">	back := s2[len(s2)-1]</span><br><span class="line">	s2 = s2[:len(s2)-1]</span><br><span class="line">	fmt.Println(front, back)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> Slice  s2 s3</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0], len=10, <span class="built_in">cap</span>= 32</span><br><span class="line">Slice copy</span><br><span class="line">[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">Slice delete</span><br><span class="line">[2 3 5 6 2 5 0 0 0 0 0 0 0 0 0], len=15, <span class="built_in">cap</span>= 16</span><br><span class="line">pop from front</span><br><span class="line">pop from back</span><br><span class="line">2 0</span><br><span class="line">[3 5 6 2 5 0 0 0 0 0 0 0 0], len=13, <span class="built_in">cap</span>= 15</span><br></pre></td></tr></table></figure>



<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	m := map[string]string&#123;</span><br><span class="line">		<span class="string">"name"</span>:  <span class="string">"sam"</span>,</span><br><span class="line">		<span class="string">"class"</span>: <span class="string">"go"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	m2 := make(map[string]int)</span><br><span class="line"></span><br><span class="line">	var m3 map[string]int</span><br><span class="line"></span><br><span class="line">	fmt.Println(m2, m3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>遍历，key在map里是无序的～</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := range m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当key打错了，获取到的是空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取值</span><br><span class="line">	fmt.Println(<span class="string">"getting values"</span>)</span><br><span class="line">	name := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name)</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">	println(name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	println(<span class="string">"key does not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//删除</span><br><span class="line">	fmt.Println(<span class="string">"delete values"</span>)</span><br><span class="line">	name1, ok := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name1, ok)</span><br></pre></td></tr></table></figure>

<p>map的key的类型可以是<br>除了slice,map,function的内建类型都可以作为key<br>struct类型不包含上述字段，也可以作为key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<pre><code class="bash"></code></pre>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>AFN表单形式提交图片</title>
    <url>/2019/11/15/AFN%E8%A1%A8%E5%8D%95%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BA%A4%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>PromiseKit</title>
    <url>/2019/11/05/PromiseKit/</url>
    <content><![CDATA[<h1 id="then-and-done"><a href="#then-and-done" class="headerlink" title="then and done"></a><code>then</code> and <code>done</code></h1><p>典型使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这段代码使用了<code>completion handlers</code>，它将如下所示:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> creds = creds &#123;</span><br><span class="line">        fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> image = image &#123;</span><br><span class="line">                <span class="keyword">self</span>.imageView = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>then</code> 只是构造<code>completion handlers</code>的另一种方式, 但也远不止如此。在我们理解的最初阶段，它主要有助于可读性。上面的<code>promise链</code>很容易浏览和理解:一个异步操作一行一行地通向另一个。鉴于Swift的当前状态，它尽可能接近程序代码。</p>
<p><code>done</code> 和 <code>then</code> ，但是你不能返回一个<code>promise</code>. 这通常是链条中<code>success</code>部分的终点. 上面, 您可以看到我们在 <code>done</code> 时收到了最终的图像，并使用它来设置用户界面。</p>
<p>两种实现方法的比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Creds</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Compared with:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(completion: <span class="params">(Creds?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">                        <span class="comment">// ^^ ugh. Optionals. Double optionals.</span></span><br></pre></td></tr></table></figure>

<p>区别在于，对于<code>Promise</code>，您的函数返回<code>Promise</code>，而不是接受和运行回调。链中的每个<code>handler</code>都会返回一个<code>Promise</code>。<code>Promise</code>对象定义了<code>then</code>方法，该方法在链的执行之前等待<code>Promise</code>的完成。锁链按程序解决，一次一个<code>Promise</code>。</p>
<p><code>Promise</code> 代表异步任务的返回值。它有一个表示它包装的对象类型的类型。例如，在上面的例子中，<code>login</code>是一个返回<code>Promise</code>的函数，该<code>Promise</code>将代表Creds实例。</p>
<blockquote>
<p><em>Note</em>: <code>done</code> is new to PromiseKit 5. We previously defined a variant of <code>then</code> that<br>did not require you to return a promise. Unfortunately, this convention often confused<br>Swift and led to odd and hard-to-debug error messages. It also made using PromiseKit<br>more painful. The introduction of <code>done</code> lets you type out promise chains that<br>compile without additional qualification to help the compiler figure out type information.</p>
</blockquote>
<hr>
<p>您可能会注意到，与completion模式不同，promise链似乎<br>忽略errors。事实并非如此！事实上，它有相反的效果:promise<br>链使得errors处理更容易访问，也使得errors更难忽略。</p>
<h1 id="catch"><a href="#catch" class="headerlink" title="catch"></a><code>catch</code></h1><p>有了promise，errors就会沿着promise链级联，确保你的应用程序<br>健壮，代码清晰:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// any errors in the whole chain land here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Swift emits a warning if you forget to <code>catch</code> a chain. But we’ll<br>talk about that in more detail later.</p>
</blockquote>
<p>每个promise都是一个对象，代表一个单独的异步任务。<br>如果任务失败， promise就会变成rejected。 Chains that contain rejected<br>包含rejected的promise链跳过所有后续的promise。相反，执行下一个捕获。<br>(严格来说，所有后续的捕获处理程序都会被执行。)</p>
<p><code>completion handler</code>与<code>promise</code>的比较</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>guard</code>和<code>error handler</code>的使用有所帮助，但是promise链<br>可读性不言自明。</p>
<h1 id="ensure"><a href="#ensure" class="headerlink" title="ensure"></a><code>ensure</code></h1><p>我们已经学会了合成异步性。接下来，让我们扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> login()</span><br><span class="line">&#125;.then &#123;</span><br><span class="line">    fetch(avatar: $<span class="number">0</span>.user)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView = $<span class="number">0</span></span><br><span class="line">&#125;.ensure &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管你的链条的结果是什么——失败还是成功 <code>ensure</code><br>handler 总是被调用.</p>
<p><code>ensure</code>模式与其等价的完成处理程序进行比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">        <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对某人来说，修改这个代码并忘记取消设置是非常容易的<br>导致错误的活动指示器。有了promises，这种类型的错误是<br>几乎不可能:Swift编译器拒绝你在没有<br>使用promises。您几乎不需要审查拉动式请求。</p>
<blockquote>
<p><em>Note</em>: PromiseKit has perhaps capriciously switched between the names <code>always</code><br>and <code>ensure</code> for this function several times in the past. Sorry about this. We suck.</p>
</blockquote>
<p>You can also use <code>finally</code> as an <code>ensure</code> that terminates the promise chain and does not return a value:<br>您也可以使用<code>finally</code>作为结束的promise链且不返回值的<code>ensure</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spinner(visible: true)</span><br><span class="line"></span><br><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.catch &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.finally &#123;</span><br><span class="line">    self.spinner(visible: false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h1><p>对多个异步操作的completion handlers反应是缓慢的，意味着连续执行:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operation1 &#123; result1 <span class="keyword">in</span></span><br><span class="line">    operation2 &#123; result2 <span class="keyword">in</span></span><br><span class="line">        finish(result1, result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速(<em>parallel</em>)路径代码使代码不太清晰</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result1: …!</span><br><span class="line"><span class="keyword">var</span> result2: …!</span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">group.enter()</span><br><span class="line">group.enter()</span><br><span class="line">operation1 &#123;</span><br><span class="line">    result1 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">operation2 &#123;</span><br><span class="line">    result2 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    finish(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用Promises就更清晰了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    when(fulfilled: operation1(), operation2())</span><br><span class="line">&#125;.done &#123; result1, result2 <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>when</code> promise代表：等待它们解决并返回包含结果的promise。</p>
<p>与任何promise链一样，如果任何组件promise失败，该链将调用下一个<code>catch</code>。</p>
<h1 id="PromiseKit-Extensions"><a href="#PromiseKit-Extensions" class="headerlink" title="PromiseKit Extensions"></a>PromiseKit Extensions</h1><p>当我们使用PromiseKit, 我们是想想通过promise来实现<br>异步行为。因此，只要有可能，我们会对苹果的APIs进行扩展，重新构建<br>promise方面的应用编程接口。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">CLLocationManager</span>.promise()</span><br><span class="line">&#125;.then &#123; location <span class="keyword">in</span></span><br><span class="line">    <span class="type">CLGeocoder</span>.reverseGeocode(location)</span><br><span class="line">&#125;.done &#123; placemarks <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.placemark.text = <span class="string">"\(placemarks.first)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用这些扩展，您需要指定子代码:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">"PromiseKit"</span></span><br><span class="line">pod <span class="string">"PromiseKit/CoreLocation"</span></span><br><span class="line">pod <span class="string">"PromiseKit/MapKit"</span></span><br></pre></td></tr></table></figure>

<p>All of these extensions are available at the <a href="https://github.com/PromiseKit" target="_blank" rel="noopener">PromiseKit organization</a>.<br>Go there to see what’s available and to read the source code and documentation. Every file and function<br>has been copiously documented.</p>
<blockquote>
<p>We also provide extensions for common libraries such as <a href="https://github.com/PromiseKit/Alamofire-" target="_blank" rel="noopener">Alamofire</a>.</p>
</blockquote>
<h1 id="Making-Promises"><a href="#Making-Promises" class="headerlink" title="Making Promises"></a>Making Promises</h1><p>The standard extensions will take you a long way, but sometimes you’ll still need to start chains<br>of your own. Maybe you’re using a third party API that doesn’t provide promises, or perhaps you wrote<br>your own asynchronous system. Either way, it’s easy to add promises. If you look at the code of the<br>standard extensions, you’ll see that it uses the same approach  described below.</p>
<p>标准的扩展会让你走很长一段路，但是有时候你仍然需要启动链<br>你自己的。也许你使用的是不提供promises的第三方应用编程接口，或者你写道<br>你自己的异步系统。不管怎样，添加promises都很容易。如果你看看<br>标准扩展，您会看到它使用了下面描述的相同方法。</p>
<p>Let’s say we have the following method:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(completion: <span class="params">(String?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>

<p>How do we convert this to a promise? Well, it’s easy:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; fetch(completion: $<span class="number">0</span>.resolve) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You may find the expanded version more readable:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result, error <span class="keyword">in</span></span><br><span class="line">            seal.resolve(result, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>seal</code> object that the <code>Promise</code> initializer provides to you defines<br>many methods for handling garden-variety completion handlers. It even<br>covers a variety of rarer situations, thus making it easy for you to add<br>promises to an existing codebase.</p>
<blockquote>
<p><em>Note</em>: We tried to make it so that you could just do <code>Promise(fetch)</code>, but we<br>were not able to make this simpler pattern work universally without requiring<br>extra disambiguation for the Swift compiler. Sorry; we tried.</p>
</blockquote>
<blockquote>
<p><em>Note</em>: In PMK 4, this initializer provided two parameters to your closure:<br><code>fulfill</code> and <code>reject</code>. PMK 5 and 6 give you an object that has both <code>fulfill</code> and<br><code>reject</code> methods, but also many variants of the method <code>resolve</code>. You can<br>typically just pass completion handler parameters to <code>resolve</code> and let Swift figure<br>out which variant to apply to your particular case (as shown in the example above).</p>
</blockquote>
<blockquote>
<p><em>Note</em> <code>Guarantees</code> (below) have a slightly different initializer (since they<br>cannot error) so the parameter to the initializer closure is just a closure. Not<br>a <code>Resolver</code> object. Thus do <code>seal(value)</code> rather than <code>seal.fulfill(value)</code>. This<br>is because there is no variations in what guarantees can be sealed with, they can<br><em>only</em> fulfill.</p>
</blockquote>
<h1 id="Guarantee-lt-T-gt"><a href="#Guarantee-lt-T-gt" class="headerlink" title="Guarantee&lt;T&gt;"></a><code>Guarantee&lt;T&gt;</code></h1><p>Since PromiseKit 5, we have provided <code>Guarantee</code> as a supplementary class to<br><code>Promise</code>. We do this to complement Swift’s strong error handling system.</p>
<p>Guarantees <em>never</em> fail, so they cannot be rejected. A good example is <code>after</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    after(seconds: 0.1)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    // there is no way to add a `catch` because after cannot fail.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift warns you if you don’t terminate a regular <code>Promise</code> chain (i.e., not<br>a <code>Guarantee</code> chain). You’re expected to silence this warning by supplying<br>either a <code>catch</code> or a <code>return</code>. (In the latter case, you will then have to <code>catch</code><br>at the point where you receive that promise.)</p>
<p>Use <code>Guarantee</code>s wherever possible so that your code has error handling where<br>it’s required and no error handling where it’s not required.</p>
<p>In general, you should be able to use <code>Guarantee</code>s and <code>Promise</code>s interchangeably,<br>We have gone to great lengths to try and ensure this, so please open a ticket<br>if you find an issue.</p>
<hr>
<p>If you are creating your own guarantees the syntax is simpler than that of promises;</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result <span class="keyword">in</span></span><br><span class="line">            seal(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which could be reduced to:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span>(resolver: fetch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map-compactMap-etc"><a href="#map-compactMap-etc" class="headerlink" title="map, compactMap, etc."></a><code>map</code>, <code>compactMap</code>, etc.</h1><p><code>then</code> provides you with the result of the previous promise and requires you to return<br>another promise.</p>
<p><code>map</code> provides you with the result of the previous promise and requires you to return<br>an object or value type.</p>
<p><code>compactMap</code> provides you with the result of the previous promise and requires you<br>to return an <code>Optional</code>. If you return <code>nil</code>, the chain fails with<br><code>PMKError.compactMap</code>.</p>
<blockquote>
<p><em>Rationale</em>: Before PromiseKit 4, <code>then</code> handled all these cases, and it was<br>painful. We hoped the pain would disappear with new Swift versions. However,<br>it has become clear that the various pain points are here to stay. In fact, we<br>as library authors are expected to disambiguate at the naming level of our API.<br>Therefore, we have split the three main kinds of <code>then</code> into <code>then</code>, <code>map</code> and<br><code>done</code>. After using these new functions, we realized this is much nicer in practice,<br>so we added <code>compactMap</code> as well (modeled on <code>Optional.compactMap</code>).</p>
</blockquote>
<p><code>compactMap</code> facilitates quick composition of promise chains. For example:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">URLSession</span>.shared.dataTask(.promise, with: rq)</span><br><span class="line">&#125;.compactMap &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject($<span class="number">0</span>.data) <span class="keyword">as</span>? [<span class="type">String</span>]</span><br><span class="line">&#125;.done &#123; arrayOfStrings <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// Foundation.JSONError if JSON was badly formed</span></span><br><span class="line">    <span class="comment">// PMKError.compactMap if JSON was of different type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>Tip</em>: We also provide most of the functional methods you would expect for sequences,<br>e.g., <code>map</code>, <code>thenMap</code>, <code>compactMapValues</code>, <code>firstValue</code>, etc.</p>
</blockquote>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h1><p>We provide <code>get</code> as a <code>done</code> that returns the value fed to <code>get</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.<span class="keyword">get</span> &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.done &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// same foo!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="tap"><a href="#tap" class="headerlink" title="tap"></a><code>tap</code></h1><p>We provide <code>tap</code> for debugging. It’s the same as <code>get</code> but provides the<br><code>Result&lt;T&gt;</code> of the <code>Promise</code> so you can inspect the value of the chain at this<br>point without causing any side effects:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.tap &#123;</span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Supplement"><a href="#Supplement" class="headerlink" title="Supplement"></a>Supplement</h1><h2 id="firstly"><a href="#firstly" class="headerlink" title="firstly"></a><code>firstly</code></h2><p>We’ve used <code>firstly</code> several times on this page, but what is it, really? In fact,<br>it is just <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener">syntactic sugar</a>.<br>You don’t really need it, but it </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>PromiseKit</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift</title>
    <url>/2019/11/04/RxSwift/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/11/04/Vue/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>C++重温</title>
    <url>/2019/11/04/C++%E9%87%8D%E6%B8%A9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础</title>
    <url>/2019/11/04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC</title>
    <url>/2019/11/04/WebRTC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg</title>
    <url>/2019/11/04/FFmpeg/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础01</title>
    <url>/2019/11/02/Python%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基础01</title>
    <url>/2019/11/01/Swift%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="使用let关键字来声明常量"><a href="#使用let关键字来声明常量" class="headerlink" title="使用let关键字来声明常量"></a>使用let关键字来声明常量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="使用var关键字来声明变量"><a href="#使用var关键字来声明变量" class="headerlink" title="使用var关键字来声明变量"></a>使用var关键字来声明变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var temp = 0</span><br><span class="line">temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="可以在一行中声明多个变量或常量，用逗号分隔"><a href="#可以在一行中声明多个变量或常量，用逗号分隔" class="headerlink" title="可以在一行中声明多个变量或常量，用逗号分隔"></a>可以在一行中声明多个变量或常量，用逗号分隔</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var x=0.1, y=10.1, z=1.0</span><br></pre></td></tr></table></figure>
<h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><p>在声明一个变量或常量的时候提供类型标注，来明确变量或常量能够储存值的类型</p>
<p>添加类型标注的方法是在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称</p>
<p>可以在一行中定义多个相关的变量为相同类型，用逗号分隔，只要在最后的变量名字后边加上类型标注</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var msg: String</span><br><span class="line">msg = <span class="string">"message"</span></span><br></pre></td></tr></table></figure>

<h3 id="变量和常量命名"><a href="#变量和常量命名" class="headerlink" title="变量和常量命名"></a>变量和常量命名</h3><p>几乎可以使用任何自负，甚至包括Unicode字符</p>
<p>不能包括空白字符、数学符号、箭头、保留的（或无效的）Unicode码位、连线和制表符。也不能以数字开头。</p>
<h3 id="打印常量和变量"><a href="#打印常量和变量" class="headerlink" title="打印常量和变量"></a>打印常量和变量</h3><p>print</p>
<p>字符串插值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">"show string"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"显示str\(str)"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>8，16，32，64位编码的有符号和无符号整数（例如：UInt8,Int8）</p>
<p>通过min和max属性访问每个整数类型的最小值和最大值</p>
<p>Int，拥有与当前平台的原生字相同的长度；UInt，与平台长度相关的无符号整数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"UInt8 min \(UInt8.min), UInt8 max \(UInt8.max)"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p> Double 64位浮点数，至少有15位数字的精度</p>
<p> Float 32位浮点数，至少有6位数字的精度</p>
<h3 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h3><p>表示true和false</p>
<p>Swift的类型安全机制会阻止你用一个非布尔量的值替代掉Bool</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p><img src="/.com//Swift_%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4.png" alt="Swift_数值范围"></p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p> 类型别名是一个为已存在类型定义的一个可选择的名字<br> <code>typealias</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typealias AudioSample = UInt8</span><br><span class="line"><span class="built_in">let</span> sample: AudioSample = 32</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><h3 id="使用Tuple组合多个值"><a href="#使用Tuple组合多个值" class="headerlink" title="使用Tuple组合多个值"></a>使用Tuple组合多个值</h3><p>元组把多个值合并成单一的复合型的值</p>
<p>元组内的值可以是任何类型，而且可以不必是同一类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.0)</span><br><span class="line"><span class="built_in">print</span>(error.1)</span><br></pre></td></tr></table></figure>
<h3 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h3><p>元组中的每一个元素可以制定对应的元素名称</p>
<p>如果没有制定名称的元素也可以使用下标的方式来引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (error: 1,  errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.error)</span><br><span class="line"><span class="built_in">print</span>(error.errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="Tuple修改"><a href="#Tuple修改" class="headerlink" title="Tuple修改"></a>Tuple修改</h3><p>用var定义的元组就是可变元组，let定义的就是不可变元组</p>
<p><code>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</code></p>
<p>可以对可变元组的元素进行修改，但是不能改变其类型</p>
<p>Any类型可以改为任何类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var error:(errorCode: Int, errorMsg:Any) = (errorCode: 1, errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMsg = 3</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>可以将一个元组的内容分解成单独的常量或变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (error, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<p>如果只需要使用其中的一部分数据，不需要的数据可以用下划线<code>_</code>代替</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (_, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h3><p>使用Tuple为函数返回多个值</p>
<p>返回值的Tuple可以在函数的返回类型部分被命名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func requestWithUrl(url: String) -&gt; (errorCode: Int, errorMsg: String) &#123;</span><br><span class="line">    <span class="built_in">return</span> (1, <span class="string">"没有权限"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> error = requestWithUrl(url: <span class="string">""</span>)</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>通过在变量类型后面加<code>?</code>表示：这里有一个值，它表示x，或者这里根本没有值</p>
<p>可以通过给可选变量赋值一个nil来将之设置为没有值</p>
<p>在Swift中，nil不是指针，他是值缺失的一种特殊类型，任何类型的可选类项都可以设置成nil而不仅仅是对西那个类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = nil</span><br></pre></td></tr></table></figure>

<h3 id="Optional-if"><a href="#Optional-if" class="headerlink" title="Optional-if"></a>Optional-if</h3><p>可选项是没法直接食用的，需要用!展开之后才能使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> str != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h3><p>可以使用可选项的绑定来判断是否包含值，如果包含就把值赋给一个临时的常量或者变量</p>
<p>可选绑定可以与if和while的语句使用来检查可选项内部的值，并赋值给一个变量或常量 </p>
<p>同一个if语句中包含多个可选项绑定时，用逗号分隔开即可。如果人一个选项绑定结果是nil或者布尔值为false，那么整个if判断会被看作false</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> actualStr = str &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-隐式展开"><a href="#Optional-隐式展开" class="headerlink" title="Optional-隐式展开"></a>Optional-隐式展开</h3><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开</p>
<p>通过在声明的类型后边添加一个叹号<code>!</code>而非问好来书写隐式展开可选项</p>
<p>隐式展开可选项主要被用于Swift类的初始化过程中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String! = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str!.count</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<h3 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h3><p>可选项后面加问号</p>
<p>如果可选项不为nil，返回一个可选项结果，否则返回nil</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str?.count</span><br><span class="line"><span class="keyword">if</span> count != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> lastIndex = count! - 1</span><br><span class="line">    <span class="built_in">print</span>(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var emptyString = <span class="string">""</span></span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(Noting<span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字符串字面亮是被双引号<code>&quot;</code>包裹的固定顺序的文本字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str = <span class="string">"some string"</span></span><br></pre></td></tr></table></figure>

<h3 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h3><p>字多行符串字面量是被三个双引号<code>&quot;&quot;&quot;</code>引起来的一系列字符</p>
<p>开始和结束默认不会有换行符</p>
<p>反斜杠只会在代码阅读上方便，输出时没有实际的换行功能<code>\</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">""</span><span class="string">"var emptyString = "</span><span class="string">" \</span></span><br><span class="line"><span class="string">var anotherEmptyString = String() \</span></span><br><span class="line"><span class="string">if emptyString.isEmpty &#123; \</span></span><br><span class="line"><span class="string">    print(Noting"</span>) \</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">print(str)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h3><p>转义特殊字符</p>
<p>任意的Unicode标量  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展字符串分隔符"><a href="#扩展字符串分隔符" class="headerlink" title="扩展字符串分隔符"></a>扩展字符串分隔符</h3><p>在字符串字面量中放置扩展分隔符来在字符串中包含特殊字符而不让它们真的生效</p>
<p>将字符串放在双引号内并由井号#包裹</p>
<p>如果字符串里有”#则首尾需要两个##(首尾##与包含的”#不一样即可)</p>
<p>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的#号数量的#号，并在前面添加转义符号\</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\n\n444"#</span></span><br><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\#n\n444"#</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的可变形"><a href="#字符串的可变形" class="headerlink" title="字符串的可变形"></a>字符串的可变形</h3><p>var 可修改<br>let 不可修改</p>
<h3 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h3><p>String 值在传递给方法或者函数的时候会被复制过去</p>
<p>赋值给常量和变量的时候也是一样</p>
<h3 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h3><p>for-in 循环遍历String中的每一个独立的Character</p>
<p>Character类型</p>
<p>String值可以通过传入Character 数组来构造</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"abcdef"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> tempCharacters: [Character] = [<span class="string">"d"</span>,<span class="string">"f"</span>,<span class="string">"d"</span>,<span class="string">"h"</span>]</span><br><span class="line"><span class="built_in">let</span> str = String(tempCharacters)</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>通过加运算符<code>+</code>创建新字符串</p>
<p>使用加赋值符号<code>+=</code>在已经存在的String值末尾追加一个String值</p>
<p>使用String类型的<code>append()</code>方法来给一个String变量的末尾追加character值</p>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p><code>\(some)</code> some代表：混合常量、变量、字面量和表达式的字符串面量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="comment">#"1 * 3 = \#(1*3)."#)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>每个String值都有相关的索引类型，String.index，它相当于每个Character在字符串重的位置</p>
<p>startIndex属性来访问String中第一个Character的位置。endIndex属性就是String中最后一个字符后的位置</p>
<p>endIndex属性并不是字符串下表脚本的合法实际参数</p>
<p>如果String为空，则startIndex与endIndex相等</p>
<p>使用index(before:)和index(after:)方法来访问给定索引的前后</p>
<p>要访问给定索引更远的索引，你可以使用index(_:offsetBy:)</p>
<p>使用indices属性来访问字符串中每个字符的索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> hello = <span class="string">"hello"</span></span><br><span class="line">hello[hello.startIndex]</span><br><span class="line">hello[hello.index(before: hello.endIndex)]</span><br><span class="line">hello[hello.index(after: hello.startIndex)]</span><br><span class="line"><span class="built_in">let</span> index = hello.index(hello.startIndex, offsetBy: 2)</span><br><span class="line">hello[index]</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入字符，使用insert(_:at:)方法</p>
<p>插入另一个字符串的内容到特定的索引，使用insert(contentsOs:at:)方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, at: welcome.endIndex)</span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf: <span class="string">"ererer"</span>, at: welcome.index(before: welcome.endIndex))</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>移除字符串remove(at:)</p>
<p>移除特定范围的字符串removeSubrange(range)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> range = welcome.index(welcome.endIndex, offsetBy: -1)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br></pre></td></tr></table></figure>

<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>使用下表或者累死prefix(_:)的方法得到的子字符串是SubString类型</p>
<p>SubString拥有String的大部分方法</p>
<p>SubString可以转成String类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> index3 = hello.lastIndex(of: <span class="string">"o"</span>) ?? hello.endIndex</span><br><span class="line"><span class="built_in">let</span> begin = hello[..&lt;index3]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> newHello = String(begin)</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>字符串和字符相等性(==和==)</p>
<p>前缀相等hasPrefix(_:)</p>
<p>后缀相等hasSuffix(_:)</p>
<h2 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a>赋值和算术运算符</h2><p>一元运算符、二元运算符、三元运算符</p>
<p>赋值运算符不会返回值</p>
<h2 id="如何处理算术结果溢出"><a href="#如何处理算术结果溢出" class="headerlink" title="如何处理算术结果溢出"></a>如何处理算术结果溢出</h2><p>在默认情况下，当一个整数赋超过它容量的值时，Swift会报错而不是生成一个无效的数，给我们操作过大或者过小的数的时候提供了额外的安全性</p>
<p>同时提供了三个算术溢出运算符来让系统支持整数溢出的运算</p>
<p>溢出加法<code>&amp;+</code></p>
<p>溢出减法<code>&amp;-</code></p>
<p>溢出乘法<code>&amp;*</code></p>
<h3 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h3><p>溢出也会发生在有符号整形数值上</p>
<p>对于无符号与有符号整形数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
<h2 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符??"></a>合并空值运算符<code>??</code></h2><p>合并空值运算符(a??b)如果选项a有值则展开，如果没有值，是nil，则返回默认值b</p>
<p>表达式a必须是一个可选类型。表达式b必须与a的存储类型相同。</p>
<p>实际上它就是相当于三目运算符<code>_?_:_</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func addTwoNum(num1: Int?, num2: Int2?) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> (num1 ?? 0) +(num2 ?? 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><h3 id="闭区间运算符a-b"><a href="#闭区间运算符a-b" class="headerlink" title="闭区间运算符a...b"></a>闭区间运算符<code>a...b</code></h3><p>定义了从a到b的一组范围，并且包含a和b</p>
<p>a的值不能大于b的值</p>
<h3 id="半开区间运算符a-lt-b"><a href="#半开区间运算符a-lt-b" class="headerlink" title="半开区间运算符a..&lt;b"></a>半开区间运算符<code>a..&lt;b</code></h3><p>定义了从a到b但不包含b的区间</p>
<p>a的值不能大于b的值，如果a与b的值相等，那返回的区间将会是空的</p>
<h3 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h3><p>比如说，一个包含数组所有的元素的区间，从索引2到数组的结束。在这种情况下，你可以省略区间运算符一侧的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[2...] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[...2] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倒序索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (0..&lt;10&gt;).<span class="function"><span class="title">reversed</span></span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间运算符在字符串上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> range = welcome.startIndex...welcome.index(welcome.endIndex, offsetBy: -6)</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(welcome)]</span><br></pre></td></tr></table></figure>

<p>区间运算符在比较类型上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> interval = <span class="string">"a"</span>...<span class="string">"z"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> welcome &#123;</span><br><span class="line">    <span class="keyword">if</span> !interval.contains(String(c)) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(c)不是小写字母"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符"></a>位取反运算符</h3><p>位取反运算符(~)是对所有位的数字进行取反操作</p>
<h3 id="位与运算符"><a href="#位与运算符" class="headerlink" title="位与运算符"></a>位与运算符</h3><p>位与运算符(&amp;)是对两个数的比特位进行合并。它会返回一个新的数，只有当这两个数都是1的时候才能返回1。</p>
<h3 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符"></a>位或运算符</h3><p>位或运算符(|)是对两个数的比特位进行比较。它会返回一个新的数，只要两个操作位任意一个为1时，那么对应的位数就为1。</p>
<h3 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符"></a>位异或运算符</h3><p>位异或运算符(^))，当两个操作数的对应位不相同时，那么该数对应的位数就为1。</p>
<h3 id="位左移和右移运算符"><a href="#位左移和右移运算符" class="headerlink" title="位左移和右移运算符"></a>位左移和右移运算符</h3><p>位左移(&lt;&lt;)和右移运算符(&gt;&gt;)可以吧所有位数的数字向左或向右移动一个确定的位数。</p>
<p>位座椅和右移具有给整数乘以或除以二的效果。将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。</p>
<h3 id="无符号整数的唯一操作"><a href="#无符号整数的唯一操作" class="headerlink" title="无符号整数的唯一操作"></a>无符号整数的唯一操作</h3><p>用0填充左移或右移后产生的空白位</p>
<h3 id="有符号整数的移位操作"><a href="#有符号整数的移位操作" class="headerlink" title="有符号整数的移位操作"></a>有符号整数的移位操作</h3><p>第一位表示整数还是负数（0正数，1负数）</p>
<h3 id="位运算符应用"><a href="#位运算符应用" class="headerlink" title="位运算符应用"></a>位运算符应用</h3><ul>
<li>两个数字交换</li>
<li>求赋符号整形数二进制中1的个数</li>
<li>判断一个整数是否为为2的整数次幂</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"></span><br><span class="line">$ hexo d --g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
