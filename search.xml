<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java Mybatis</title>
    <url>/2020/07/17/Java-Mybatis/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java Spring JDBC JTA实现分布式事务</title>
    <url>/2020/07/17/Java-Spring-JDBC-JTA%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java JDBC</title>
    <url>/2020/07/17/Java-JDBC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java Spring boot配置管理总结</title>
    <url>/2020/07/17/Java-Spring-boot%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java profile不同环境使用不同配置</title>
    <url>/2020/07/17/Java-profile%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java SpEL</title>
    <url>/2020/07/17/Java-SpEL/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java YAML</title>
    <url>/2020/07/17/Java-YAML/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java swagger</title>
    <url>/2020/07/17/Java-swagger/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java Mockito</title>
    <url>/2020/07/17/Java-Mockito/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java 单元测试</title>
    <url>/2020/07/17/Java-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java jackson-JSON数据格式处理</title>
    <url>/2020/07/17/Java-jackson-JSON%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java Restful接口</title>
    <url>/2020/07/17/Java-Restful%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java lombok插件</title>
    <url>/2020/07/17/Java-lombok%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java Spring boot2.0 helloworld</title>
    <url>/2020/07/17/Java-Spring-boot2-0-helloworld/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java Maven使用</title>
    <url>/2020/07/17/Java-Maven%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java 到底是值传递还是引用传递</title>
    <url>/2020/07/15/Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。</p>
<h1 id="01、值传递-VS-引用传递"><a href="#01、值传递-VS-引用传递" class="headerlink" title="01、值传递 VS 引用传递"></a>01、值传递 VS 引用传递</h1><p>首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。</p>
<p>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。</p>
<p>而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。</p>
<p>Java 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。</p>
<p>基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。<br><img src="/2020/07/15/Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/%E4%BC%A0%E9%80%9201.png" alt></p>
<p>之所以有这个区别，是因为：</p>
<ul>
<li>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。</li>
<li>堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。</li>
</ul>
<h1 id="02、基本类型的参数传递"><a href="#02、基本类型的参数传递" class="headerlink" title="02、基本类型的参数传递"></a>02、基本类型的参数传递</h1><p>众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。</p>
<p>来看下面这段代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class PrimitiveTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 18;</span><br><span class="line">        modify(age);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void modify(int age1) &#123;</span><br><span class="line">        age1 = 30;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。</p>
<p>2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。</p>
<p>3）对形参 age 的任何修改都只会影响它自身而不会影响实参。</p>
<p><img src="/2020/07/15/Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/%E4%BC%A0%E9%80%9202.png" alt></p>
<h1 id="03、引用类型的参数传递"><a href="#03、引用类型的参数传递" class="headerlink" title="03、引用类型的参数传递"></a>03、引用类型的参数传递</h1><p>来看一段创建引用类型变量的代码：</p>
<p><code>Writer writer = new Writer(18, &quot;沉默王二&quot;);</code><br>writer 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer writer;</span><br><span class="line">writer = new Writer(18, <span class="string">"沉默王二"</span>);</span><br></pre></td></tr></table></figure>

<p>假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“=”操作符执行之前，它仅仅是一个变量。那谁是对象呢？<code>new Writer(18, &quot;沉默王二&quot;)</code>，它是对象，存储于堆中；然后，“=”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫<code>对象引用，它存储在栈中，保存了对象在堆中的地址</code>。</p>
<p>每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。</p>
<p>来看下面这段代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ReferenceTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Writer a = new Writer(18);</span><br><span class="line">        Writer b = new Writer(18);</span><br><span class="line">        modify(a, b);</span><br><span class="line"></span><br><span class="line">        System.out.println(a.getAge());</span><br><span class="line">        System.out.println(b.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void modify(Writer a1, Writer b1) &#123;</span><br><span class="line">        a1.setAge(30);</span><br><span class="line"></span><br><span class="line">        b1 = new Writer(18);</span><br><span class="line">        b1.setAge(30);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）在调用 <code>modify()</code> 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。<br><img src="/2020/07/15/Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/%E4%BC%A0%E9%80%9203.png" alt></p>
<p>2）在调用 <code>modify()</code> 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。</p>
<p><img src="/2020/07/15/Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/%E4%BC%A0%E9%80%9204.png" alt></p>
<p>3）在 <code>modify()</code> 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。<br><img src="/2020/07/15/Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/%E4%BC%A0%E9%80%9205.png" alt></p>
<p>修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。</p>
<p>程序输出的结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">30</span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<p>果然和我们的分析是吻合的。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 关于IntelliJ IDEA的使用</title>
    <url>/2020/07/15/Java-%E5%85%B3%E4%BA%8EIntelliJ-IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java final 关键字</title>
    <url>/2020/07/07/Java-final-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。</p>
<p>01、final 类<br>如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,</span><br><span class="line">               Constable, ConstantDesc &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为什么 String 类要设计成 final 的呢？原因大致有以下三个：</p>
<p>为了实现字符串常量池</p>
<p>为了线程安全</p>
<p>为了 HashCode 的不可变性</p>
<p>更详细的原因，可以查看我之前写的一篇文章。</p>
<p>任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public final class Writer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。</p>
<p>不过，类是 final 的，并不意味着该类的对象是不可变的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer writer = new Writer();</span><br><span class="line">writer.setName(<span class="string">"沉默王二"</span>);</span><br><span class="line">System.out.println(writer.getName()); // 沉默王二</span><br></pre></td></tr></table></figure>
<p>Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。</p>
<p>如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。</p>
<p>把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。</p>
<p>02、final 方法<br>被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。</p>
<p>Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    public final native boolean isAlive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。</p>
<p>Actor 类有一个 final 方法 show()：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Actor &#123;</span><br><span class="line">    public final void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们想要重写该方法的话，就会出现编译错误：</p>
<p>如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。</p>
<p>一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？</p>
<p>我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。</p>
<p>03、final 变量<br>被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：</p>
<p><a href="http://www.itwanger.com/java/2020/02/14/java-final-effectively.html" target="_blank" rel="noopener">http://www.itwanger.com/java/2020/02/14/java-final-effectively.html</a></p>
<p>1）final 修饰的基本数据类型</p>
<p>来声明一个 final 修饰的 int 类型的变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">final int age = 18;</span><br></pre></td></tr></table></figure>
<p>尝试将它修改为 30，结果编译器生气了：</p>
<p>2）final 修饰的引用类型</p>
<p>现在有一个普通的类 Pig，它有一个字段 name：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">   private String name;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类中声明一个 final 修饰的 Pig 对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">final Pig pig = new Pig();</span><br></pre></td></tr></table></figure>
<p>如果尝试将 pig 重新赋值的话，编译器同样会生气：</p>
<p>但我们仍然可以去修改 Pig 的字段值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">final Pig pig = new Pig();</span><br><span class="line">pig.setName(<span class="string">"特立独行"</span>);</span><br><span class="line">System.out.println(pig.getName()); // 特立独行</span><br></pre></td></tr></table></figure>
<p>3）final 修饰的字段</p>
<p>final 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">   private final int age = 1;</span><br><span class="line">   public static final double PRICE = 36.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：</p>
<p>static 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static <a href>代码块初始化</a>。</p>
<p>4) final 修饰的参数</p>
<p>final 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ArgFinalTest &#123;</span><br><span class="line">    public void arg(final int age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void arg1(final String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尝试去修改它的话，编译器会提示以下错误：</p>
<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 枚举</title>
    <url>/2020/07/07/Java-%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。</p>
<p>为了证明这一点，我们来新建一个枚举 PlayerType：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public enum PlayerType &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public final class PlayerType extends Enum</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static PlayerType[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (PlayerType[])<span class="variable">$VALUES</span>.<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static PlayerType valueOf(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private PlayerType(String s, int i)</span><br><span class="line">    &#123;</span><br><span class="line">        super(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final PlayerType TENNIS;</span><br><span class="line">    public static final PlayerType FOOTBALL;</span><br><span class="line">    public static final PlayerType BASKETBALL;</span><br><span class="line">    private static final PlayerType <span class="variable">$VALUES</span>[];</span><br><span class="line"></span><br><span class="line">    static </span><br><span class="line">    &#123;</span><br><span class="line">        TENNIS = new PlayerType(<span class="string">"TENNIS"</span>, 0);</span><br><span class="line">        FOOTBALL = new PlayerType(<span class="string">"FOOTBALL"</span>, 1);</span><br><span class="line">        BASKETBALL = new PlayerType(<span class="string">"BASKETBALL"</span>, 2);</span><br><span class="line">        <span class="variable">$VALUES</span> = (new PlayerType[] &#123;</span><br><span class="line">            TENNIS, FOOTBALL, BASKETBALL</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和  valueOf(String name)。</p>
<p>01、内部枚举<br>好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Player &#123;</span><br><span class="line">    private PlayerType <span class="built_in">type</span>;</span><br><span class="line">    public enum PlayerType &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean <span class="function"><span class="title">isBasketballPlayer</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> getType() == PlayerType.BASKETBALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PlayerType <span class="function"><span class="title">getType</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(PlayerType <span class="built_in">type</span>) &#123;</span><br><span class="line">        this.type = <span class="built_in">type</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。</p>
<p>由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“==”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。</p>
<p>那为什么不使用 equals() 方法判断呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(player.getType().equals(Player.PlayerType.BASKETBALL))&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(player.getType() == Player.PlayerType.BASKETBALL)&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。</p>
<p>另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。</p>
<p>02、枚举可用于 switch 语句<br>这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch (playerType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TENNIS:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">"网球运动员费德勒"</span>;</span><br><span class="line">        <span class="keyword">case</span> FOOTBALL:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">"足球运动员C罗"</span>;</span><br><span class="line">        <span class="keyword">case</span> BASKETBALL:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">"篮球运动员詹姆斯"</span>;</span><br><span class="line">        <span class="keyword">case</span> UNKNOWN:</span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"未知"</span>);</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    <span class="string">"运动员类型: "</span> + playerType);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>03、枚举可以有构造方法<br>如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public enum PlayerType &#123;</span><br><span class="line">    TENNIS(<span class="string">"网球"</span>),</span><br><span class="line">    FOOTBALL(<span class="string">"足球"</span>),</span><br><span class="line">    BASKETBALL(<span class="string">"篮球"</span>);</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    PlayerType(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>04、EnumSet<br>EnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。</p>
<p>因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：</p>
<p>下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class EnumSetTest &#123;</span><br><span class="line">    public enum PlayerType &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);</span><br><span class="line">        System.out.println(enumSetNone);</span><br><span class="line"></span><br><span class="line">        EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);</span><br><span class="line">        System.out.println(enumSetAll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[TENNIS, FOOTBALL, BASKETBALL]</span><br></pre></td></tr></table></figure>
<p>有了 EnumSet 后，就可以使用 Set 的一些方法了：</p>
<p>05、EnumMap<br>EnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。</p>
<p>和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</span><br></pre></td></tr></table></figure>
<p>有了 EnumMap 对象后就可以使用 Map 的一些方法了：</p>
<p>和 HashMap 的使用方法大致相同，来看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</span><br><span class="line">enumMap.put(PlayerType.BASKETBALL,<span class="string">"篮球运动员"</span>);</span><br><span class="line">enumMap.put(PlayerType.FOOTBALL,<span class="string">"足球运动员"</span>);</span><br><span class="line">enumMap.put(PlayerType.TENNIS,<span class="string">"网球运动员"</span>);</span><br><span class="line">System.out.println(enumMap);</span><br><span class="line"></span><br><span class="line">System.out.println(enumMap.get(PlayerType.BASKETBALL));</span><br><span class="line">System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));</span><br><span class="line">System.out.println(enumMap.remove(PlayerType.BASKETBALL));</span><br></pre></td></tr></table></figure>
<p>程序输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员&#125;</span><br><span class="line">篮球运动员</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">篮球运动员</span><br></pre></td></tr></table></figure>
<p>06、单例<br>通常情况下，实现一个单例并非易事，不信，来看下面这段代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton; </span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span> ()&#123;&#125;  </span><br><span class="line">    public static Singleton <span class="function"><span class="title">getSingleton</span></span>() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == null) &#123;</span><br><span class="line">        synchronized (Singleton.class) &#123; </span><br><span class="line">        <span class="keyword">if</span> (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton(); </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但枚举的出现，让代码量减少到极致：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public enum EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。</p>
<p>07、枚举可与数据库交互<br>我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：</p>
<p><code>check_type</code> int(1) DEFAULT NULL COMMENT ‘检查类型（1：未通过、2：通过）’,<br>它对应的枚举类型为 CheckType，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public enum CheckType &#123;</span><br><span class="line">    NO_PASS(0, <span class="string">"未通过"</span>), PASS(1, <span class="string">"通过"</span>);</span><br><span class="line">    private int key;</span><br><span class="line"></span><br><span class="line">    private String text;</span><br><span class="line"></span><br><span class="line">    private CheckType(int key, String text) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">getKey</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getText</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static HashMap&lt;Integer,CheckType&gt; map = new HashMap&lt;Integer,CheckType&gt;();</span><br><span class="line">    static &#123;</span><br><span class="line">        <span class="keyword">for</span>(CheckType d : CheckType.values())&#123;</span><br><span class="line">            map.put(d.key, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static CheckType parse(Integer index) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(index))&#123;</span><br><span class="line">            <span class="built_in">return</span> map.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。</p>
<p>2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。</p>
<p>那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。</p>
<resultMap id="CheckLog" type="com.entity.CheckLog">
  <id property="id" column="id">
  <result property="checkType" column="check_type" typehandler="com.CheckTypeHandler"></result>
</id></resultMap>
其中 checkType 字段对应的类如下：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CheckLog implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private CheckType checkType;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CheckType <span class="function"><span class="title">getCheckType</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> checkType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCheckType(CheckType checkType) &#123;</span><br><span class="line">        this.checkType = checkType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
CheckTypeHandler 转换器的类源码如下：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CheckTypeHandler extends BaseTypeHandler&lt;CheckType&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CheckType getNullableResult(ResultSet rs, String index) throws SQLException &#123;</span><br><span class="line">        <span class="built_in">return</span> CheckType.parse(rs.getInt(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CheckType getNullableResult(ResultSet rs, int index) throws SQLException &#123;</span><br><span class="line">        <span class="built_in">return</span> CheckType.parse(rs.getInt(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CheckType getNullableResult(CallableStatement cs, int index) throws SQLException &#123;</span><br><span class="line">        <span class="built_in">return</span> CheckType.parse(cs.getInt(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException &#123;</span><br><span class="line">        ps.setInt(index, val.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。</p>
<p>恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java static 关键字</title>
    <url>/2020/07/07/Java-static-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：</p>
<blockquote>
<p><code>static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。</code></p>
</blockquote>
<h1 id="01、静态变量"><a href="#01、静态变量" class="headerlink" title="01、静态变量"></a>01、静态变量</h1><p>静态变量也叫类变量，它属于一个类，而不是这个类的对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public static int countOfWriters;</span><br><span class="line"></span><br><span class="line">    public Writer(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        countOfWriters++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">getAge</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。</p>
<p>这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer w1 = new Writer(<span class="string">"沉默王二"</span>,18);</span><br><span class="line">Writer w2 = new Writer(<span class="string">"沉默王三"</span>,16);</span><br><span class="line"></span><br><span class="line">System.out.println(Writer.countOfWriters);</span><br></pre></td></tr></table></figure>
<p>按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。</p>
<p>静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。</p>
<p>简单小结一下：</p>
<p>1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；<br><img src="/2020/07/07/Java-static-%E5%85%B3%E9%94%AE%E5%AD%97/1.png" alt></p>
<p>2）不需要初始化类就可以访问静态变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class WriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Writer.countOfWriters); // 输出 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="02、静态方法"><a href="#02、静态方法" class="headerlink" title="02、静态方法"></a>02、静态方法</h1><p>静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void setCountOfWriters(int countOfWriters) &#123;</span><br><span class="line">    Writer.countOfWriters = countOfWriters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。</p>
<p>如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。<br><img src="/2020/07/07/Java-static-%E5%85%B3%E9%94%AE%E5%AD%97/2.png" alt></p>
<p>Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。<br><img src="/2020/07/07/Java-static-%E5%85%B3%E9%94%AE%E5%AD%97/3.png" alt></p>
<p>简单小结一下：</p>
<p>1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。</p>
<p>2）抽象方法不能是静态的。<br><img src="/2020/07/07/Java-static-%E5%85%B3%E9%94%AE%E5%AD%97/4.png" alt></p>
<p>3）静态方法不能使用 this 和 super 关键字。</p>
<p>4）成员方法可以直接访问其他成员方法和成员变量。</p>
<p>5）成员方法也可以直接方法静态方法和静态变量。</p>
<p>6）静态方法可以访问所有其他静态方法和静态变量。</p>
<p>7）静态方法无法直接访问成员方法和成员变量。<br><img src="/2020/07/07/Java-static-%E5%85%B3%E9%94%AE%E5%AD%97/5.png" alt></p>
<p>03、静态代码块<br>静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class StaticBlockDemo &#123;</span><br><span class="line">    public static List&lt;String&gt; writes = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        writes.add(<span class="string">"沉默王二"</span>);</span><br><span class="line">        writes.add(<span class="string">"沉默王三"</span>);</span><br><span class="line">        writes.add(<span class="string">"沉默王四"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"第一块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        writes.add(<span class="string">"沉默王五"</span>);</span><br><span class="line">        writes.add(<span class="string">"沉默王六"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"第二块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。</p>
<p>简单小结一下：</p>
<p>1）一个类可以有多个静态代码块。</p>
<p>2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：</p>
<p>第一块<br>第二块<br>04、静态内部类<br>Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。</p>
<p>常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private <span class="function"><span class="title">Singleton</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        public static final Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。</p>
<p>简单小结一下：</p>
<p>1）静态内部类不能访问外部类的所有成员变量。</p>
<p>2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</p>
<p>3）外部类不能声明为 <code>static</code>。<br><img src="/2020/07/07/Java-static-%E5%85%B3%E9%94%AE%E5%AD%97/6.png" alt></p>
<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 重写和重载</title>
    <url>/2020/07/07/Java-%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>先来看一段重写的代码吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class LaoWang&#123;</span><br><span class="line">    public void <span class="function"><span class="title">write</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"老王写了一本《基督山伯爵》"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class XiaoWang extends LaoWang &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">write</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"小王写了一本《茶花女》"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。</p>
<p>来写一段测试代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class OverridingTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LaoWang wang = new XiaoWang();</span><br><span class="line">        wang.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家猜结果是什么？</p>
<p>小王写了一本《茶花女》<br>在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang  中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。</p>
<p>再来看一段重载的代码吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class LaoWang&#123;</span><br><span class="line">    public void <span class="function"><span class="title">read</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"老王读了一本《Web全栈开发进阶之路》"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="built_in">read</span>(String bookname) &#123;</span><br><span class="line">        System.out.println(<span class="string">"老王读了一本《"</span> + bookname + <span class="string">"》"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。</p>
<p>来写一段测试代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class OverloadingTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LaoWang wang = new LaoWang();</span><br><span class="line">        wang.read();</span><br><span class="line">        wang.read(<span class="string">"金瓶梅"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(“金瓶梅”) 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（=方法名称+方法参数）不同。</p>
<p>简单的来总结一下：</p>
<p>1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。</p>
<p>2）多态针对的是重写，而不是重载。</p>
<p>另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java super 关键字</title>
    <url>/2020/07/07/Java-super-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>简而言之，super 关键字就是用来访问父类的。</p>
<p>先来看父类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class SuperBase &#123;</span><br><span class="line">    String message = <span class="string">"父类"</span>;</span><br><span class="line"></span><br><span class="line">    public SuperBase(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">SuperBase</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">printMessage</span></span>() &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看子类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class SuperSub extends SuperBase &#123;</span><br><span class="line">    String message = <span class="string">"子类"</span>;</span><br><span class="line"></span><br><span class="line">    public SuperSub(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">SuperSub</span></span>() &#123;</span><br><span class="line">        super.printMessage();</span><br><span class="line">        printMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">getParentMessage</span></span>() &#123;</span><br><span class="line">        System.out.println(super.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">printMessage</span></span>() &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）super 关键字可用于访问父类的构造方法</p>
<p>你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：</p>
<p><code>SuperSub superSub = new SuperSub(&quot;子类的message&quot;);</code><br>new 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。</p>
<p>2）super 关键字可以访问父类的变量</p>
<p>上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。</p>
<p>3）当方法发生重写时，super 关键字可以访问父类的同名方法</p>
<p>上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。</p>
<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java this 关键字</title>
    <url>/2020/07/07/Java-this-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>在 Java 中，<code>this</code> 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。</p>
<p>看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。</p>
<h1 id="01、消除字段歧义"><a href="#01、消除字段歧义" class="headerlink" title="01、消除字段歧义"></a>01、消除字段歧义</h1><p>我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Writer(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Writer 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 <code>this</code> 关键字消除歧义：<code>this.age 是指成员变量，age 是指构造方法的参数</code>。</p>
<h1 id="02、引用类的其他构造方法"><a href="#02、引用类的其他构造方法" class="headerlink" title="02、引用类的其他构造方法"></a>02、引用类的其他构造方法</h1><p>当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 <code>this</code> 关键字来调用不同的构造方法，从而减少代码量。</p>
<p>比如说，在无参构造方法中调用有参构造方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Writer(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Writer</span></span>() &#123;</span><br><span class="line">        this(18, <span class="string">"沉默王二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在有参构造方法中调用无参构造方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Writer(int age, String name) &#123;</span><br><span class="line">        this();</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Writer</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。</p>
<p><img src="/2020/07/07/Java-this-%E5%85%B3%E9%94%AE%E5%AD%97/1.png" alt></p>
<h1 id="03、作为参数传递"><a href="#03、作为参数传递" class="headerlink" title="03、作为参数传递"></a>03、作为参数传递</h1><p>在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 <code>this</code> 关键字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ThisTest &#123;</span><br><span class="line">    public <span class="function"><span class="title">ThisTest</span></span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void <span class="built_in">print</span>(ThisTest thisTest) &#123;</span><br><span class="line">        System.out.println(<span class="string">"print "</span> +thisTest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThisTest <span class="built_in">test</span> = new ThisTest();</span><br><span class="line">        System.out.println(<span class="string">"main "</span> + <span class="built_in">test</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来打印看一下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> com.cmower.baeldung.this1.ThisTest@573fd745</span><br><span class="line">main com.cmower.baeldung.this1.ThisTest@573fd745</span><br></pre></td></tr></table></figure>
<p>从结果中可以看得出来，<code>this</code> 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。</p>
<h1 id="04、链式调用"><a href="#04、链式调用" class="headerlink" title="04、链式调用"></a>04、链式调用</h1><p>学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。</p>
<p>在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    private String bookName;</span><br><span class="line"></span><br><span class="line">    public Writer(WriterBuilder builder) &#123;</span><br><span class="line">        this.age = builder.age;</span><br><span class="line">        this.name = builder.name;</span><br><span class="line">        this.bookName = builder.bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class WriterBuilder &#123;</span><br><span class="line">        public String bookName;</span><br><span class="line">        private int age;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public WriterBuilder(int age, String name) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public WriterBuilder writeBook(String bookName) &#123;</span><br><span class="line">            this.bookName = bookName;</span><br><span class="line">            <span class="built_in">return</span> this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Writer <span class="function"><span class="title">build</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> new Writer(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。</p>
<p>内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。</p>
<p>最后的 build() 方法用来创建一个 Writer 对象，参数为 <code>this</code> 关键字，也就是当前的 WriterBuilder 对象。</p>
<p>这时候，创建 Writer 对象就可以通过链式调用的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer writer = new Writer.WriterBuilder(18,<span class="string">"沉默王二"</span>)</span><br><span class="line">                .writeBook(<span class="string">"《Web全栈开发进阶之路》"</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<h1 id="05、在内部类中访问外部类对象"><a href="#05、在内部类中访问外部类对象" class="headerlink" title="05、在内部类中访问外部类对象"></a>05、在内部类中访问外部类对象</h1><p>说实话，自从 Java 8 的函数式编程出现后，就很少用到 <code>this</code> 在内部类中访问外部类对象了。来看一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ThisInnerTest &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    class InnerClass &#123;</span><br><span class="line">        public <span class="function"><span class="title">InnerClass</span></span>() &#123;</span><br><span class="line">            ThisInnerTest thisInnerTest = ThisInnerTest.this;</span><br><span class="line">            String outerName = thisInnerTest.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内部类 InnerClass 的构造方法中，<code>通过外部类.this 可以获取到外部类对象</code>，然后就可以使用外部类的成员变量了，比如说 name。</p>
<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 继承</title>
    <url>/2020/07/07/Java-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface OneInterface extends Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用  <code>Object.clone()</code> 方法了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class TestInterface implements OneInterface &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        TestInterface c1 = new TestInterface();</span><br><span class="line">        TestInterface c2 = (TestInterface) c1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface OneInterface extends Cloneable &#123;</span><br><span class="line">    void deepClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧？这就是继承的好处：<code>子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。</code><br>以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    void <span class="function"><span class="title">write</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"我写了本《基督山伯爵》"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Wangxiaoer extends Wanger&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void <span class="function"><span class="title">write</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"我写了本《茶花女》"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如<code>write()</code> 方法）。这样，子类也就焕发出了新的生命力。</p>
<p><code>Java 只支持单一继承</code>，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 <code>java.lang.Object</code> 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。</p>
<p>那究竟子类继承了父类的什么呢？</p>
<p>子类可以继承父类的非 <code>private</code> 成员变量，为了验证这一点，我们来看下面这个示例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    String defaultName;</span><br><span class="line">    private String privateName;</span><br><span class="line">    public String publicName;</span><br><span class="line">    protected String protectedName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。</p>
<p>在子类 Wangxiaoer 中定义一个测试方法 <code>testVariable()</code>：<br><img src="/2020/07/07/Java-%E7%BB%A7%E6%89%BF/1.png" alt></p>
<p>可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。</p>
<p>同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    void <span class="function"><span class="title">write</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void <span class="function"><span class="title">privateWrite</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">publicWrite</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void <span class="function"><span class="title">protectedWrite</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。</p>
<p>在子类 Wangxiaoer 中定义一个 <code>main</code> 方法，并使用 <code>new</code> 关键字新建一个子类对象：</p>
<p><img src="/2020/07/07/Java-%E7%BB%A7%E6%89%BF/2.png" alt></p>
<p>可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。</p>
<p>不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Wanger(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：<br><img src="/2020/07/07/Java-%E7%BB%A7%E6%89%BF/3.png" alt></p>
<p>修复后的代码如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Wangxiaoer extends Wanger&#123;</span><br><span class="line">    public Wangxiaoer(int age, String name) &#123;</span><br><span class="line">        super(age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>is-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Wangxiaoer extends Wanger&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wanger wangxiaoer = new Wangxiaoer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，子接口的实现类的对象引用类型也可以是一个父接口类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface OneInterface extends Cloneable &#123;</span><br><span class="line">&#125;</span><br><span class="line">public class TestInterface implements OneInterface &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cloneable c1 = new TestInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：</p>
<blockquote>
<p>如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。</p>
</blockquote>
<p>FlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface FlyInterface &#123;</span><br><span class="line">    void fly();</span><br><span class="line">    default void <span class="function"><span class="title">sleep</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"睡着飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface RunInterface &#123;</span><br><span class="line">    void run();</span><br><span class="line">    default void <span class="function"><span class="title">sleep</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"睡着跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。<br><img src="/2020/07/07/Java-%E7%BB%A7%E6%89%BF/4.png" alt></p>
<p>原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig implements FlyInterface, RunInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">fly</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"会飞的猪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">sleep</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"只能重写了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"会跑的猪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface WalkInterface extends FlyInterface,RunInterface&#123;</span><br><span class="line">    void walk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 接口</title>
    <url>/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。</p>
<p>如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：</p>
<p>一个类只能继承一个抽象类，但却可以实现多个接口。<br>当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。</p>
<h1 id="01、接口是什么"><a href="#01、接口是什么" class="headerlink" title="01、接口是什么"></a>01、接口是什么</h1><p>接口是通过 <code>interface</code> 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface Electronic &#123;</span><br><span class="line">    // 常量</span><br><span class="line">    String LED = <span class="string">"LED"</span>;</span><br><span class="line"></span><br><span class="line">    // 抽象方法</span><br><span class="line">    int getElectricityUse();</span><br><span class="line"></span><br><span class="line">    // 静态方法</span><br><span class="line">    static boolean isEnergyEfficient(String electtronicType) &#123;</span><br><span class="line">        <span class="built_in">return</span> electtronicType.equals(LED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 默认方法</span><br><span class="line">    default void <span class="function"><span class="title">printDescription</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"电子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）接口中定义的变量会在编译的时候自动加上 <code>public static final</code> 修饰符，也就是说 LED 变量其实是一个常量。</p>
<p>Java 官方文档上有这样的声明：</p>
<blockquote>
<p>Every field declaration in the body of an interface is implicitly public, static, and final.</p>
</blockquote>
<p>换句话说，接口可以用来作为常量类使用，还能省略掉 <code>public static final</code>，看似不错的一种选择，对吧？</p>
<p>不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。</p>
<p>2）没有使用 <code>private</code>、<code>default</code> 或者 <code>static</code> 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 <code>public</code> <code>abstract</code> 修饰符。也就是说 <code>getElectricityUse()</code> 其实是一个抽象方法，没有方法体——这是定义接口的本意。</p>
<p>3）从 Java 8 开始，接口中允许有静态方法，比如说 <code>isEnergyEfficient()</code> 方法。</p>
<p>静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(“LED”)。</p>
<p>接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。</p>
<p>4）接口中允许定义 <code>default</code> 方法也是从 Java 8 开始的，比如说 <code>printDescription()</code>，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。<br><img src="/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/1.png" alt></p>
<p>允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 <code>default</code> 方法的帮助下，我们就必须挨个对实现类进行修改。</p>
<p>来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface Electronic</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public abstract int getElectricityUse();</span><br><span class="line"></span><br><span class="line">    public static boolean isEnergyEfficient(String electtronicType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> electtronicType.equals(<span class="string">"LED"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printDescription()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"\u7535\u5B50"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final String LED = <span class="string">"LED"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。</p>
<h1 id="02、定义接口的注意事项"><a href="#02、定义接口的注意事项" class="headerlink" title="02、定义接口的注意事项"></a>02、定义接口的注意事项</h1><p>由之前的例子我们就可以得出下面这些结论：</p>
<ul>
<li>接口中允许定义变量</li>
<li>接口中允许定义抽象方法</li>
<li>接口中允许定义静态方法（Java 8 之后）</li>
<li>接口中允许定义默认方法（Java 8 之后）</li>
</ul>
<p>除此之外，我们还应该知道：</p>
<p>1）接口不允许直接实例化。</p>
<p>需要定义一个类去实现接口，然后再实例化。<br><img src="/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/2.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Computer implements Electronic &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Computer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int <span class="function"><span class="title">getElectricityUse</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2）接口可以是空的，既不定义变量，也不定义方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Serializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。</p>
<blockquote>
<p><a href="http://www.itwanger.com/java/2019/11/14/java-serializable.html" target="_blank" rel="noopener">http://www.itwanger.com/java/2019/11/14/java-serializable.html</a></p>
</blockquote>
<p>3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。<br><img src="/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/3.png" alt></p>
<p>4）接口的抽象方法不能是 private、protected 或者 final。<br><img src="/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/4.png" alt></p>
<p><img src="/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/5.png" alt></p>
<p><img src="/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/6.png" alt></p>
<p>5）接口的变量是隐式 public static final，所以其值无法改变。</p>
<p>03、接口可以做什么</p>
<p>1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。</p>
<p>Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CloneableTest implements Cloneable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object <span class="built_in">clone</span>() throws CloneNotSupportedException &#123;</span><br><span class="line">        <span class="built_in">return</span> super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        CloneableTest c1 = new CloneableTest();</span><br><span class="line">        CloneableTest c2 = (CloneableTest) c1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后没有报错。现在把 implements Cloneable 去掉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CloneableTest &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object <span class="built_in">clone</span>() throws CloneNotSupportedException &#123;</span><br><span class="line">        <span class="built_in">return</span> super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        CloneableTest c1 = new CloneableTest();</span><br><span class="line">        CloneableTest c2 = (CloneableTest) c1.clone();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后抛出 CloneNotSupportedException：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest</span><br><span class="line">    at java.base/java.lang.Object.clone(Native Method)</span><br><span class="line">    at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)</span><br><span class="line">    at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)</span><br></pre></td></tr></table></figure>
<p>至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。</p>
<p><a href="http://www.itwanger.com/java/2020/01/04/java-comparable-comparator.html" target="_blank" rel="noopener">http://www.itwanger.com/java/2020/01/04/java-comparable-comparator.html</a></p>
<p>2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。</p>
<p>可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。</p>
<p>如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。<br><img src="/2020/07/07/Java-%E6%8E%A5%E5%8F%A3/7.png" alt></p>
<p>ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。</p>
<p>接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface Fly &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line">public interface Run &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后让一个类同时实现这两个接口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig implements Fly,Run&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">fly</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"会飞的猪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"会跑的猪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。</p>
<p>3）实现多态。</p>
<p>什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</p>
<p>多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。</p>
<p>Shape 是表示一个形状。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    String name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>圆是一个形状。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"圆"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正方形也是一个形状。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"正方形"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看测试类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();</span><br><span class="line">Shape circleShape = new Circle();</span><br><span class="line">Shape squareShape = new Square();</span><br><span class="line"></span><br><span class="line">shapes.add(circleShape);</span><br><span class="line">shapes.add(squareShape);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">    System.out.println(shape.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多态的存在 3 个前提：</p>
<p>1、要有继承关系，Circle 和 Square 都实现了 Shape 接口<br>2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法<br>3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。</p>
<p>然后，我们来看一下测试结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">圆</span><br><span class="line">正方形</span><br></pre></td></tr></table></figure>
<p>也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</p>
<p>04、接口与抽象类的区别</p>
<p>好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”</p>
<p>1）语法层面上</p>
<p>接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。<br>接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。<br>一个类只能继承一个抽象类，但却可以实现多个接口。<br>2）设计层面上</p>
<p>抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。</p>
<p>接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。</p>
<p>就这么多吧，能说道这份上，我相信面试官就不会为难你了。</p>
<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 抽象类</title>
    <url>/2020/07/07/Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。</p>
<h1 id="01、抽象类的-5-个关键点"><a href="#01、抽象类的-5-个关键点" class="headerlink" title="01、抽象类的 5 个关键点"></a>01、抽象类的 5 个关键点</h1><p>1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于抽象类的命名，阿里出品的 Java 开发手册上有强调，<code>抽象类命名要使用 Abstract 或 Base 开头</code>，记住了哦。</p>
<p>2）抽象类不能被实例化，但可以有子类。</p>
<p>尝试通过 <code>new</code> 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。</p>
<p><img src="/2020/07/07/Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/1.png" alt></p>
<p>通过 <code>extends</code> 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。</p>
<p>当在一个普通类（没有使用 <code>abstract</code> 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。</p>
<p>第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。</p>
<p><img src="/2020/07/07/Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/2.png" alt></p>
<p>第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。<br><img src="/2020/07/07/Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/3.png" alt></p>
<p>4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">sleep</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"运动员也要休息而不是挑战极限"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void <span class="function"><span class="title">play</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是张伯伦，篮球场上得过 100 分"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。</p>
<p><img src="/2020/07/07/Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/4.png" alt></p>
<h1 id="02、什么时候用抽象类"><a href="#02、什么时候用抽象类" class="headerlink" title="02、什么时候用抽象类"></a>02、什么时候用抽象类</h1><p>与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。</p>
<p>（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）</p>
<p>除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class BasketballPlayer &#123;</span><br><span class="line">   public void <span class="function"><span class="title">play</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是詹姆斯，现役第一人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有接口，有具体类，那什么时候该使用抽象类呢？</p>
<p>1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    public void <span class="function"><span class="title">sleep</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"运动员也要休息而不是挑战极限"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 AbstractPlayer 类可以不是抽象类——把 <code>abstract</code> 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</span><br><span class="line"></span><br><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br><span class="line">BasketballPlayer 对象可以直接调用 sleep() 方法：</span><br><span class="line"></span><br><span class="line">BasketballPlayer basketballPlayer = new BasketballPlayer();</span><br><span class="line">basketballPlayer.sleep();</span><br><span class="line">FootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</span><br><span class="line"></span><br><span class="line">public class FootballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br><span class="line">FootballPlayer 对象也可以直接调用 sleep() 方法：</span><br><span class="line"></span><br><span class="line">FootballPlayer footballPlayer = new FootballPlayer();</span><br><span class="line">footballPlayer.sleep();</span><br></pre></td></tr></table></figure>
<p>2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer  抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line">&#125;</span><br><span class="line">BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</span><br><span class="line"></span><br><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void <span class="function"><span class="title">play</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是张伯伦，我篮球场上得过 100 分，"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</span><br><span class="line"></span><br><span class="line">public class FootballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void <span class="function"><span class="title">play</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是C罗，我能接住任意高度的头球"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）如果父类与子类之间的关系符合 <code>is-a</code> 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。</p>
<h1 id="03、具体示例"><a href="#03、具体示例" class="headerlink" title="03、具体示例"></a>03、具体示例</h1><p>为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。</p>
<p>这时候，最好定义一个抽象类，比如说 BaseFileReader：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public abstract class BaseFileReader &#123;</span><br><span class="line">    protected Path filePath;</span><br><span class="line"></span><br><span class="line">    protected BaseFileReader(Path filePath) &#123;</span><br><span class="line">        this.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; readFile() throws IOException &#123;</span><br><span class="line">        <span class="built_in">return</span> Files.lines(filePath)</span><br><span class="line">                .map(this::mapFileLine).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract String mapFileLine(String line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。</p>
<p>readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。</p>
<p>你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。</p>
<p>小写的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class LowercaseFileReader extends BaseFileReader &#123;</span><br><span class="line">    protected LowercaseFileReader(Path filePath) &#123;</span><br><span class="line">        super(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String mapFileLine(String line) &#123;</span><br><span class="line">        <span class="built_in">return</span> line.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">大写的方式：</span><br><span class="line"></span><br><span class="line">public class UppercaseFileReader extends BaseFileReader &#123;</span><br><span class="line">    protected UppercaseFileReader(Path filePath) &#123;</span><br><span class="line">        super(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String mapFileLine(String line) &#123;</span><br><span class="line">        <span class="built_in">return</span> line.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。</p>
<p>接下来，我们来新建一个测试类 FileReaderTest：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class FileReaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws URISyntaxException, IOException &#123;</span><br><span class="line">        URL location = FileReaderTest.class.getClassLoader().getResource(<span class="string">"helloworld.txt"</span>);</span><br><span class="line">        Path path = Paths.get(location.toURI());</span><br><span class="line">        BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);</span><br><span class="line">        BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);</span><br><span class="line">        System.out.println(lowercaseFileReader.readFile());</span><br><span class="line">        System.out.println(uppercaseFileReader.readFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。<br><img src="/2020/07/07/Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/5.png" alt></p>
<p>可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。</p>
<p>输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[hello world]</span><br><span class="line">[HELLO WORLD]</span><br></pre></td></tr></table></figure>


<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 构造方法</title>
    <url>/2020/07/07/Java-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>假设现在有一个 Writer 类，它有两个字段，姓名和年纪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Writer&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", age=" + age +</span></span><br><span class="line"><span class="string">                '</span>&#125;<span class="string">';</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer writer = new Writer();</span><br><span class="line">System.out.println(writer.toString());</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer&#123;name=<span class="string">'null'</span>, age=0&#125;</span><br></pre></td></tr></table></figure>
<p>name 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。</p>
<p>让我们为 Writer 类主动加一个无参的构造方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public <span class="function"><span class="title">Writer</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">""</span>;</span><br><span class="line">    this.age = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。</p>
<p>接下来，让我们添加一个有参的构造方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public Writer(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer writer1 = new Writer(<span class="string">"沉默王二"</span>,18);</span><br><span class="line">System.out.println(writer1.toString());</span><br></pre></td></tr></table></figure>
<p>来看一下打印结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Writer&#123;name=<span class="string">'沉默王二'</span>, age=18&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public Writer(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public Writer(String name) &#123;</span><br><span class="line">    this(name,18);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。</p>
<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的类和对象</title>
    <url>/2020/07/07/Java-%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。</p>
<p>来，让我来定义一个简单的类给你看看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">eat</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Pig</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">eat</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：</p>
<p><code>Pig pig = new Pig();</code><br>当然了，我们也可以主动添加带参的构造方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Pig(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">eat</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Pig(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">eat</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。<br><img src="/2020/07/07/Java-%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1.png" alt></p>
<p>比如说你将代码修改为 new Pig(“纯白色”)，或者添加无参的构造方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Pig(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Pig</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">eat</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。</p>
<p><img src="/2020/07/07/Java-%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/2.png" alt></p>
<p>（图片中有一处错误，boolean 的默认值为 false）</p>
<p>接下来，我们来创建多个 Pig 对象，它的颜色各不相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class PigTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pig pigNoColor = new Pig();</span><br><span class="line">        Pig pigWhite = new Pig(<span class="string">"纯白色"</span>);</span><br><span class="line">        Pig pigBlack = new Pig(<span class="string">"纯黑色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。</p>
<p>那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。</p>
<p>最好的办法就是为 Pig 类追加 getter/setter 方法，就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public String <span class="function"><span class="title">getColor</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setColor(String color) &#123;</span><br><span class="line">    this.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Pig pigNoColor = new Pig();</span><br><span class="line">pigNoColor.setColor(<span class="string">"花色"</span>);</span><br><span class="line">System.out.println(pigNoColor.getColor()); // 花色</span><br></pre></td></tr></table></figure>
<p>为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter/setter 一样的效果了吗？</p>
<p>因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">public int <span class="function"><span class="title">getAge</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void <span class="function"><span class="title">increaseAge</span></span>() &#123;</span><br><span class="line">    this.age++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。</p>
<p>访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。</p>
<p>一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。</p>
<p>假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。<br><img src="/2020/07/07/Java-%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/3.png" alt></p>
<p>private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。</p>
<p>可以通过下面这张图来对比一下四个权限修饰符之间的差别：</p>
<p><img src="/2020/07/07/Java-%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/4.png" alt></p>
<ul>
<li>同一个类中，不管是哪种权限修饰符，都可以访问；</li>
<li>同一个包下，private 修饰的无法访问；</li>
<li>子类可以访问 public 和 protected 修饰的；</li>
<li>public 修饰符面向世界，哈哈，可以被所有的地方访问到。</li>
</ul>
<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 关键字</title>
    <url>/2020/07/07/Java-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。</p>
<p><code>abstract：</code> abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。</p>
<p><code>boolean：</code> boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。</p>
<p><code>break：</code> break 关键字用于中断循环或 switch 语句。</p>
<p><code>byte：</code> byte 关键字用于声明一个可以容纳 8 个比特的变量。</p>
<p><code>case：</code>  case 关键字用于在 switch 语句中标记条件的值。</p>
<p><code>catch：</code>  catch 关键字用于捕获 try 语句中的异常。</p>
<p><code>char：</code>  char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。</p>
<p><code>class：</code>  class 关键字用于声明一个类。</p>
<p><code>continue：</code>  continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。</p>
<p><code>default：</code>  default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。</p>
<p><code>do：</code>  do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。</p>
<p><code>double：</code> double 关键字用于声明一个可以容纳 64 位浮点数的变量。</p>
<p><code>else：</code>  else 关键字用于指示 if 语句中的备用分支。</p>
<p><code>enum：</code>  enum（枚举）关键字用于定义一组固定的常量。</p>
<p><code>extends：</code>  extends 关键字用于指示一个类是从另一个类或接口继承的。</p>
<p><code>final：</code>  final 关键字用于指示该变量是不可更改的。</p>
<p><code>finally：</code>  finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>
<p><code>float：</code>  float 关键字用于声明一个可以容纳 32 位浮点数的变量。</p>
<p><code>for：</code>  for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>
<p><code>if：</code>  if 关键字用于指定条件，如果条件为真，则执行对应代码。</p>
<p><code>implements：</code>  implements 关键字用于实现接口。</p>
<p><code>import：</code>  import 关键字用于导入对应的类或者接口。</p>
<p><code>instanceof：</code>  instanceof 关键字用于判断对象是否属于某个类型（class）。</p>
<p><code>int：</code>  int 关键字用于声明一个可以容纳 32 位带符号的整数变量。</p>
<p><code>interface：</code>  interface 关键字用于声明接口——只能具有抽象方法。</p>
<p><code>long：</code>  long 关键字用于声明一个可以容纳 64 位整数的变量。</p>
<p><code>native：</code>  native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。</p>
<p><code>new：</code>  new 关键字用于创建一个新的对象。</p>
<p><code>null：</code>  如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。</p>
<p><code>package：</code>  package 关键字用于声明类所在的包。</p>
<p><code>private：</code>  private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。</p>
<p><code>protected：</code>  protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。</p>
<p><code>public：</code>  public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>
<p><code>return：</code>  return 关键字用于在代码执行完成后返回（一个值）。</p>
<p><code>short：</code> short 关键字用于声明一个可以容纳 16 位整数的变量。</p>
<p><code>static：</code>  static 关键字表示该变量或方法是静态变量或静态方法。</p>
<p><code>strictfp：</code>   strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</p>
<p><code>super：</code>  super 关键字可用于调用父类的方法或者变量。</p>
<p><code>switch：</code>  switch 关键字通常用于三个（以上）的条件判断。</p>
<p><code>synchronized：</code>  synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。</p>
<p><code>this：</code>  this 关键字可用于在方法或构造函数中引用当前对象。</p>
<p><code>throw：</code>  throw 关键字主动抛出异常。</p>
<p><code>throws：</code>  throws 关键字用于声明异常。</p>
<p><code>transient：</code>  transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。</p>
<p><code>try：</code>  try 关键字用于包裹要捕获异常的代码块。</p>
<p><code>void：</code>  void 关键字用于指定方法没有返回值。</p>
<p><code>volatile：</code>  volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p><code>while：</code>  如果循环次数不固定，建议使用 while 循环。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基本数据类型</title>
    <url>/2020/07/07/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="center">默认值</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="center">false</td>
<td align="center">1比特</td>
</tr>
<tr>
<td align="left">char</td>
<td align="center">‘\u0000’</td>
<td align="center">2字节</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="center">0</td>
<td align="center">1字节</td>
</tr>
<tr>
<td align="left">short</td>
<td align="center">0</td>
<td align="center">2字节</td>
</tr>
<tr>
<td align="left">int</td>
<td align="center">0</td>
<td align="center">4字节</td>
</tr>
<tr>
<td align="left">long</td>
<td align="center">0L</td>
<td align="center">8字节</td>
</tr>
<tr>
<td align="left">float</td>
<td align="center">0.0f</td>
<td align="center">4字节</td>
</tr>
<tr>
<td align="left">double</td>
<td align="center">0.0</td>
<td align="center">8字节</td>
</tr>
</tbody></table>
<h1 id="01、布尔"><a href="#01、布尔" class="headerlink" title="01、布尔"></a>01、布尔</h1><p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p>
<p><code>boolean flag = true;</code></p>
<h1 id="02、byte"><a href="#02、byte" class="headerlink" title="02、byte"></a>02、byte</h1><p>byte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。</p>
<p>在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byte a = 10;</span><br><span class="line">byte b = -10;</span><br></pre></td></tr></table></figure>
<h1 id="03、short"><a href="#03、short" class="headerlink" title="03、short"></a>03、short</h1><p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">short s = 10000;</span><br><span class="line">short r = -5000;</span><br></pre></td></tr></table></figure>
<h1 id="04、int"><a href="#04、int" class="headerlink" title="04、int"></a>04、int</h1><p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int a = 100000;</span><br><span class="line">int b = -200000;</span><br></pre></td></tr></table></figure>
<h1 id="05、long"><a href="#05、long" class="headerlink" title="05、long"></a>05、long</h1><p>long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">long a = 100000L; </span><br><span class="line">long b = -200000L;</span><br></pre></td></tr></table></figure>
<p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p>
<h1 id="06、float"><a href="#06、float" class="headerlink" title="06、float"></a>06、float</h1><p>float 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> f1 = 234.5f;</span><br></pre></td></tr></table></figure>
<p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p>
<h1 id="07、double"><a href="#07、double" class="headerlink" title="07、double"></a>07、double</h1><p>double 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">double d1 = 12.3</span><br></pre></td></tr></table></figure>
<p>那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。</p>
<p>Tips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。<br><img src="/2020/07/07/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/double01.png" alt></p>
<p>双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。</p>
<p><img src="/2020/07/07/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/double02.png" alt><br>取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>
<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>
<h1 id="08、char"><a href="#08、char" class="headerlink" title="08、char"></a>08、char</h1><p>char 可以表示一个 16 位的 Unicode 字符，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。代码示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char letterA = <span class="string">'A'</span>; // 用英文的单引号包裹住。</span><br></pre></td></tr></table></figure>

<p>摘抄自：<a href="https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ySGMnBLhKtBnztivj_ImEg</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java main()</title>
    <url>/2020/07/07/Java-main/</url>
    <content><![CDATA[<p>每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。</p>
<p>public static void main(<code>String[] args</code>) {}<br>public、static、void 这 3 个关键字在前面的内容已经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：</p>
<p>public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>
<p>static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。</p>
<p>void 关键字用于指定方法没有返回值。</p>
<p>另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。</p>
<p>java HelloWorld 沉默王二 沉默王三<br>javac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"沉默王二"</span>.equals(args[0])) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"沉默王三"</span>.equals(args[1])) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。</p>
<p>第二种，把方括号 [] 往 args 靠近而不是 String 靠近：</p>
<p><code>public static void main(String []args) { }</code><br>第三种，把方括号 [] 放在 args 的右侧：</p>
<p><code>public static void main(String args[]) { }</code><br>第四种，还可以把数组形式换成可变参数的形式：</p>
<p><code>public static void main(String...args) { }</code><br>第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：</p>
<p><code>public strictfp static void main(String[] args) { }</code><br>也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。</p>
<p>第六种，还可以为 args 参数添加 final 关键字：</p>
<p><code>public static void main(final String[] args) { }</code><br>第七种，最复杂的一种，所有可以添加的关键字统统添加上：</p>
<p><code>final static synchronized strictfp void main(final String[] args) { }</code><br>当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 包</title>
    <url>/2020/07/07/Java-%E5%8C%85/</url>
    <content><![CDATA[<p>在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：</p>
<p>使相关类型更容易查找<br>避免命名冲突，比如说 <code>com.itwanger.Hello</code> 和 <code>com.itwangsan.Hello</code> 不同<br>通过包和访问权限控制符来限定类的可见性</p>
<h1 id="01、创建一个包"><a href="#01、创建一个包" class="headerlink" title="01、创建一个包"></a>01、创建一个包</h1><p>package com.itwanger;<br>可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。</p>
<p>包的命名应该遵守以下规则：</p>
<p>应该全部是小写字母<br>可以包含多个单词，单词之间使用“.”连接，比如说 java.lang<br>名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 <a href="http://www.itwanger.com，所以我创建的包名是就是" target="_blank" rel="noopener">www.itwanger.com，所以我创建的包名是就是</a> com.itwanger.xxxx。<br>每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com-&gt;itwanger-&gt;xxxx。</p>
<h1 id="02、使用包"><a href="#02、使用包" class="headerlink" title="02、使用包"></a>02、使用包</h1><p>让我们在名为 test 的子包里新建一个 Cmower 类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.itwanger.test;</span><br><span class="line"></span><br><span class="line">public class Cmower &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，<code>使用 * 导入包下所有的类：</code></p>
<p><code>import com.itwanger.test.*;</code></p>
<p>第二种，使用类名导入该类：</p>
<p>import com.itwanger.test.Cmower;<br>Java 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.itwanger.test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CmowerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Cmower());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="03、全名"><a href="#03、全名" class="headerlink" title="03、全名"></a>03、全名</h1><p>有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。<code>当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">List&lt;com.itwanger.test.Cmower&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new com.itwanger.test.Cmower());</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python根据excel表格编号匹配csv的url</title>
    <url>/2020/06/24/Python%E6%A0%B9%E6%8D%AEexcel%E8%A1%A8%E6%A0%BC%E7%BC%96%E5%8F%B7%E5%8C%B9%E9%85%8Dcsv%E7%9A%84url/</url>
    <content><![CDATA[<ul>
<li><p><code>export_urls.csv</code>是阿里云oss导出的url表，其中有四个列表字段，依次是：id,barcode,type,serial,img_url</p>
</li>
<li><p><code>2.xlsx</code> 是所依据的excel表格，固定的第一列是barcode。</p>
</li>
<li><p><code>data.xlsx</code>是生成的结果数据。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line">import re</span><br><span class="line">import pandas as pd</span><br><span class="line">from openpyxl import Workbook</span><br><span class="line"></span><br><span class="line">rz = re.compile(r<span class="string">'/(\d+-\d)-.+jpg'</span>)</span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">dkey = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def open_csv():</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> file_paths:</span><br><span class="line">        ex = pd.read_csv(file)</span><br><span class="line">        exs = ex.values.tolist()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> exs:</span><br><span class="line">            url = i[4]</span><br><span class="line">            url_id = rz.findall(url)</span><br><span class="line">            <span class="built_in">print</span>(url_id)</span><br><span class="line">            <span class="keyword">if</span> len(url_id)== 0 :</span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">            url_id = url_id[0]</span><br><span class="line">            <span class="keyword">if</span> url_id not <span class="keyword">in</span> d:</span><br><span class="line">                d.update(&#123;url_id: [url]&#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[url_id].append(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">        ks = str(k).split(<span class="string">'-'</span>)</span><br><span class="line">        k1 = ks[0]</span><br><span class="line">        k2 = ks[1]</span><br><span class="line">        <span class="keyword">if</span> k1 not <span class="keyword">in</span> dkey:</span><br><span class="line">            <span class="keyword">if</span> str(k2) == <span class="string">'1'</span>:</span><br><span class="line">                dkey.update(&#123;k1: &#123;<span class="string">'0'</span>: [], <span class="string">'1'</span>: v&#125;&#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dkey.update(&#123;k1: &#123;<span class="string">'0'</span>: v, <span class="string">'1'</span>: []&#125;&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> str(k2) == <span class="string">'1'</span>:</span><br><span class="line">                dkey[k1][<span class="string">'1'</span>].extend(v)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dkey[k1][<span class="string">'0'</span>].extend(v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> dkey.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">type</span>(k), v)</span><br><span class="line">        wb.append([str(k), str(v[<span class="string">'0'</span>]), str(v[<span class="string">'1'</span>])])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> orl_key:</span><br><span class="line">        <span class="keyword">if</span> str(i) not <span class="keyword">in</span> dkey:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">type</span>(i), <span class="string">'iii'</span>)</span><br><span class="line">            wb.append([str(i)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    orl_urlids = pd.read_excel(r<span class="string">'2.xlsx'</span>)</span><br><span class="line">    orl_urls = orl_urlids.values.tolist()</span><br><span class="line">    orl_key = [i[0] <span class="keyword">for</span> i <span class="keyword">in</span> orl_urls]</span><br><span class="line"></span><br><span class="line">    wk = Workbook()</span><br><span class="line">    wb = wk.active</span><br><span class="line"></span><br><span class="line">    file_paths = [<span class="string">'./export_urls.csv'</span>]</span><br><span class="line">    open_csv()</span><br><span class="line">    wk.save(r<span class="string">'data.xlsx'</span>)</span><br><span class="line">    <span class="comment"># """</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>gorm.Model的包含字段</title>
    <url>/2020/05/20/gorm-Model%E7%9A%84%E5%8C%85%E5%90%AB%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p><a href="https://github.com/jinzhu/gorm/blob/master/model.go" target="_blank" rel="noopener">gorm.Model</a>源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package gorm</span><br><span class="line"></span><br><span class="line">import <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">// Model base model definition, including fields `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`, <span class="built_in">which</span> could be embedded <span class="keyword">in</span> your models</span><br><span class="line">//    <span class="built_in">type</span> User struct &#123;</span><br><span class="line">//      gorm.Model</span><br><span class="line">//    &#125;</span><br><span class="line"><span class="built_in">type</span> Model struct &#123;</span><br><span class="line">	ID        uint `gorm:<span class="string">"primary_key"</span>`</span><br><span class="line">	CreatedAt time.Time</span><br><span class="line">	UpdatedAt time.Time</span><br><span class="line">	DeletedAt *time.Time `sql:<span class="string">"index"</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们创建结构体的时候的就不需要包含这几个字段了，不然后会报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> User struct &#123;</span><br><span class="line">	Id            int        `json:<span class="string">"id"</span> form:<span class="string">"id"</span> gorm:<span class="string">"primary_key"</span>` // 主键ID</span><br><span class="line">	CreatedAt     time.Time  `gorm:<span class="string">""</span>json:<span class="string">"createdAt"</span>`                // 创建时间</span><br><span class="line">	UpdatedAt     time.Time  `gorm:<span class="string">""</span>json:<span class="string">"updatedAt"</span>`                // 更新时间</span><br><span class="line">	DeletedAt     *time.Time `gorm:<span class="string">"index"</span>json:<span class="string">"deletedAt"</span>`           // 删除时间</span><br><span class="line">	Name          string     `gorm:<span class="string">"not null;"</span>json:<span class="string">"name"</span>`            // 姓名</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*User) TableName() string &#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">"user"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *User) IsAdministrator() bool &#123;</span><br><span class="line">	<span class="keyword">if</span> m == nil || m.Id &lt;= 0 &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> m.Role == 0 || m.Role == 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panic: Error 1146: Table <span class="string">'XXXX.user'</span> doesn<span class="string">'t exist</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">goroutine 1 [running]:</span></span><br><span class="line"><span class="string">github.com/jinzhu/gorm.mysql.HasIndex(0x1a3ebc0, 0xc0000fe240, 0x203000, 0x19037e8, 0x4, 0xc00059ddc0, 0x13, 0x30c8300)</span></span><br><span class="line"><span class="string">        /Users/samtake/go/pkg/mod/github.com/jinzhu/gorm@v1.9.12/dialect_mysql.go:189 +0x31f</span></span><br><span class="line"><span class="string">github.com/jinzhu/gorm.(*Scope).addIndex(0xc0004ec380, 0x18ecd00, 0xc00059ddc0, 0x13, 0xc00037b5a0, 0x2, 0x2)</span></span><br><span class="line"><span class="string">        /Users/samtake/go/pkg/mod/github.com/jinzhu/gorm@v1.9.12/scope.go:1212 +0x8d</span></span><br><span class="line"><span class="string">github.com/jinzhu/gorm.(*DB).AddIndex(0xc00001dee0, 0xc00059ddc0, 0x13, 0xc00037b5a0, 0x2, 0x2, 0x1)</span></span><br><span class="line"><span class="string">        /Users/samtake/go/pkg/mod/github.com/jinzhu/gorm@v1.9.12/main.go:706 +0xac</span></span><br><span class="line"><span class="string">github.com/jinzhu/gorm.(*Scope).autoIndex(0xc000559900, 0xc000559900)</span></span><br><span class="line"><span class="string">        /Users/samtake/go/pkg/mod/github.com/jinzhu/gorm@v1.9.12/scope.go:1312 +0x9a0</span></span><br><span class="line"><span class="string">github.com/jinzhu/gorm.(*Scope).createTable(0xc000559900, 0x19037e8)</span></span><br><span class="line"><span class="string">        /Users/samtake/go/pkg/mod/github.com/jinzhu/gorm@v1.9.12/scope.go:1194 +0x792</span></span><br></pre></td></tr></table></figure>

<p>改成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/jinzhu/gorm"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> User struct &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	Name          string    `gorm:<span class="string">"not null;"</span>json:<span class="string">"name"</span>`     // 姓名</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*User) TableName() string &#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">"user"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *User) IsAdministrator() bool &#123;</span><br><span class="line">	<span class="keyword">if</span> m == nil || m.ID &lt;= 0 &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> m.Role == 0 || m.Role == 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>通过drawio插件在vs code上画流程图</title>
    <url>/2020/05/19/%E9%80%9A%E8%BF%87drawio%E6%8F%92%E4%BB%B6%E5%9C%A8vs-code%E4%B8%8A%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="打开vs-code-搜索并安装插件drawio"><a href="#打开vs-code-搜索并安装插件drawio" class="headerlink" title="打开vs code 搜索并安装插件drawio"></a>打开vs code 搜索并安装插件drawio</h1><p><img src="/2020/05/19/%E9%80%9A%E8%BF%87drawio%E6%8F%92%E4%BB%B6%E5%9C%A8vs-code%E4%B8%8A%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/drawio01.png" alt="drawio01"></p>
<h1 id="创建一个后缀为drawio的文件，即可惊醒流程图的编辑"><a href="#创建一个后缀为drawio的文件，即可惊醒流程图的编辑" class="headerlink" title="创建一个后缀为drawio的文件，即可惊醒流程图的编辑"></a>创建一个后缀为drawio的文件，即可惊醒流程图的编辑</h1><p><img src="/2020/05/19/%E9%80%9A%E8%BF%87drawio%E6%8F%92%E4%BB%B6%E5%9C%A8vs-code%E4%B8%8A%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/drawio02.png" alt="drawio02"></p>
]]></content>
  </entry>
  <entry>
    <title>swagger的使用</title>
    <url>/2020/05/14/swagger%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Mac首选brew安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap go-swagger/go-swagger</span><br><span class="line">brew install go-swagger</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swagger generate spec -o ./swagger.json --scan-models</span><br><span class="line">swagger serve -F=swagger swagger.json</span><br></pre></td></tr></table></figure>
<p>其中 swagger.json文件是使用过命令行来生成的，然后进去编写自己的规则。</p>
<p>小编直接拉去别的项目swagger.json文件时，跑起来出错了，你只需要通过swagger命令行创建后再复制内容进去即可。<br><code>No operations defined in spec!</code></p>
<p><img src="/2020/05/14/swagger%E7%9A%84%E4%BD%BF%E7%94%A8/swagger01.png" alt="swagger01.png"></p>
<p>资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/136521497" target="_blank" rel="noopener">如何使用 SwaggerUI 创建 Golang API 文档？</a></p>
<p><a href="https://blog.csdn.net/qq_37493556/article/details/104081138" target="_blank" rel="noopener">go-swagger安装及使用</a></p>
]]></content>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计</title>
    <url>/2020/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>表设计</p>
<ul>
<li>DDL（Data Definition Language）数据库模式定义语言</li>
<li>表字段类型选择。</li>
<li>3范式，三种表间关系：一对一，一对多，多对多。</li>
</ul>
<p>表使用</p>
<ul>
<li>基本查询语句。</li>
<li>SQL语句优先级。</li>
<li>链接查询：子查询，组合查询。</li>
<li>select…from…where…group by…having…order by..limit</li>
</ul>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><p>库的创建<br><code>create database 库名；</code><br><code>create database if not existe 库名；</code></p>
<p>更改库的字符集<br><code>alter database books character set gbk；</code></p>
<p>库的删除<br><code>drop database if exists 库名；</code></p>
<p>表的创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table 表名（</span><br><span class="line">    列名  列的类型【（长度）约束】</span><br><span class="line">    列名  列的类型【（长度）约束】</span><br><span class="line">   .......</span><br><span class="line">    列名  列的类型【（长度）约束】）</span><br><span class="line"></span><br><span class="line">create table book(</span><br><span class="line">    id  int,</span><br><span class="line">    bname varchar(20),</span><br><span class="line">    prince double,</span><br><span class="line">    authorid int,</span><br><span class="line">    publishbate datetime)</span><br></pre></td></tr></table></figure>


<p>表的修改<br><code>alter table 表名 add/drop/modify/change column 列名 列类型 约束；</code></p>
<ul>
<li>修改列名 <code>alter table 表名 change column 旧列名 新列名 类型；</code></li>
<li>修改列的类型及约束 <code>alter table 表名 modify column 列名 要修改的类型</code></li>
<li>添加新列 <code>alter table author add column annual double；</code></li>
<li>删除列 <code>alter table author drop column annual ；</code></li>
<li>修改表名 <code>alter table  author rename to bookauthor;</code></li>
<li>表的删除 <code>drop table if exists 表名；</code></li>
<li>查看 <code>show tables</code> </li>
</ul>
<ul>
<li><p>通用的写法</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop database <span class="keyword">if</span> exists 旧库名；</span><br><span class="line"></span><br><span class="line">create batabase 新库名；</span><br><span class="line"></span><br><span class="line">drop table <span class="keyword">if</span> exists 旧表名；</span><br><span class="line"></span><br><span class="line">create table 表名（）；</span><br><span class="line"></span><br><span class="line">desc 表名 （查看表结构）</span><br></pre></td></tr></table></figure>
</li>
<li><p>表的复制 </p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.仅仅复制表的结构</span></span><br><span class="line">create table 新表名  like  author；</span><br><span class="line"><span class="comment">#2.复制表的结构+数据</span></span><br><span class="line">create table 新表名</span><br><span class="line">select *from 旧表名；</span><br><span class="line"><span class="comment">#3.只复制部分数据</span></span><br><span class="line">create teble 新表名</span><br><span class="line">select 列名，..</span><br><span class="line">from 旧表名</span><br><span class="line"><span class="built_in">where</span> 筛选条件；</span><br><span class="line"><span class="comment">#4.仅仅复制某些结构</span></span><br><span class="line">create table 新表名 </span><br><span class="line">select 列名，..</span><br><span class="line">from 旧表名</span><br><span class="line"><span class="built_in">where</span>  0（谁都不满足的条件）；</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="表字段类型"><a href="#表字段类型" class="headerlink" title="表字段类型"></a>表字段类型</h1><h2 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h2><table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">类型</th>
<th align="left">字节</th>
<th align="left">举例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">tinyint</td>
<td align="left">1</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">smallint</td>
<td align="left">2</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">mediumint</td>
<td align="left">3</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">int<br>integer</td>
<td align="left">4<br>4</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">bigint</td>
<td align="left">1</td>
<td align="left">8</td>
<td align="left">-</td>
</tr>
</tbody></table>
<ul>
<li><p>如何设置有符号和无符号<br>  默认是有符号，设置无符号追加unsigned</p>
</li>
<li><p>插入数值超出整型范围<br>  报异常：out of range，并且插入的是临界值</p>
</li>
<li><p>如果不设置长度会有默认的长度<br>  zerofill（零填充，默认无符号），显示结果的最大宽度，不过会在左边用0填充</p>
</li>
</ul>
<h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">类型</th>
<th align="left">举例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">dec<br>decimal</td>
<td align="left">dec(M,D)<br>decimal(M,D)</td>
<td align="left">定点型</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">float<br>double</td>
<td align="left">float(M,D)<br>double(M,D)</td>
<td align="left">浮点型</td>
</tr>
</tbody></table>
<ul>
<li><p>M是整数部位加小数部位的总长度，D是小数点后保留的位数<br>  超过插入的是临界值</p>
</li>
<li><p>M和D都可省略，如果是decimal，M默认为10，D默认为0<br>  如果是float和double，则会根据插入的数值决定</p>
</li>
<li><p>定点型精确度较高，要求插入数值精度较高优先用，如货币运算等则等<br>  其他一般用float就可以。</p>
</li>
<li><p>选择类型越简单越好，保存数值越小越好</p>
</li>
</ul>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">类型</th>
<th align="left">举例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">较短的文本</td>
<td align="left">char<br>varchar</td>
<td align="left">char(M)<br>varchar(M)</td>
<td align="left">M表示最大的字符数，可省略，默认为1 固定长度的字符 比较耗费空间 <br> M表示最大的字符数，不可省略 可变长度的字符 比较节省空间</td>
</tr>
<tr>
<td align="left">较长的文本</td>
<td align="left">text<br>blob</td>
<td align="left">-</td>
<td align="left">较长的二进制数据</td>
</tr>
</tbody></table>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">类型</th>
<th align="left">举例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">date</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">datetime</td>
<td align="left">-</td>
<td align="left">datetime范围1000-1-1—-9999-12-31，不受时区影响</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">timestamp</td>
<td align="left">-</td>
<td align="left">受时区影响</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">time</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">year</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<h2 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h2><table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">字段</th>
<th align="left">举例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">not null</td>
<td align="left">-</td>
<td align="left">非空，用于保证该字段的值不能为空，如姓名、学号</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">default</td>
<td align="left">-</td>
<td align="left">默认，用于保证该字段有默认值，如性别</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">primary key</td>
<td align="left">-</td>
<td align="left">主键，用于保证该字段的值具有唯一性，并且非空，如学号、员工编号</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">unique</td>
<td align="left">-</td>
<td align="left">唯一、用于保证该字段的值具有唯一性，可以为空，如座位号</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">check</td>
<td align="left">-</td>
<td align="left">检查约束，mysql中不支持，如年龄、性别</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">foreign key</td>
<td align="left">-</td>
<td align="left">外键，用于限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值。在从表添加外键约束，用于引用主表中某列的值。</td>
</tr>
</tbody></table>
<ul>
<li><p>添加约束的时机：创建表时/修改表时</p>
</li>
<li><p>约束的添加分类：</p>
<ul>
<li>列级约束：六大约束语法都支持但外键约束没有效果</li>
<li>表级约束;除了非空、默认，其他的都支持</li>
</ul>
</li>
</ul>
<h1 id="创建表时添加约束"><a href="#创建表时添加约束" class="headerlink" title="创建表时添加约束"></a>创建表时添加约束</h1><h2 id="添加列级约束"><a href="#添加列级约束" class="headerlink" title="添加列级约束"></a>添加列级约束</h2><p>直接在字段名和类型后面追加 约束类型即可<br>只支持：默认、非空、主键、唯一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table 表名（</span><br><span class="line">         字段名   字段类型   列级约束，</span><br><span class="line">       字段名  字段类型，</span><br><span class="line">       表级约束</span><br><span class="line">）</span><br><span class="line">create table stuinfo（</span><br><span class="line">    id  int primary  key,</span><br><span class="line">    stuname  varchar(20)  not  null,</span><br><span class="line">    gender   char(1)  check(gender=<span class="string">'男'</span> or gender = <span class="string">'女'</span>），</span><br><span class="line">    age  int default  18</span><br><span class="line">   majorid  int foreign key references major（id）</span><br><span class="line">）；</span><br></pre></td></tr></table></figure>


<h2 id="添加表级约束"><a href="#添加表级约束" class="headerlink" title="添加表级约束"></a>添加表级约束</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create table stuinfo（</span><br><span class="line">    id  int ,</span><br><span class="line">    stuname  varchar(20) ,</span><br><span class="line">    gender   char(1) ，</span><br><span class="line">    age  int，</span><br><span class="line">   majorid  int，</span><br><span class="line">   </span><br><span class="line">   constraint pk primary  key（id）,<span class="comment">#主键</span></span><br><span class="line">   constraint uq unique（seat），<span class="comment">#唯一键</span></span><br><span class="line">   constraint ck check(gender=<span class="string">'男'</span> or gender = <span class="string">'女'</span>），</span><br><span class="line">   constraint fk_syuinfo_major   foreign key(majorid) references major（id）<span class="comment">#外键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在各个字段的最下面添加：&lt;<code>constraint</code> 约束名&gt; 约束类型（字段名）</p>
<h1 id="主键与唯一的对比"><a href="#主键与唯一的对比" class="headerlink" title="主键与唯一的对比"></a>主键与唯一的对比</h1><ul>
<li>主键：保持唯一性 / 不允许为空/一个表中只至少有一个/两个列可以组合为一个主键但不推荐</li>
<li>唯一：保持唯一性 / 允许为空 /可以有多个/可以组合但不推荐</li>
</ul>
<h1 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h1><ul>
<li><p>要求在从表设置外键关系</p>
</li>
<li><p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p>
</li>
<li><p>主表的关联列必须是一个key（一般是主键或唯一）</p>
</li>
<li><p>插入数据时，先插入主表数据再插入从表</p>
</li>
<li><p>删除数据先删除从表再删除主表</p>
</li>
</ul>
<h1 id="修改表时添加约束"><a href="#修改表时添加约束" class="headerlink" title="修改表时添加约束"></a>修改表时添加约束</h1><p>列级约束：<code>alter table 表名 modify column 字段名 字段类型 新约束；</code></p>
<p>表级约束：<code>alter table 表名 add &lt;constriaint 约束名&gt; 约束类型（字段名）&lt;外键的引用&gt;；</code></p>
<ul>
<li><p>添加非空约束 <code>alter table 表名 modify column 列名 要修改的类型  not null</code></p>
</li>
<li><p>默认约束 <code>alter table 表名 modify column 列名 int default 18</code></p>
</li>
<li><p>添加主键<br>  <code>列级约束 alter table 表名 modify column 列名 int default key；</code><br>  <code>表级约束  alter table 表名 add primary key(列名)</code></p>
</li>
<li><p>添加唯一<br>  <code>列级约束  alter table 表名 add primary key(列名) 要修改的类型  notnull</code><br>  <code>表级约束   alter table 表名 add unique（列名）</code> </p>
</li>
<li><p>添加外键 <code>alter table 表名 add foreign key（majorid） references major（id）</code></p>
</li>
</ul>
<h1 id="修改表时删除约束"><a href="#修改表时删除约束" class="headerlink" title="修改表时删除约束"></a>修改表时删除约束</h1><p>删除非空 <code>alter table 表名 modify column 列名 varchar（20） null；</code><br>删除默认约束 <code>alter table 表名 modify column 列名  int；</code><br>删除主键 <code>alter table 表名 drop primary key；</code><br>删除唯一 <code>alter table 表名 drop index 列名；</code><br>删除外键 <code>alter table 表名 drop foreign key 列名；</code></p>
<h1 id="3范式"><a href="#3范式" class="headerlink" title="3范式"></a>3范式</h1><h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p>保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式。</p>
<p>例如将地址的拆分：</p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">姓名</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">张三</td>
<td align="left">广东广州天河</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">李四</td>
<td align="left">广东佛山禅城</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">王五</td>
<td align="left">广东广州科学城</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">姓名</th>
<th align="left">省份</th>
<th align="left">城市</th>
<th align="left">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">张三</td>
<td align="left">广东</td>
<td align="left">广州</td>
<td align="left">天河</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">李四</td>
<td align="left">广东</td>
<td align="left">佛山</td>
<td align="left">禅城</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">王五</td>
<td align="left">广东</td>
<td align="left">广州</td>
<td align="left">科学城</td>
</tr>
</tbody></table>
<h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p>保证一张表只描述一件事情。<br>在满足第一范式的基础上，数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，也即所有非关键字段都完全依赖于任一组候选关键字。</p>
<p>举例：<br>| 学号    | 姓名    | 年龄 | 课程 | 成绩 | 学分 |<br>| :—–| :—–| :—-|  :—-|  :—-|  :—-|<br>| 1 | 张三  | 20 | 数学 | 90 | 1 |<br>| 2 | 李四  | 20 | 语文 | 90 | 1 |<br>| 3 | 王五  | 20 | 英语 | 50 | 1 |</p>
<p>上表满足第一范式，即每个字段不可再分，但这张表的设计并不满足第二范式。因为这张表里面描述了两件事情：学生信息、课程信息，”学分”完全依赖于”课程名称”、”姓名”与”年龄”完全依赖于”学号”。这么做的后果是：</p>
<ul>
<li><p>数据冗余：同一门课程由n个学生选修，”学分”重复n-1次；同一个学生选修了m门课程，姓名和年龄重复m-1次</p>
</li>
<li><p>更新异常：若调整了某门课程的学分，数据表中所有行的”学分”值都需要更新，否则会出现同一门课程学分不同的情况</p>
</li>
<li><p>插入异常：假设要开一门新课程，暂时没有人选修，那么由于没有”学号”关键字，”课程”与”学分”也无法记录入数据库</p>
</li>
<li><p>删除异常：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，”课程”和”学分”也被删除了，显然，这最终可能会导致插入异常</p>
</li>
</ul>
<p>优化后的表设计如下：<br>| 学号    | 姓名    | 年龄 |<br>| :—–| :—–| :—-|<br>| 1 | 张三  | 20 |<br>| 2 | 李四  | 20 |<br>| 3 | 王五  | 20 |</p>
<table>
<thead>
<tr>
<th align="left">课程</th>
<th align="left">学分</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数学</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">语文</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">英语</td>
<td align="left">1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">学号</th>
<th align="left">课程</th>
<th align="left">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">数学</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">语文</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">英语</td>
<td align="left">50</td>
</tr>
</tbody></table>
<p>增加了表，将学生信息与课程信息通过一张中间表关联，很好地解决了上面的几个问题，这就是第二范式的中心—-保证一张表只讲一件事情。</p>
<h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p>数据库表中如果不存在非关键字段任一候选关键字段的传递函数依赖则符合第三范式，所谓传递函数依赖指的是如果存在”A–&gt;B–&gt;C”的决定关系，则C传递函数依赖于A。也就是说<code>中的字段和主键直接对应不依靠其他中间字段，说白了就是，决定某字段值的必须是主键。</code></p>
<p>举例：</p>
<table>
<thead>
<tr>
<th align="left">学号</th>
<th align="left">姓名</th>
<th align="left">年龄</th>
<th align="left">学院地点</th>
<th align="left">学院电话</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">张三</td>
<td align="left">20</td>
<td align="left">计算机学院</td>
<td align="left">9号楼</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">李四</td>
<td align="left">20</td>
<td align="left">计算机学院</td>
<td align="left">9号楼</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">王五</td>
<td align="left">20</td>
<td align="left">计算机学院</td>
<td align="left">9号楼</td>
</tr>
</tbody></table>
<p>从这张数据库表结构中可以看出：</p>
<ul>
<li><p>“姓名”、”年龄”、”学院”和主键”学号”直接关联。</p>
</li>
<li><p>但是”学院地点”、”学院电话”却不直接和主键”学号”相关联，和”学院电话”直接相关联的是”学院”。</p>
</li>
<li><p>如果表结构这么设计，同样会造成和第二范式一样的数据冗余、更新异常、插入异常、删除异常的问题。</p>
</li>
</ul>
<p>优化后的表设计：</p>
<table>
<thead>
<tr>
<th align="left">学院</th>
<th align="left">学院地点</th>
<th align="left">学院电话</th>
</tr>
</thead>
<tbody><tr>
<td align="left">计算机学院</td>
<td align="left">9号楼</td>
<td align="left">11111</td>
</tr>
<tr>
<td align="left">艺术学院</td>
<td align="left">8号楼</td>
<td align="left">11112</td>
</tr>
<tr>
<td align="left">机电学院</td>
<td align="left">7号楼</td>
<td align="left">11113</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">学号</th>
<th align="left">姓名</th>
<th align="left">年龄</th>
<th align="left">学院</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">张三</td>
<td align="left">20</td>
<td align="left">计算机学院</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">李四</td>
<td align="left">20</td>
<td align="left">计算机学院</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">王五</td>
<td align="left">20</td>
<td align="left">计算机学院</td>
</tr>
</tbody></table>
<p>文章参考：<br><a href="https://zhuanlan.zhihu.com/p/72197799" target="_blank" rel="noopener">MySQL数据库三范式</a></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Life is simple, i learn Python</title>
    <url>/2020/05/05/Life-is-simple-i-learn-Python/</url>
    <content><![CDATA[<p><a href="https://www.readwithu.com/Article/PythonBasis/python2/Variable.html" target="_blank" rel="noopener">草根学Python</a></p>
<p><a href="https://www.runoob.com/python3/python3-data-type.html" target="_blank" rel="noopener">菜鸟教程Python</a></p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>Number:数字<br>int:整数<br>float:浮点数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">counter = 100          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = 1000.0       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">"r00unoob"</span>     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (5/2)  <span class="comment">#除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (5//2)  <span class="comment">#整除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (0b10) <span class="comment">#二进制</span></span><br><span class="line"><span class="built_in">print</span> (0o10) <span class="comment">#八进制</span></span><br><span class="line"><span class="built_in">print</span> (0x10) <span class="comment">#十六进制</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (bin(123)) <span class="comment">#bin转二进制</span></span><br><span class="line"><span class="built_in">print</span> (int(0o10)) <span class="comment">#int转十进制</span></span><br><span class="line"><span class="built_in">print</span> (hex(0o10)) <span class="comment">#转十六进制</span></span><br><span class="line"><span class="built_in">print</span> (oct(123)) <span class="comment">#转十六进制</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>bool:布尔类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (bool(True))</span><br><span class="line"><span class="built_in">print</span> (bool(False))</span><br><span class="line"><span class="built_in">print</span> (bool(None))</span><br><span class="line"><span class="built_in">print</span> (bool(<span class="string">""</span>))</span><br><span class="line"><span class="built_in">print</span> (bool(&#123;&#125;))</span><br><span class="line"><span class="built_in">print</span> (bool([1,2,3]))</span><br></pre></td></tr></table></figure>

<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex:复数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 字符串</span></span><br><span class="line">单引号、双引号、三个单引号、三个双引号、</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"i'm hello"</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'i\'</span>m hello<span class="string">')</span></span><br><span class="line"><span class="string">print ('</span><span class="string">''</span>i<span class="string">'m </span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">mm</span></span><br><span class="line"><span class="string">nn</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h2 id="转移字符"><a href="#转移字符" class="headerlink" title="转移字符"></a>转移字符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\n  <span class="comment">#换行</span></span><br><span class="line">\r  <span class="comment">#回车</span></span><br><span class="line">\<span class="string">'  #单引号</span></span><br><span class="line"><span class="string">\t  #横向制表符</span></span><br></pre></td></tr></table></figure>



<h2 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>+<span class="string">'hello'</span>) <span class="comment">#两个字符串的拼接</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>[0])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>[-1])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>[0:3])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>[0:-3])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>[0:30])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>[3:])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hellohellohello</span><br><span class="line">h</span><br><span class="line">o</span><br><span class="line">hel</span><br><span class="line">he</span><br><span class="line">hello</span><br><span class="line">lo</span><br></pre></td></tr></table></figure>


<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> ([1,2,3,<span class="string">"hhh"</span>,False])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> ([[1,2,3,<span class="string">"hhh"</span>,False],[7,9],9])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, <span class="string">'hhh'</span>, False]</span><br><span class="line">[[1, 2, 3, <span class="string">'hhh'</span>, False], [7, 9], 9]</span><br></pre></td></tr></table></figure>

<h2 id="列表的基本操作"><a href="#列表的基本操作" class="headerlink" title="列表的基本操作"></a>列表的基本操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> ([[1,2,3,<span class="string">"hhh"</span>,False],[7,9],9])  <span class="comment">#列表的组成可以是嵌套列表</span></span><br><span class="line"></span><br><span class="line">myList =  [1,2,3,<span class="string">"hhh"</span>,False]</span><br><span class="line"><span class="built_in">print</span> (myList[3])  <span class="comment">#得到的是一个元素</span></span><br><span class="line"><span class="built_in">print</span> (myList[3:]) <span class="comment">#得到的是一个列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myList2 =  [<span class="string">'添加的元素'</span>]</span><br><span class="line"><span class="built_in">print</span>(myList+myList2)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[1, 2, 3, <span class="string">'hhh'</span>, False], [7, 9], 9]</span><br><span class="line">hhh</span><br><span class="line">[<span class="string">'hhh'</span>, False]</span><br><span class="line">[1, 2, 3, <span class="string">'hhh'</span>, False, <span class="string">'添加的元素'</span>]</span><br></pre></td></tr></table></figure>


<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, 1997, 2000)</span><br><span class="line"><span class="built_in">print</span>(tup1)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5 )</span><br><span class="line"><span class="built_in">print</span>(tup2)</span><br><span class="line">tup3 = <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>   <span class="comment">#  不需要括号也可以</span></span><br><span class="line"><span class="built_in">print</span>(tup3)</span><br><span class="line"></span><br><span class="line">tup4 = ()</span><br><span class="line"><span class="built_in">print</span>(tup4)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, 1997, 2000)</span><br><span class="line">(1, 2, 3, 4, 5)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)</span><br><span class="line">()</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</span></span><br><span class="line"></span><br><span class="line">tup1 = (50,)</span><br><span class="line"><span class="built_in">print</span>(tup1)</span><br></pre></td></tr></table></figure>

<h2 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, 1997, 2000)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5, 6, 7 )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tup1[0]: "</span>, tup1[0])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"tup2[1:5]: "</span>, tup2[1:5])</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tup1[0]:  Google</span><br><span class="line">tup2[1:5]:  (2, 3, 4, 5)</span><br></pre></td></tr></table></figure>


<h2 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h2><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">tup1 = (12, 34.56)</span><br><span class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span> (tup3)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(12, 34.56, <span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">tup = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, 1997, 2000)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (tup)</span><br><span class="line">del tup</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"删除后的元组 tup : "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print (tup)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

<p>删除之后在使用，会存在报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, 1997, 2000)</span><br><span class="line">删除后的元组 tup : </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"main.py"</span>, line 9, <span class="keyword">in</span> </span><br><span class="line">    <span class="built_in">print</span> (tup)</span><br><span class="line">NameError: name <span class="string">'tup'</span> is not defined</span><br></pre></td></tr></table></figure>
<h2 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len(tuple)</td>
<td align="center">计算元组元素个数</td>
</tr>
<tr>
<td align="center">max(tuple)</td>
<td align="center">返回元组中元素最大值</td>
</tr>
<tr>
<td align="center">min(tuple)</td>
<td align="center">返回元组中元素最小值</td>
</tr>
<tr>
<td align="center">tuple(iterable)</td>
<td align="center">将可迭代系列转换为元组</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">list1= [<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Baidu'</span>]</span><br><span class="line">tuple1=tuple(list1)</span><br><span class="line"><span class="built_in">print</span>(tuple1)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Baidu'</span>)</span><br></pre></td></tr></table></figure>


<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>d = {key1 : value1, key2 : value2 }</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Alice'</span>: <span class="string">'2341'</span>, <span class="string">'Beth'</span>: <span class="string">'9102'</span>, <span class="string">'Cecil'</span>: <span class="string">'3258'</span>&#125;</span><br><span class="line">dict1 = &#123; <span class="string">'abc'</span>: 456 &#125;</span><br><span class="line">dict2 = &#123; <span class="string">'abc'</span>: 123, 98.6: 37 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: 7, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  Runoob</span><br><span class="line">dict[<span class="string">'Age'</span>]:  7</span><br></pre></td></tr></table></figure>

<h2 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: 7, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line"> </span><br><span class="line">dict[<span class="string">'Age'</span>] = 8               <span class="comment"># 更新 Age</span></span><br><span class="line">dict[<span class="string">'School'</span>] = <span class="string">"菜鸟教程"</span>  <span class="comment"># 添加信息</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:  8</span><br><span class="line">dict[<span class="string">'School'</span>]:  菜鸟教程</span><br></pre></td></tr></table></figure>

<h2 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">dict = &#123;<span class="string">'School'</span>: <span class="string">'社会'</span>,<span class="string">'Name'</span>: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: 7, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#del dict['Name'] # 删除键 'Name'</span></span><br><span class="line"><span class="comment">#dict.clear()     # 清空字典</span></span><br><span class="line"><span class="comment">#del dict         # 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:  7</span><br><span class="line">dict[<span class="string">'School'</span>]:  社会</span><br></pre></td></tr></table></figure>

<p>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: 7&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11111Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"main.py"</span>, line 3, <span class="keyword">in</span> </span><br><span class="line">    dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Runoob'</span>, <span class="string">'Age'</span>: 7&#125;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">'list'</span></span><br></pre></td></tr></table></figure>


<p>内置函数<br>| 方法 | 描述 |<br>| :—–:| :—-: |<br>|         len(dict) | 计算字典元素个数，即键的总数 |<br>| str(dict) | 输出字典，以可打印的字符串表示 |<br>|type(variable)|返回输入的变量类型，如果变量是字典就返回字典类型|</p>
<p>内置方法<br>| 方法 | 描述 |<br>| :—–| :—-|<br>|radiansdict.clear()|删除字典内所有元素|<br>|radiansdict.copy()|返回一个字典的浅复制|<br>|radiansdict.fromkeys()|创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值|<br>|radiansdict.get(key, default=None)|返回指定键的值，如果值不在字典中返回default值|<br>|key in dict|如果键在字典dict里返回true，否则返回false|<br>|radiansdict.items()|以列表返回可遍历的(键, 值) 元组数组|<br>|radiansdict.keys()|返回一个迭代器，可以使用 list() 来转换为列表|<br>|radiansdict.setdefault(key, default=None)|和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default|<br>|radiansdict.update(dict2)|把字典dict2的键/值对更新到dict里|<br>|radiansdict.values()|返回一个迭代器，可以使用 list() 来转换为列表|<br>|pop(key[,default])|删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。|<br>|popitem()|随机返回并删除字典中的最后一对键和值|</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）是一个无序的不重复元素序列。</p>
<p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">set</span>(value)</span><br></pre></td></tr></table></figure>

<p>集合具有去重功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">basket = &#123;<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(basket)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>快速判断元素是否在集合内</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abracadabra'</span> <span class="keyword">if</span> x not <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">'alacazam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a:"</span>,a)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"集合a中包含而集合b中不包含的元素:"</span>,a - b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"集合a或b中包含的所有元素:"</span>,a | b )  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"集合a和b中都包含了的元素:"</span>,a &amp; b)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"不同时包含于a和b的元素:"</span>,a ^ b)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: &#123;<span class="string">'r'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line">集合a中包含而集合b中不包含的元素: &#123;<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line">集合a或b中包含的所有元素: &#123;<span class="string">'z'</span>, <span class="string">'r'</span>, <span class="string">'a'</span>, <span class="string">'l'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line">集合a和b中都包含了的元素: &#123;<span class="string">'c'</span>, <span class="string">'a'</span>&#125;</span><br><span class="line">不同时包含于a和b的元素: &#123;<span class="string">'z'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'d'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>类似列表推导式，同样集合支持集合推导式(Set comprehension)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abracadabra'</span> <span class="keyword">if</span> x not <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a:"</span>,a)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: &#123;<span class="string">'r'</span>, <span class="string">'d'</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h2><p>添加元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">thisset = <span class="built_in">set</span>((<span class="string">"Google"</span>, <span class="string">"Runoob"</span>, <span class="string">"Taobao"</span>))</span><br><span class="line">thisset.add(<span class="string">"Facebook"</span>)</span><br><span class="line"><span class="built_in">print</span>(thisset)</span><br><span class="line">thisset.update(&#123;1,3&#125;)</span><br><span class="line"><span class="built_in">print</span>(thisset)</span><br><span class="line">thisset.update([1,4],[5,6])  </span><br><span class="line"><span class="built_in">print</span>(thisset)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>, <span class="string">'Facebook'</span>&#125;</span><br><span class="line">&#123;1, <span class="string">'Taobao'</span>, 3, <span class="string">'Runoob'</span>, <span class="string">'Facebook'</span>, <span class="string">'Google'</span>&#125;</span><br><span class="line">&#123;1, <span class="string">'Taobao'</span>, 3, 4, 5, 6, <span class="string">'Runoob'</span>, <span class="string">'Facebook'</span>, <span class="string">'Google'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>移除元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thisset.remove(<span class="string">"Taobao"</span>) <span class="comment"># 不存在会发生错误</span></span><br><span class="line"></span><br><span class="line">thisset.discard(<span class="string">"Taobao"</span>) <span class="comment">#不存在不会发生错误</span></span><br><span class="line"></span><br><span class="line">// pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除</span><br><span class="line">thisset.pop() <span class="comment">#随机删除集合中的一个元素</span></span><br></pre></td></tr></table></figure>


<p>计算集合元素个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">len(thisset)</span><br></pre></td></tr></table></figure>

<p>清空集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thisset.clear()</span><br></pre></td></tr></table></figure>

<p>判断元素是否在集合中存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"Runoob"</span> <span class="keyword">in</span> thisset</span><br></pre></td></tr></table></figure>

<p>集合内置方法完整列表<br>| 方法    | 描述|<br>| :—–| :—-|<br>| add()    | 为集合添加元素<br>| clear()    | 移除集合中的所有元素<br>| copy()    | 拷贝一个集合<br>| difference()    | 返回多个集合的差集<br>| difference_update()    | 移除集合中的元素，该元素在指定的集合也存在。<br>| discard()    | 删除集合中指定的元素<br>| intersection()    | 返回集合的交集<br>| intersection_update()    | 返回集合的交集。<br>| isdisjoint()    | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。<br>issubset()    | 判断指定集合是否为该方法参数集合的子集。<br>issuperset()    | 判断该方法的参数集合是否为指定集合的子集<br>pop()    | 随机移除元素<br>remove()    | 移除指定元素<br>symmetric_difference()    | 返回两个集合中不重复的元素集合。<br>| symmetric_difference_update()    | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。<br>| union()    | 返回两个集合的并集<br>| update()    | 给集合添加元素</p>
<h1 id="end-关键字"><a href="#end-关键字" class="headerlink" title="end 关键字"></a>end 关键字</h1><p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Fibonacci series: 斐波纳契数列</span></span><br><span class="line"><span class="comment"># 两个元素的总和确定了下一个数</span></span><br><span class="line">a, b = 0, 1</span><br><span class="line"><span class="keyword">while</span> b &lt; 1000:</span><br><span class="line">    <span class="built_in">print</span>(b, end=<span class="string">','</span>)</span><br><span class="line">    a, b = b, a+b</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</span><br></pre></td></tr></table></figure>

<h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure>
<p>if 嵌套：可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式1:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">if</span> 表达式2:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">elif</span> 表达式3:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">elif</span> 表达式4:</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>while</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure>

<p>while 循环使用 else 语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure>

<p>for中使用了 break 语句，break 语句用于跳出当前循环体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">sites = [<span class="string">"Baidu"</span>, <span class="string">"Google"</span>,<span class="string">"Runoob"</span>,<span class="string">"Taobao"</span>]</span><br><span class="line"><span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">    <span class="keyword">if</span> site == <span class="string">"Runoob"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"菜鸟教程!"</span>)</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"循环数据 "</span> + site)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"没有循环数据!"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"完成循环!"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">循环数据 Baidu</span><br><span class="line">循环数据 Google</span><br><span class="line">菜鸟教程!</span><br><span class="line">完成循环!</span><br></pre></td></tr></table></figure>


<p>range()函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">	     <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>


<p>使用range指定区间的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(5,9) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>


<p>使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(0, 10, 3) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"负数"</span>)	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(-10, -100, -30) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">负数</span><br><span class="line">-10</span><br><span class="line">-40</span><br><span class="line">-70</span><br></pre></td></tr></table></figure>


<p>结合range()和len()函数以遍历一个序列的索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = [<span class="string">'Google'</span>, <span class="string">'Baidu'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>, <span class="string">'QQ'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">	<span class="built_in">print</span>(i, a[i])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 Google</span><br><span class="line">1 Baidu</span><br><span class="line">2 Runoob</span><br><span class="line">3 Taobao</span><br><span class="line">4 QQ</span><br></pre></td></tr></table></figure>

<p>使用range()函数来创建一个列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">myList=list(range(5))</span><br><span class="line"><span class="built_in">print</span>(myList)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h1 id="break-和-continue-语句及循环中的-else-子句"><a href="#break-和-continue-语句及循环中的-else-子句" class="headerlink" title="break 和 continue 语句及循环中的 else 子句"></a>break 和 continue 语句及循环中的 else 子句</h1><p><code>break</code> 语句可以跳出 <code>for</code> 和 <code>while</code> 的循环体。如果你从 <code>for</code> 或 <code>while</code> 循环中终止，任何对应的循环 <code>else</code> 块将不执行。</p>
<p><code>continue</code> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环</p>
<p>while 中使用 break：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">n = 5</span><br><span class="line"><span class="keyword">while</span> n &gt; 0:</span><br><span class="line">    n -= 1</span><br><span class="line">    <span class="keyword">if</span> n == 2:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'循环结束。'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">循环结束。</span><br></pre></td></tr></table></figure>

<p>while 中使用 continue：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">n = 5</span><br><span class="line"><span class="keyword">while</span> n &gt; 0:</span><br><span class="line">    n -= 1</span><br><span class="line">    <span class="keyword">if</span> n == 2:</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'循环结束。'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">循环结束。</span><br></pre></td></tr></table></figure>
<h1 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h1><p>pass 不做任何事情，一般用做占位语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"...."</span>)</span><br><span class="line">	pass  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>

<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul>
<li>迭代器是一个可以记住遍历的位置的对象。</li>
<li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li>
<li>迭代器有两个基本的方法：iter() 和 next()。</li>
</ul>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (next(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="built_in">print</span> (next(it))</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>使用for语句遍历迭代器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>

<p>使用next()遍历迭代器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">import sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    try:</span><br><span class="line">        <span class="built_in">print</span> (next(it))</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>


<h2 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h2><ul>
<li><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p>
</li>
<li><p>Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p>
</li>
<li><p><code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 StopIteration 异常标识迭代的完成。</p>
</li>
<li><p><code>__next__()</code> 方法会返回下一个迭代器对象。</p>
</li>
</ul>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">  def __iter__(self):</span><br><span class="line">    self.a = 1</span><br><span class="line">    <span class="built_in">return</span> self</span><br><span class="line"> </span><br><span class="line">  def __next__(self):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += 1</span><br><span class="line">    <span class="built_in">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(next(myiter))</span><br><span class="line"><span class="built_in">print</span>(next(myiter))</span><br><span class="line"><span class="built_in">print</span>(next(myiter))</span><br><span class="line"><span class="built_in">print</span>(next(myiter))</span><br><span class="line"><span class="built_in">print</span>(next(myiter))</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>


<h2 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h2><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">  def __iter__(self):</span><br><span class="line">    self.a = 1</span><br><span class="line">    <span class="built_in">return</span> self</span><br><span class="line"> </span><br><span class="line">  def __next__(self):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= 20:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += 1</span><br><span class="line">      <span class="built_in">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      raise StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul>
<li><p>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器（generator）。</p>
</li>
<li><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
</li>
<li><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
</li>
<li><p>调用一个生成器函数，返回的是一个迭代器对象。</p>
</li>
</ul>
<p>使用 <code>yield</code> 实现斐波那契数列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"> </span><br><span class="line">def fibonacci(n): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = 0, 1, 0</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += 1</span><br><span class="line">f = fibonacci(10) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    try:</span><br><span class="line">        <span class="built_in">print</span> (next(f), end=<span class="string">" "</span>)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>


<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>架构、技术选型、SAAS、中台、数据分析</title>
    <url>/2020/04/27/%E6%9E%B6%E6%9E%84%E3%80%81%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E3%80%81SAAS%E3%80%81%E4%B8%AD%E5%8F%B0%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h1><h2 id="SAAS"><a href="#SAAS" class="headerlink" title="SAAS"></a>SAAS</h2><p>SAAS是Software-as-a-Service（软件即服务）的简称.</p>
<ul>
<li>厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务.</li>
<li>用户不用再购买软件，而改用向提供商租用基于Web的软件，来管理企业经营活动，且无需对软件进行维护，服务提供商会全权管理和维护软件，软件厂商在向客户提供互联网应用的同时，也提供软件的离线操作和本地数据存储，让用户随时随地都可以使用其定购的软件和服务.</li>
</ul>
<h2 id="ERP"><a href="#ERP" class="headerlink" title="ERP"></a>ERP</h2><p>ERP系统是企业资源计划的简称.</p>
<ul>
<li>ERP系统主要功能：有产品采集、产品管理、分类管理、订单管理、物流管理、报表管理.</li>
<li>软件举例：进销存软件、</li>
</ul>
<h2 id="CRM"><a href="#CRM" class="headerlink" title="CRM"></a>CRM</h2><p>CRM即客户关系管理.</p>
<ul>
<li>通常所指的CRM，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统.</li>
</ul>
<h2 id="BI"><a href="#BI" class="headerlink" title="BI"></a>BI</h2><p>BI（Business Intelligence），商业智能,又称商业智能或商务智能.</p>
<ul>
<li>指用数据仓库技术、在线分析处理技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。</li>
<li>商业智能通常可以将企业中现有的数据转化为知识，帮助企业做出明智的业务经营决策的工具。</li>
</ul>
<h2 id="SAP"><a href="#SAP" class="headerlink" title="SAP"></a>SAP</h2><p>它一般指的是一家生产设计Erp系统的公司简称。</p>
<ul>
<li>SAP公司是全球最大的企业管理和协同化商务解决方案供应商、世界第三大的独立软件供应商、全球第二大云公司。</li>
</ul>
<h2 id="BPO"><a href="#BPO" class="headerlink" title="BPO"></a>BPO</h2><p>BPO(Business Process Outsourcing)商业流程委外,又称业务流程外包或经营外包.</p>
<ul>
<li>是指把特定的商业工序外派给第三方服务供应商.</li>
</ul>
<h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><p>SOA（Service-Oriented Architecture），面向服务的体系结构。</p>
<ul>
<li>SOA是一种根据业务流程（Business Process）来组织功能，并将功能封装成为可互操作的服务的软件架构。</li>
</ul>
<h1 id="大数据、数据分析"><a href="#大数据、数据分析" class="headerlink" title="大数据、数据分析"></a>大数据、数据分析</h1><p><img src="/2020/04/27/%E6%9E%B6%E6%9E%84%E3%80%81%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E3%80%81SAAS%E3%80%81%E4%B8%AD%E5%8F%B0%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%9001.jpeg" alt="数据分析01.jpeg"></p>
<p><a href="https://zhuanlan.zhihu.com/p/26545566" target="_blank" rel="noopener">一文读懂大数据平台——写给大数据开发初学者的话!</a></p>
<p>这里推荐极客时间出品的《数据分析实战45讲》<br>基础+算法+实战+数据可视化</p>
<h1 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h1><p><a href="https://zhuanlan.zhihu.com/p/81410765" target="_blank" rel="noopener">阿里中台架构</a></p>
<p>双中台<br><img src="/2020/04/27/%E6%9E%B6%E6%9E%84%E3%80%81%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E3%80%81SAAS%E3%80%81%E4%B8%AD%E5%8F%B0%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B001.jpeg" alt="说透中台01.jpeg"></p>
<p>这里推荐王健的《说透中台》</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各自的技术栈都不一样，做之前先调研：</p>
<ol>
<li><p>数据：数据分析用 python，但自己之前接触的大数据行业，像为某些机构做舆论监控的，他们用的却是Java。</p>
</li>
<li><p>接口：判断未来go语言是趋势，但看有没有具体轮子吧，Java or go ?</p>
</li>
<li><p>app： flutter作为跨平台首选毕竟以前用过rn真的不好用，但flutter在iOS上架长期会有不稳定因素（说不定哪天被拒），安卓是没问题的，或者用flutter做成模块被iOS调用进行混合开发也行。</p>
</li>
<li><p>小程序： uni-app吧，全平台小程序：微信、头条、支付宝。</p>
</li>
<li><p>web前端：vue了。</p>
</li>
</ol>
<p>资料</p>
<p><a href="https://www.processon.com/view/link/5e51378ce4b0c037b5f9d1e3#outline" target="_blank" rel="noopener">极客时间-架构实战案例解析</a></p>
<p><a href="https://www.zhihu.com/question/41359111" target="_blank" rel="noopener">SaaS ERP和传统ERP的区别在哪里？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/43216852" target="_blank" rel="noopener">Iass、Pass、SasS三种云服务区别</a></p>
<p><a href="https://github.com/weizhiqiang1995/erp-pro" target="_blank" rel="noopener">erp-pro</a></p>
<p><a href="https://studygolang.com/articles/24864" target="_blank" rel="noopener">适合SaaS的几种架构比较</a></p>
]]></content>
  </entry>
  <entry>
    <title>go-logging</title>
    <url>/2020/04/25/go-logging/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>iOS VIPER架构</title>
    <url>/2020/04/24/iOS-VIPER%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="查了一下资料"><a href="#查了一下资料" class="headerlink" title="查了一下资料"></a>查了一下资料</h1><p><code>VIPER</code> View-Interactor-Presenter-Entity-Router</p>
<p>View</p>
<ul>
<li>提供完整的视图，负责视图的组合、布局、更新</li>
<li>向Presenter提供更新视图的接口</li>
<li>将View相关的事件发送给Presenter</li>
</ul>
<p>Presenter</p>
<ul>
<li>接收并处理来自View的事件</li>
<li>向Interactor请求调用业务逻辑</li>
<li>向Interactor提供View中的数据</li>
<li>接收并处理来自Interactor的数据回调事件</li>
<li>通知View进行更新操作</li>
<li>通过Router跳转到其他View</li>
</ul>
<p>Router（路由）</p>
<ul>
<li>提供View之间的跳转功能，减少了模块间的耦合</li>
<li>初始化VIPER的各个模块</li>
</ul>
<p>Interactor（交互器）</p>
<ul>
<li>维护主要的业务逻辑功能，向Presenter提供现有的业务用例</li>
<li>维护、获取、更新Entity</li>
<li>当有业务相关的事件发生时，处理事件，并通知Presenter</li>
</ul>
<p>Entity（实体）</p>
<ul>
<li>和Model一样的数据模型</li>
</ul>
<blockquote>
<p>VIPER把MVC中的Controller进一步拆分成了Presenter、Router和Interactor。和MVP中负责业务逻辑的Presenter不同，VIPER的Presenter的主要工作是在View和Interactor之间传递事件，并管理一些View的展示逻辑，主要的业务逻辑实现代码都放在了Interactor里。Interactor的设计里提出了”用例”的概念，也就是把每一个会出现的业务流程封装好，这样可测试性会大大提高。而Router则进一步解决了不同模块之间的耦合。</p>
</blockquote>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>ok!!那就按照上面的意思来写个 demo 呗～～</p>
]]></content>
  </entry>
  <entry>
    <title>基于RBAC角色的访问控制</title>
    <url>/2020/04/22/%E5%9F%BA%E4%BA%8ERBAC%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RBAC</code>（Role-Based Access Control ）基于角色的访问控制。</p>
<p><code>casbin</code>是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型。</p>
<p><code>gorm-adapter</code>使用这个库,Casbin可以从Gorm加载政策支持的数据库或保存政策。</p>
<h1 id="理解casbin的使用"><a href="#理解casbin的使用" class="headerlink" title="理解casbin的使用"></a>理解casbin的使用</h1><p>具体可以看这篇文章：<a href="https://zupzup.org/casbin-http-role-auth/" target="_blank" rel="noopener">Basic Role-Based HTTP Authorization in Go with Casbin</a>(中文翻译为<a href="https://studygolang.com/articles/12323" target="_blank" rel="noopener">在 Go 语言中使用 casbin 实现基于角色的 HTTP 权限控制</a>)，具体<a href="https://github.com/samtake/casbin-demo" target="_blank" rel="noopener">demo</a>我也加了详细注释。</p>
<p>这里有几个需要弄懂的：</p>
<p>模型文件的配置<code>auth_model.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[request_definition]</span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line">[policy_definition]</span><br><span class="line">p = sub, obj, act</span><br><span class="line"></span><br><span class="line">[policy_effect]</span><br><span class="line">e = some(<span class="built_in">where</span> (p.eft == allow))</span><br><span class="line"></span><br><span class="line">[matchers]</span><br><span class="line">m = r.sub == p.sub &amp;&amp; keyMatch(r.obj, p.obj) &amp;&amp; (r.act == p.act || p.act == <span class="string">"*"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Model CONF 至少应包含四个部分:<code>[request_definition]</code>, <code>[policy_definition]</code>, <code>[policy_effect]</code>, <code>[matchers]</code></p>
</li>
<li><p>如果 model 使用 RBAC, 还需要添加<code>[role_definition]</code>部分。</p>
</li>
<li><p>sub, obj, act 表示经典三元组: 访问实体 (Subject)，访问资源 (Object) 和访问方法 (Action)</p>
</li>
<li><p><a href="https://casbin.org/docs/zh-CN/syntax-for-models" target="_blank" rel="noopener">更具体的可以直接看官方文档</a></p>
</li>
</ul>
<p>策略文件<code>policy.csv</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p, admin, /*, *</span><br><span class="line">p, anonymous, /login, *</span><br><span class="line">p, member, /<span class="built_in">logout</span>, *</span><br><span class="line">p, member, /member/*, *</span><br></pre></td></tr></table></figure>
<ul>
<li>admin 角色可以访问所有内容</li>
<li>member 角色可以访问以 /member/ 开头的路径和 logout 路径</li>
<li>未认证用户可以登陆</li>
</ul>
<h1 id="gorm-adapter"><a href="#gorm-adapter" class="headerlink" title="gorm-adapter"></a>gorm-adapter</h1><p>在上个个例子中，策略文件就是一个简单的 csv 文件，描述了哪些角色可以访问哪些路径等。但在实际项目中策略文件一般都会存储在数据库，这时候就用到了<a href="https://github.com/casbin/gorm-adapter" target="_blank" rel="noopener">gorm-adapter</a></p>
<p>直接看官方给出的demo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/casbin/casbin/v2"</span></span><br><span class="line">	gormadapter <span class="string">"github.com/casbin/gorm-adapter/v2"</span></span><br><span class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    //初始化一个Gorm adapter 并在Casbin enforcer中使用它:</span><br><span class="line">    //Gorm adapter会使用一个名叫casbin的MySQL数据库</span><br><span class="line">    //如果不存在，将会自动创建</span><br><span class="line">    //或者通过 gormadapter.NewAdapterByDB(gormInstance)读取一个已经存在的数据库  </span><br><span class="line"></span><br><span class="line">	a, _ := gormadapter.NewAdapter(<span class="string">"mysql"</span>, <span class="string">"mysql_username:mysql_password@tcp(127.0.0.1:3306)/"</span>)</span><br><span class="line">	e, _ := casbin.NewEnforcer(<span class="string">"examples/rbac_model.conf"</span>, a)</span><br><span class="line">	</span><br><span class="line">	// Or you can use an existing DB <span class="string">"abc"</span> like this:</span><br><span class="line">	// The adapter will use the table named <span class="string">"casbin_rule"</span>.</span><br><span class="line">	// If it doesn<span class="string">'t exist, the adapter will create it automatically.</span></span><br><span class="line"><span class="string">	// a := gormadapter.NewAdapter("mysql", "mysql_username:mysql_password@tcp(127.0.0.1:3306)/abc", true)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	e.LoadPolicy()//从数据库加载策略</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	e.Enforce("alice", "data1", "read")// 检查许可</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	// 更改策略</span></span><br><span class="line"><span class="string">	// e.AddPolicy(...)</span></span><br><span class="line"><span class="string">	// e.RemovePolicy(...)</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	e.SavePolicy()//保存策略</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>


<h1 id="实际项目举例"><a href="#实际项目举例" class="headerlink" title="实际项目举例"></a>实际项目举例</h1><p><code>rbac_model.conf</code>模型文件配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[request_definition]</span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line">[policy_definition]</span><br><span class="line">p = sub, obj, act</span><br><span class="line"></span><br><span class="line">[role_definition]</span><br><span class="line">g = _, _</span><br><span class="line"></span><br><span class="line">[policy_effect]</span><br><span class="line">e = some(<span class="built_in">where</span> (p.eft == allow))</span><br><span class="line"></span><br><span class="line">[matchers]</span><br><span class="line">m = r.sub == p.sub &amp;&amp; ParamsMatch(r.obj,p.obj) &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure>

<p><code>qmplus.sql</code>表的定义并通过sql往数据库添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> Navicat Premium Data Transfer</span><br><span class="line"></span><br><span class="line"> Source Server         : qmplus</span><br><span class="line"> Source Server Type    : MySQL</span><br><span class="line"> Source Server Version : 50644</span><br><span class="line"> Source Host           : localhost:3306</span><br><span class="line"> Source Schema         : qmplus</span><br><span class="line"></span><br><span class="line"> Target Server Type    : MySQL</span><br><span class="line"> Target Server Version : 50644</span><br><span class="line"> File Encoding         : 65001</span><br><span class="line"></span><br><span class="line"> Date: 15/04/2020 17:48:50</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure <span class="keyword">for</span> casbin_rule</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `casbin_rule`;</span><br><span class="line">CREATE TABLE `casbin_rule`  (</span><br><span class="line">  `p_type` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `v0` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `v1` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `v2` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `v3` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `v4` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `v5` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of casbin_rule</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `casbin_rule` VALUES (<span class="string">'p'</span>, <span class="string">'8881'</span>, <span class="string">'/base/login'</span>, <span class="string">'POST'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>更新Casbin规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func UpdateCasbinApi(oldPath string, newPath string, oldMethod string, newMethod string) error &#123;</span><br><span class="line">	var cs []model.CasbinModel</span><br><span class="line">	err := global.GVA_DB.Table(<span class="string">"casbin_rule"</span>).Where(<span class="string">"v1 = ? AND v2 = ?"</span>, oldPath, oldMethod).Find(&amp;cs).Updates(map[string]string&#123;</span><br><span class="line">		<span class="string">"v1"</span>: newPath,</span><br><span class="line">		<span class="string">"v2"</span>: newMethod,</span><br><span class="line">	&#125;).Error</span><br><span class="line">	<span class="built_in">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>GVA_DB</code>就是全局定义的gorm.DB实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">	GVA_DB     *gorm.DB</span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>




<p>资料</p>
<p><a href="https://zhuanlan.zhihu.com/p/63769951" target="_blank" rel="noopener">RBAC用户、角色、权限、组设计方案</a><br><a href="https://casbin.org/docs/zh-CN/rbac" target="_blank" rel="noopener">casbin 基于角色的访问控制</a></p>
]]></content>
  </entry>
  <entry>
    <title>Gin JWT Middleware</title>
    <url>/2020/04/18/Gin-JWT-Middleware/</url>
    <content><![CDATA[<p>在<a href="https://samtake.github.io/2020/04/09/jwt-go/" target="_blank" rel="noopener">jwt-go</a>中我记录了手动封装一个认证中间件，然后今天在看<a href="https://github.com/wenjianzhang/go-admin" target="_blank" rel="noopener">go-admin</a>后台管理系统源码的时候发现作者用到了一个第三方库<a href="https://github.com/appleboy/gin-jwt" target="_blank" rel="noopener">gin-jwt</a>实现了同样的功能，今天就一起来看一下吧！</p>
<h1 id="gin-jwt能做什么？"><a href="#gin-jwt能做什么？" class="headerlink" title="gin-jwt能做什么？"></a>gin-jwt能做什么？</h1><ul>
<li><p><code>gin-jwt</code>是基于<code>jwt-go</code>实现的一个认证中间件，同时也是专为Gin框架实现的。</p>
</li>
<li><p><code>gin-jwt</code>提供了额外的函数功能：给登录接口生成token令牌，以及用于刷新token的函数。</p>
</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>整个框架就一个<a href="https://github.com/appleboy/gin-jwt/blob/master/auth_jwt.go" target="_blank" rel="noopener">auth_jwt.go</a>文件，共747行代码。我们从头往下看：</p>
<p>先定义了一个返回值为map类型的接口<br><code>type MapClaims map[string]interface{}</code></p>
<p>接着就是一个结构体<code>GinJWTMiddleware</code>,还记得我们在使用jwt-go的时候，也会定义一个结构体，里面存放了关于生成token的一些信息，包括：token发放时间、是谁发放的token、主题等，这里也一样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> GinJWTMiddleware struct &#123;</span><br><span class="line">	// Realm name to display to the user. Required.</span><br><span class="line">	Realm string</span><br><span class="line"></span><br><span class="line">	// 算法类型： HS256, HS384, HS512默认是 HS256.</span><br><span class="line">	SigningAlgorithm string</span><br><span class="line"></span><br><span class="line">	// 加密密钥.</span><br><span class="line">	Key []byte</span><br><span class="line"></span><br><span class="line">	// 刷新Token有效期.默认一个小时</span><br><span class="line">	MaxRefresh time.Duration</span><br><span class="line"></span><br><span class="line">	// 认证回调函数</span><br><span class="line">	Authenticator func(c *gin.Context) (interface&#123;&#125;, error)</span><br><span class="line"></span><br><span class="line">	// 通过认证后的处理函数</span><br><span class="line">	Authorizator func(data interface&#123;&#125;, c *gin.Context) bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 认证失败的回调函数</span><br><span class="line">	Unauthorized func(*gin.Context, int, string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//登录响应函数</span><br><span class="line">	LoginResponse func(*gin.Context, int, string, time.Time)</span><br><span class="line"></span><br><span class="line">	// 超时响应函数</span><br><span class="line">	LogoutResponse func(*gin.Context, int)</span><br><span class="line"></span><br><span class="line">	// 刷新响应函数</span><br><span class="line">	RefreshResponse func(*gin.Context, int, string, time.Time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数(只列了几个目前见到的)</p>
<p>登录返回token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// LoginHandler can be used by clients to get a jwt token.</span><br><span class="line">// Payload needs to be json <span class="keyword">in</span> the form of &#123;<span class="string">"username"</span>: <span class="string">"USERNAME"</span>, <span class="string">"password"</span>: <span class="string">"PASSWORD"</span>&#125;.</span><br><span class="line">// Reply will be of the form &#123;<span class="string">"token"</span>: <span class="string">"TOKEN"</span>&#125;.</span><br><span class="line">func (mw *GinJWTMiddleware) LoginHandler(c *gin.Context) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// RefreshHandler can be used to refresh a token. The token still needs to be valid on refresh.</span><br><span class="line">// Shall be put under an endpoint that is using the GinJWTMiddleware.</span><br><span class="line">// Reply will be of the form &#123;<span class="string">"token"</span>: <span class="string">"TOKEN"</span>&#125;.</span><br><span class="line">func (mw *GinJWTMiddleware) RefreshHandler(c *gin.Context) &#123;</span><br><span class="line">	tokenString, expire, err := mw.RefreshToken(c)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		mw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(err, c))</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mw.RefreshResponse(c, http.StatusOK, tokenString, expire)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证API时需要用到，例如检测权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// MiddlewareFunc makes GinJWTMiddleware implement the Middleware interface.</span><br><span class="line">func (mw *GinJWTMiddleware) MiddlewareFunc() gin.HandlerFunc &#123;</span><br><span class="line">	<span class="built_in">return</span> func(c *gin.Context) &#123;</span><br><span class="line">		mw.middlewareImpl(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="测试官方demo"><a href="#测试官方demo" class="headerlink" title="测试官方demo"></a>测试官方demo</h2><p>源码地址：<a href="https://github.com/samtake/gin-jwt-demo" target="_blank" rel="noopener">https://github.com/samtake/gin-jwt-demo</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GIN] 2020/04/18 - 18:29:51 | 200 |    1.502204ms |             ::1 | POST     <span class="string">"/login"</span></span><br><span class="line">[GIN] 2020/04/18 - 18:30:50 | 401 |     112.029µs |             ::1 | GET      <span class="string">"/auth/hello"</span></span><br><span class="line">[GIN] 2020/04/18 - 18:32:55 | 200 |     346.218µs |             ::1 | GET      <span class="string">"/auth/hello"</span></span><br></pre></td></tr></table></figure>

<p>直接请求401</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: 401,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"cookie token is empty"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录返回token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: 200,</span><br><span class="line">    <span class="string">"expire"</span>: <span class="string">"2020-04-18T19:29:51+08:00"</span>,</span><br><span class="line">    <span class="string">"token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODcyMDkzOTEsImlkIjoiYWRtaW4iLCJvcmlnX2lhdCI6MTU4NzIwNTc5MX0.o55urrL-qhUqpqEKK8k8KF8yBqrgZo_EtKmuOW1bHnc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>携带token请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"text"</span>: <span class="string">"Hello World."</span>,</span><br><span class="line">    <span class="string">"userID"</span>: <span class="string">"admin"</span>,</span><br><span class="line">    <span class="string">"userName"</span>: <span class="string">"admin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="go-admin中的使用"><a href="#go-admin中的使用" class="headerlink" title="go-admin中的使用"></a>go-admin中的使用</h2><p>这里也就记录别人在项目中是怎么使用的，以及有没有可以学习的地方。</p>
<p><code>auth.go</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package middleware</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	config2 <span class="string">"go-admin/config"</span></span><br><span class="line">	<span class="string">"go-admin/handler"</span></span><br><span class="line">	jwt <span class="string">"go-admin/pkg/jwtauth"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func AuthInit() (*jwt.GinJWTMiddleware, error) &#123;</span><br><span class="line">	<span class="built_in">return</span> jwt.New(&amp;jwt.GinJWTMiddleware&#123;</span><br><span class="line">		Realm:           <span class="string">"test zone"</span>,</span><br><span class="line">		Key:             []byte(<span class="string">"secret key"</span>),</span><br><span class="line">		Timeout:         time.Hour,</span><br><span class="line">		MaxRefresh:      time.Hour,</span><br><span class="line">		IdentityKey:     config2.ApplicationConfig.JwtSecret,</span><br><span class="line">		PayloadFunc:     handler.PayloadFunc,</span><br><span class="line">		IdentityHandler: handler.IdentityHandler,</span><br><span class="line">		Authenticator:   handler.Authenticator,</span><br><span class="line">		Authorizator:    handler.Authorizator,</span><br><span class="line">		Unauthorized:    handler.Unauthorized,</span><br><span class="line">		TokenLookup:     <span class="string">"header: Authorization, query: token, cookie: jwt"</span>,</span><br><span class="line">		TokenHeadName:   <span class="string">"Bearer"</span>,</span><br><span class="line">		TimeFunc:        time.Now,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>permission.go</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package middleware</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"go-admin/pkg"</span></span><br><span class="line">	mycasbin <span class="string">"go-admin/pkg/casbin"</span></span><br><span class="line">	<span class="string">"go-admin/pkg/jwtauth"</span></span><br><span class="line">	_ <span class="string">"go-admin/pkg/jwtauth"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//权限检查中间件</span><br><span class="line">func AuthCheckRole() gin.HandlerFunc &#123;</span><br><span class="line">	<span class="built_in">return</span> func(c *gin.Context) &#123;</span><br><span class="line">		data, _ := c.Get(<span class="string">"JWT_PAYLOAD"</span>)</span><br><span class="line">		v := data.(jwtauth.MapClaims)</span><br><span class="line">		e, err := mycasbin.Casbin()</span><br><span class="line">		pkg.HasError(err,<span class="string">""</span>,500)</span><br><span class="line">		//检查权限</span><br><span class="line">		res, err := e.Enforce(v[<span class="string">"rolekey"</span>], c.Request.URL.Path, c.Request.Method)</span><br><span class="line">		log.Println(<span class="string">"----------------"</span>, v[<span class="string">"rolekey"</span>], c.Request.URL.Path, c.Request.Method)</span><br><span class="line"></span><br><span class="line">			pkg.HasError(err,<span class="string">""</span>,500)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> res &#123;</span><br><span class="line">			c.Next()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">"status"</span>: 401,</span><br><span class="line">				<span class="string">"msg"</span>:    <span class="string">"对不起，您没有该接口访问权限，请联系管理员"</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>router.go</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func InitRouter() *gin.Engine &#123;</span><br><span class="line"></span><br><span class="line">	// the jwt middleware</span><br><span class="line">	authMiddleware, err := middleware.AuthInit()//初始化</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		_ = fmt.Errorf(<span class="string">"JWT Error"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">"/login"</span>, authMiddleware.LoginHandler)  //框架自带</span><br><span class="line"></span><br><span class="line">	// Refresh time can be longer than token timeout</span><br><span class="line">	r.GET(<span class="string">"/refresh_token"</span>, authMiddleware.RefreshHandler)//框架自带</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    apiv1 := r.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		apiv1.GET(<span class="string">"/monitor/server"</span>, monitor.ServerInfo)</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    auth := r.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">	auth.Use(authMiddleware.MiddlewareFunc()).Use(middleware.AuthCheckRole())//检测权限</span><br><span class="line">	&#123;</span><br><span class="line">		auth.GET(<span class="string">"/deptList"</span>, system.GetDeptList)</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>写到最后发现这里有篇博客写的挺好的，可以看看～<br><a href="https://blog.firerain.me/article/18" target="_blank" rel="noopener">https://blog.firerain.me/article/18</a></p>
<p>.end</p>
]]></content>
  </entry>
  <entry>
    <title>Golang调用shell脚本</title>
    <url>/2020/04/17/Golang%E8%B0%83%E7%94%A8shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在用一些工具处理文件的时候，批量手动操作真会累死人，时间成本不划算，想着怎么用脚本做成自动化，思路大概是每个脚本处理不同的功能，也就没必要将所有功能写到一个脚本了，担心万一某个模块出了问题影响整个流程。然后其中一个功能需要调用某个网页的接口处理，想了好久，请教了下一些前辈，给出的建议就是破解接口，这时候我立刻想到了Go…大概分三步：</p>
<ul>
<li>shell调用工具拿到处理好的数据</li>
<li>再由Go实现对接口的数据请求…</li>
<li>请求回来接口之后再交由shell调用工具做最后的处理，从而完成整个模块的工作。</li>
</ul>
<p>这里记住一点：shell脚本无非就做成参数形式。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p><code>os/exec</code>包可用于从Go触发任何OS命令。 相同的可用于触发.sh文件。</p>
<p>具体函数接口参考官方文档<a href="https://pkg.go.dev/os/exec?tab=doc" target="_blank" rel="noopener">package exec </a></p>
<h1 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h1><p>首先，在同一目录中创建一个test.sh文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">your_name=<span class="string">"start test ..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br></pre></td></tr></table></figure>

<p>执行<code>chmod +x test.sh</code>，不然会因为没有执行权限报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Execute Shell:./test.sh failed with error:<span class="built_in">exit</span> status 126%</span><br></pre></td></tr></table></figure>


<p>调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">command</span> := `./test.sh .`</span><br><span class="line">	cmd := exec.Command(<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="built_in">command</span>)</span><br><span class="line"></span><br><span class="line">	output, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Execute Shell:%s failed with error:%s"</span>, <span class="built_in">command</span>, err.Error())</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"Execute Shell:%s finished with output:\n%s"</span>, <span class="built_in">command</span>, string(output))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Execute Shell:./test.sh . finished with output:</span><br><span class="line">start <span class="built_in">test</span> ...</span><br></pre></td></tr></table></figure>

<p><a href="https://golangbyexample.com//" target="_blank" rel="noopener">https://golangbyexample.com//</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>E-R图</title>
    <url>/2020/04/12/E-R%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>E-R图也称实体-联系图(Entity Relationship Diagram)，也就是概念模型，可以用来做数据库设计。今天先记录下该怎么看E-R图，至于软件的操作下次补充记录～</p>
<p>作图工具在Mac端可以用<a href="https://dbeaver.io/download/" target="_blank" rel="noopener">dbeaver</a>,原因呢主要是免费吧。</p>
<p>然后说说今天我为什么怎么就扯到了E-R图呢？是我在撸一个golang项目的时候，发觉对后台数据库不知道怎么设计，然后就查了下资料，如何设计也算说的很明了，对应的关系就是用E-R图来画的。</p>
<h1 id="如何看图"><a href="#如何看图" class="headerlink" title="如何看图"></a>如何看图</h1><p><img src="/2020/04/12/E-R%E5%9B%BE/ER01.png" alt="ER01.png"></p>
<p>上面👆概念数据模型中包含了：权限、角色、用户、文章、栏目、评论和两个桥表，其中1对1或1对多等关系在模型中体现。其中：</p>
<ul>
<li><code>PK</code>primary key</li>
<li><code>箭头</code>代表的是关联关系</li>
<li><code>虚线</code>代表的是备注说明</li>
</ul>
<p>具体举例（红框部分）：<br><img src="/2020/04/12/E-R%E5%9B%BE/ER02.png" alt="ER02.png"></p>
<ul>
<li>用户角色表(cms_user_role) 同时属于用户表(cms_user)和角色表(cms_role)</li>
<li>说白了，就是一个用户会有多个角色</li>
</ul>
<p><img src="/2020/04/12/E-R%E5%9B%BE/%E7%94%A8%E4%BE%8B01.png" alt="用例01.png"><br>读者可以进行阅读、注册、登录等操作。登录状态下又可以进行评论与阅读操作。</p>
<p><img src="/2020/04/12/E-R%E5%9B%BE/%E7%94%A8%E4%BE%8B02.png" alt="用例02.png"><br>小编是作者身份，可以对自己的文章进行管理。</p>
<p><img src="/2020/04/12/E-R%E5%9B%BE/%E7%94%A8%E4%BE%8B03.png" alt="用例03.png"><br>超级管理员拥有系统最大权限(或者所有权限)，可以进行栏目管理、文章管理（文章管理隐式的包含了拥有阅读权限）、权限管理、角色管理、评论审核等操作。可对文章进行审核，权限管理下可对角色进行管理。</p>
<h1 id="gorm的实现"><a href="#gorm的实现" class="headerlink" title="gorm的实现"></a>gorm的实现</h1><p>gorm文档中，我们可以找到对模型建立关系的的文档：<a href="https://gorm.io/zh_CN/docs/belongs_to.html" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/belongs_to.html</a></p>
<p>依旧以<code>cms_user_role</code>  <code>cms_user</code> <code>cms_role</code> 这三个表为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//在gorm中，模型的结构以驼峰命名方式书写，在数据表会自动转成对应下划线</span><br><span class="line"></span><br><span class="line">//CmsUserRole .</span><br><span class="line"><span class="built_in">type</span> CmsUserRole struct &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	ID     string `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"id"</span>`</span><br><span class="line">	UserID string `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"user_id"</span>`</span><br><span class="line">	RoleID string `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"role_id"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CmsUser .</span><br><span class="line"><span class="built_in">type</span> CmsUser struct &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	ID       string `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"id"</span>`</span><br><span class="line">	UserName string `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"username"</span>`</span><br><span class="line">	Password string `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"password"</span>`</span><br><span class="line">	CmsUserRole CmsUserRole `gorm:<span class="string">"foreignkey:CmsUserRoleRefer"</span>` // 将 CmsUserRoleRefer 作为外键</span><br><span class="line">	CmsUserRoleRefer uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CmsRole .</span><br><span class="line"><span class="built_in">type</span> CmsRole struct &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	ID          string      `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"id"</span>`</span><br><span class="line">	Name        string      `gorm:<span class="string">"type:varchar(100);not null"</span>json:<span class="string">"name"</span>`</span><br><span class="line">	CmsUserRole CmsUserRole `gorm:<span class="string">"foreignkey:CmsUserRoleRefer"</span>` // 将 CmsUserRoleRefer 作为外键</span><br><span class="line">	CmsUserRoleRefer uint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这，你也会发觉用户角色表其实是个中间件。</p>
<h1 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h1><p><a href="https://blog.csdn.net/qq_41306364/article/details/103135904" target="_blank" rel="noopener">【管理系统课程设计】美少女手把手教你后台管理</a><br><a href="https://www.zhihu.com/question/19973018" target="_blank" rel="noopener">在mac上有没有类似PowerDesigner的软件？</a><br><a href="https://www.bilibili.com/video/BV1X7411L7kc?from=search&seid=1650702711585721122" target="_blank" rel="noopener">第1节：7分钟上手ER图</a><br><a href="https://zhuanlan.zhihu.com/p/50448125" target="_blank" rel="noopener">通俗数据库设计（2）E-R图</a><br><a href="https://www.zhihu.com/question/20680795/answer/91850640" target="_blank" rel="noopener">如何使用 MySQL workbench 生成 EER 图？</a><br><a href="https://www.zhihu.com/topic/19630983/top-answers" target="_blank" rel="noopener">E-R图专栏</a><br><a href="https://www.bilibili.com/video/BV1dE411q7Xf?from=search&seid=12985731220509939471" target="_blank" rel="noopener">visio-数据库模型图</a></p>
]]></content>
  </entry>
  <entry>
    <title>通过viper读取项目配置文件</title>
    <url>/2020/04/10/%E9%80%9A%E8%BF%87viper%E8%AF%BB%E5%8F%96%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a></p>
<p>在项目中创建一个<code>config</code>文件夹，新建一个<code>application.yml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8099</span><br><span class="line">datasource:</span><br><span class="line">  driverName: mysql</span><br><span class="line">  host: 127.0.0.1</span><br><span class="line">  port: 3306</span><br><span class="line">  database: gin_vue_bs</span><br><span class="line">  username: root</span><br><span class="line">  password: 123456</span><br><span class="line">  charset: utf8</span><br></pre></td></tr></table></figure>

<p>初始化配置文件,要在初始化数据库之前调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//InitConfig 初始化配置文件.</span><br><span class="line">func <span class="function"><span class="title">InitConfig</span></span>() &#123;</span><br><span class="line">	workDir, _ := os.Getwd()                 //工程项目目录</span><br><span class="line">	viper.SetConfigName(<span class="string">"application"</span>)       //配置文件名</span><br><span class="line">	viper.SetConfigType(<span class="string">"yml"</span>)               //配置文件类型</span><br><span class="line">	viper.AddConfigPath(workDir + <span class="string">"/config"</span>) //配置文件目录</span><br><span class="line">	err := viper.ReadInConfig()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//InitDB .</span><br><span class="line">func InitDB() *gorm.DB &#123;</span><br><span class="line">	driverName := viper.GetString(<span class="string">"datasource.driverName"</span>)</span><br><span class="line">	host := viper.GetString(<span class="string">"datasource.host"</span>)</span><br><span class="line">	port := viper.GetString(<span class="string">"datasource.port"</span>)</span><br><span class="line">	database := viper.GetString(<span class="string">"datasource.database"</span>)</span><br><span class="line">	username := viper.GetString(<span class="string">"datasource.username"</span>)</span><br><span class="line">	passwoed := viper.GetString(<span class="string">"datasource.password"</span>)</span><br><span class="line">	charset := <span class="string">"utf8"</span></span><br><span class="line">	args := fmt.Sprintf(<span class="string">"%s:%s@tcp(%s:%s)/%s?charset=%s&amp;parseTime=true"</span>,</span><br><span class="line">		username,</span><br><span class="line">		passwoed,</span><br><span class="line">		host,</span><br><span class="line">		port,</span><br><span class="line">		database,</span><br><span class="line">		charset)</span><br><span class="line"></span><br><span class="line">	db, err := gorm.Open(driverName, args)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(<span class="string">"failed to connect database,err"</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//创建数据表</span><br><span class="line">	db.AutoMigrate(&amp;model.User&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	DB = db</span><br><span class="line">	<span class="built_in">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>dto与dao</title>
    <url>/2020/04/10/dto%E4%B8%8Edao/</url>
    <content><![CDATA[<h1 id="dto"><a href="#dto" class="headerlink" title="dto"></a>dto</h1><p><code>dto</code>数据传输对象(Data Transfer Object)，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。</p>
<p>在golang中目前我遇到是用于控制返回的字段，如：在User中由多个字段，我希望只返回<code>Name</code>和<code>Telephone</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package dto</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"gin_vue_bs/model"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//UserDto .</span><br><span class="line"><span class="built_in">type</span> UserDto struct &#123;</span><br><span class="line">	Name      string `json:<span class="string">"name"</span>`</span><br><span class="line">	Telephone string `json:<span class="string">"telephone"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ToUserDto .</span><br><span class="line">func ToUserDto(user model.User) UserDto &#123;</span><br><span class="line">	<span class="built_in">return</span> UserDto&#123;</span><br><span class="line">		Name:      user.Name,</span><br><span class="line">		Telephone: user.Telephone,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> User struct &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	Name      string `gorm:<span class="string">"type:varchar(20);not null"</span>`</span><br><span class="line">	Telephone string `gorm:<span class="string">"varchar(110;not null;unique"</span>`</span><br><span class="line">	Password  string `gorm:<span class="string">"size:255;not null"</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctx.JSON(http.StatusOK, gin.H&#123;<span class="string">"code"</span>: 200, <span class="string">"data"</span>: gin.H&#123;<span class="string">"user"</span>: dto.ToUserDto(user.(model.User))&#125;&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h1><p><a href="https://baike.sogou.com/v6708028.htm?fromTitle=dao" target="_blank" rel="noopener">dao</a>就叫它数据访问接口吧。</p>
<p>举一个例子先，例如我们比较常见的 Service 层和 DAO 层的操作，Service 处理完逻辑之后，交给 DAO 层进行持久化，或者需要调用 DAO 层从持久化中获取一些必要的数据；在测试的时候，我们很多时候不希望真的持久化或者从持久化中获取数据，那么就会对 DAO 层进行一些 Mock。</p>
<p>还有深刻的理解，相关资料：</p>
<p><a href="http://www.imooc.com/article/33236" target="_blank" rel="noopener">http://www.imooc.com/article/33236</a><br><a href="https://www.cnblogs.com/makor/p/ut-in-go-lang.html" target="_blank" rel="noopener">https://www.cnblogs.com/makor/p/ut-in-go-lang.html</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt-go</title>
    <url>/2020/04/09/jwt-go/</url>
    <content><![CDATA[<p><a href="https://github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">github</a></p>
<p><a href="https://godoc.org/github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">Documentation</a></p>
<p>引入包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get <span class="string">"github.com/dgrijalva/jwt-go"</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package common</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"gin_vue_bs/model"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/dgrijalva/jwt-go"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义 jwt 加密密钥</span><br><span class="line">var jwtKey = []byte(<span class="string">"a_secret_crect"</span>)</span><br><span class="line"></span><br><span class="line">//Claims .</span><br><span class="line"><span class="built_in">type</span> Claims struct &#123;</span><br><span class="line">	UserID uint</span><br><span class="line">	jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ReleaseToken 登录成功则调用该方法发放token.</span><br><span class="line">func ReleaseToken(user model.User) (string, error) &#123;</span><br><span class="line">	expirationTime := time.Now().Add(7 * 24 * time.Hour) //token的过期时间7天</span><br><span class="line">	claims := &amp;Claims&#123;</span><br><span class="line">		UserID: user.ID,</span><br><span class="line">		StandardClaims: jwt.StandardClaims&#123;</span><br><span class="line">			ExpiresAt: expirationTime.Unix(),</span><br><span class="line">			IssuedAt:  time.Now().Unix(), //token发放时间</span><br><span class="line">			Issuer:    <span class="string">"samtake"</span>,         //是谁发放的token</span><br><span class="line">			Subject:   <span class="string">"user token"</span>,      //主题</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">	tokenString, err := token.SignedString(jwtKey)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> tokenString, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"200"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VySUQiOjMsImV4cCI6MTU4NzA1MjA0MiwiaWF0IjoxNTg2NDQ3MjQyLCJpc3MiOiJzYW10YWtlIiwic3ViIjoidXNlciB0b2tlbiJ9.6a50w6SfsQH7XZBW7zu3_FEGFcrWHRAh2DFYTh9hbCo"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"登录成功"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所返回的token由三部分组成：协议头（token的加密协议）、 源码claims储存的信息 、（前面两部分+jwtKey）的哈希值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blogs <span class="built_in">echo</span> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  | base64 -D                                                                                                                                                         </span><br><span class="line">&#123;<span class="string">"alg"</span>:<span class="string">"HS256"</span>,<span class="string">"typ"</span>:<span class="string">"JWT"</span>&#125;%</span><br><span class="line">➜  blogs <span class="built_in">echo</span> eyJVc2VySUQiOjMsImV4cCI6MTU4NzA1MjA0MiwiaWF0IjoxNTg2NDQ3MjQyLCJpc3MiOiJzYW10YWtlIiwic3ViIjoidXNlciB0b2tlbiJ9 | base64 -D     </span><br><span class="line">&#123;<span class="string">"UserID"</span>:3,<span class="string">"exp"</span>:1587052042,<span class="string">"iat"</span>:1586447242,<span class="string">"iss"</span>:<span class="string">"samtake"</span>,<span class="string">"sub"</span>:<span class="string">"user token"</span>&#125;%</span><br><span class="line">➜  blogs <span class="built_in">echo</span> 6a50w6SfsQH7XZBW7zu3_FEGFcrWHRAh2DFYTh9hbCo  | base64 -D     </span><br><span class="line">?tä???]?V?;??Q??!?1XNa%</span><br><span class="line">➜  blogs</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>gorm</title>
    <url>/2020/04/09/gorm/</url>
    <content><![CDATA[<p><a href="https://gorm.io" target="_blank" rel="noopener">https://gorm.io</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>ORM</code>分别代表：<br>|O|R|M|<br>|:—-|:—|:—-|<br>|Object|Relational|Mapping|<br>|对象|关系|映射|<br>|程序中的对象/实例|关系型数据库|-|<br>|例如Go中的结构体实例|例如MySQL|-|</p>
<p>MySQL与 Go的对应关系：<br>数据表     &lt;-&gt;     结构体<br>数据行     &lt;-&gt;     结构体实例<br>字段     &lt;-&gt;     结构体字段    </p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/e421083458/gorm"</span> //https://gorm.io</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> User struct &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	Name      string `gorm:<span class="string">"type:varchar(20);not null"</span>`</span><br><span class="line">	Telephone string `gorm:<span class="string">"varchar(110;not null;unique"</span>`</span><br><span class="line">	Password  string `gorm:<span class="string">"size:255;not null"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	db := InitDb()</span><br><span class="line">	defer db.Close()</span><br><span class="line"></span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line">	r.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">"/api/auth/register"</span>, func(ctx *gin.Context) &#123;</span><br><span class="line">		//获取参数</span><br><span class="line">		name := ctx.PostForm(<span class="string">"name"</span>)</span><br><span class="line">		telephone := ctx.PostForm(<span class="string">"telephone"</span>)</span><br><span class="line">		password := ctx.PostForm(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">		//验证数据</span><br><span class="line">		<span class="keyword">if</span> len(telephone) != 11 &#123;</span><br><span class="line">			ctx.JSON(http.StatusServiceUnavailable,</span><br><span class="line">				gin.H&#123;<span class="string">"code"</span>: 422, <span class="string">"msg"</span>: <span class="string">"手机号必须为11为"</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> len(password) &lt; 6 &#123;</span><br><span class="line">			ctx.JSON(http.StatusUnprocessableEntity,</span><br><span class="line">				gin.H&#123;<span class="string">"code"</span>: 422, <span class="string">"msg"</span>: <span class="string">"密码不能少于6位"</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//名称如果没有传，则返回随机字符串</span><br><span class="line">		<span class="keyword">if</span> len(name) == 0 &#123;</span><br><span class="line">			name = RandomString(10)</span><br><span class="line">		&#125;</span><br><span class="line">		//判断手机号是否存在</span><br><span class="line">		<span class="keyword">if</span> isTelephoneExist(db, telephone) &#123;</span><br><span class="line">			ctx.JSON(http.StatusUnprocessableEntity,</span><br><span class="line">				gin.H&#123;<span class="string">"code"</span>: 422, <span class="string">"msg"</span>: <span class="string">"用户已经存在"</span>&#125;)</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//创建用户</span><br><span class="line">		newUser := User&#123;</span><br><span class="line">			Name:      name,</span><br><span class="line">			Telephone: telephone,</span><br><span class="line">			Password:  password,</span><br><span class="line">		&#125;</span><br><span class="line">		db.Create(&amp;newUser)</span><br><span class="line"></span><br><span class="line">		//返回结果</span><br><span class="line">		ctx.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"msg"</span>: <span class="string">"注册成功"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	panic(r.Run(<span class="string">":8099"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isTelephoneExist(db *gorm.DB, telephone string) bool &#123;</span><br><span class="line">	var user User</span><br><span class="line">	db.Where(<span class="string">"telephone = ?"</span>, telephone).First(&amp;user)</span><br><span class="line">	<span class="keyword">if</span> user.ID != 0 &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回随机字符串</span><br><span class="line">func RandomString(n int) string &#123;</span><br><span class="line">	var letters = []byte(<span class="string">"iasdhjklfhascvxnjklasdfhjkasdfklasdfhnjklasdfjklasdfjklfasdsdfjk"</span>)</span><br><span class="line">	result := make([]byte, n)</span><br><span class="line"></span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := range result &#123;</span><br><span class="line">		result[i] = letters[rand.Intn(len(letters))]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> string(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func InitDb() *gorm.DB &#123;</span><br><span class="line">	driverName := <span class="string">"mysql"</span></span><br><span class="line">	host := <span class="string">"127.0.0.1"</span></span><br><span class="line">	port := <span class="string">"3306"</span></span><br><span class="line">	database := <span class="string">"gin_vue_bs"</span></span><br><span class="line">	username := <span class="string">"root"</span></span><br><span class="line">	passwoed := <span class="string">"123456"</span></span><br><span class="line">	charset := <span class="string">"utf8"</span></span><br><span class="line">	args := fmt.Sprintf(<span class="string">"%s:%s@tcp(%s:%s)/%s?charset=%s&amp;parseTime=true"</span>,</span><br><span class="line">		username,</span><br><span class="line">		passwoed,</span><br><span class="line">		host,</span><br><span class="line">		port,</span><br><span class="line">		database,</span><br><span class="line">		charset)</span><br><span class="line"></span><br><span class="line">	db, err := gorm.Open(driverName, args)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(<span class="string">"failed to connect database,err"</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//创建数据表</span><br><span class="line">	db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/2020/04/09/gorm/gorm01.png" alt="gorm01.png"></p>
<p><img src="/2020/04/09/gorm/gorm02.png" alt="gorm02.png"></p>
<p>#</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-学习教程</title>
    <url>/2020/03/30/OpenGL-%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>世界上最好的OpenGL教程，没有之一：<a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">LearnOpenGL CN</a></p>
<p>好好努力！勤奋敲码！</p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-着色器</title>
    <url>/2020/03/28/OpenGL-%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<p>OpenGL分为两个部分：CPU上C++编写，GPU采用GLSL语言编写，后者就是着色器的编写方式。</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">float</td>
<td align="left">ieee 32 位浮点数</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">ieee 64 位浮点数</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">有符号二进制补码的 32 位整数</td>
</tr>
<tr>
<td align="left">uint</td>
<td align="left">无符号的32位整数</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">布尔值</td>
</tr>
</tbody></table>
<h1 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h1><p>所有变量都必须在声明的同时进行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int i,nums = 1500;</span><br><span class="line"><span class="built_in">float</span> force,g = -9.8;</span><br><span class="line">bool falling = <span class="literal">true</span>;</span><br><span class="line">double pi = 3.145555LF;</span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>所有其他的数值转换都需要提供显示的转换构造函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> f = 10.0;</span><br><span class="line">int ten = int(f);</span><br></pre></td></tr></table></figure>


<h1 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h1><p>GLSL的向量与矩阵类型 </p>
<table>
<thead>
<tr>
<th align="left">基本数据类型</th>
<th align="left">2D向量</th>
<th align="left">3D向量</th>
<th align="left">矩阵类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">float</td>
<td align="left">vec2</td>
<td align="left">vec3</td>
<td align="left">..</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">dvec2</td>
<td align="left">dvec3</td>
<td align="left">..</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">ivec2</td>
<td align="left">ivec3</td>
<td align="left">..</td>
</tr>
<tr>
<td align="left">uint</td>
<td align="left">uvec2</td>
<td align="left">uvec3</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">bvec2</td>
<td align="left">bvec3</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>类型声明的变量的初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vec3 velocity = vec3(0.0, 2.0, 3.0);</span><br></pre></td></tr></table></figure>


<p>类型之间的等价转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ivec3 steps = ivec3(velocity);</span><br></pre></td></tr></table></figure>


<p>向量之间的转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 减短</span></span><br><span class="line">vec4 color;</span><br><span class="line">vec3 RGB = vec3(color);//只取了color的前面三个分量R、G、B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加长</span></span><br><span class="line">vec3 white = vec3(1.0);//white = (1.0, 1.0, 1.0)</span><br><span class="line"></span><br><span class="line">vec4 translate = vec4(white, 0.5);</span><br></pre></td></tr></table></figure>


<p>注意⚠️：传入的数据将首先填充列，再填充行。</p>
<h1 id="访问向量和矩阵中的元素"><a href="#访问向量和矩阵中的元素" class="headerlink" title="访问向量和矩阵中的元素"></a>访问向量和矩阵中的元素</h1><p>向量中的各个分量可以通过名称访问：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> red = color.r;</span><br><span class="line"><span class="built_in">float</span> v_y = velocity.y;</span><br></pre></td></tr></table></figure>

<p>或者通过一个从0开始的索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> red = color[0];</span><br><span class="line"><span class="built_in">float</span> v_y = velocity[1];</span><br></pre></td></tr></table></figure>

<p>向量分量的访问符</p>
<table>
<thead>
<tr>
<th align="left">分量访问符</th>
<th align="left">符号描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(X,Y,Z,W)</td>
<td align="left">与位置相关的分量</td>
</tr>
<tr>
<td align="left">(r,g,b,a)</td>
<td align="left">与颜色相关的分量</td>
</tr>
<tr>
<td align="left">(s,t,p,q)</td>
<td align="left">与纹理坐标相关的分量</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vec3 luminance = color.rrr; <span class="comment"># 输入颜色的红色分量来设置一个亮度值</span></span><br><span class="line"></span><br><span class="line">color = colot.abgr; <span class="comment"># 反转color的每个分量</span></span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct Partical &#123;</span><br><span class="line">    <span class="built_in">float</span> lifetime;</span><br><span class="line">    vec3 position;</span><br><span class="line">    vec3 velocity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Partical p = Partical(1.0, pos, vel); <span class="comment"># pos、 vel均为vec3类型</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的声明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> coffee[3];        <span class="comment">#有三个float元素的数组</span></span><br><span class="line"><span class="built_in">float</span>[3]  coffee;       <span class="comment">#同上</span></span><br><span class="line">int indices;            <span class="comment">#为定义维数</span></span><br></pre></td></tr></table></figure>

<p>静态初始化一个数组的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> coffee[3]  = <span class="built_in">float</span>[3](2.00, 3.00, 5.23);</span><br></pre></td></tr></table></figure>
<p>操作一个数组中的所有值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i = 0; i&lt;coffee.length(); i++)&#123;</span><br><span class="line">    coffee[i] *= 2.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取列数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mat3x4 m;</span><br><span class="line">int c = m.length();         <span class="comment"># m包含的列数为3</span></span><br><span class="line">int r = m[0].length();      <span class="comment"># 第0个列向量中分量的个数为4</span></span><br></pre></td></tr></table></figure>
<h1 id="存储限制符"><a href="#存储限制符" class="headerlink" title="存储限制符"></a>存储限制符</h1><table>
<thead>
<tr>
<th align="left">类型修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const</td>
<td align="left">将一个变量定义为只读形式。如果它初始化时用的是一个编译时变量，那么它本身也会成为编译时常量</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">设置这个变量为着色器阶段的输入变量</td>
</tr>
<tr>
<td align="left">out</td>
<td align="left">设置这个变量为着色器阶段的输出变量</td>
</tr>
<tr>
<td align="left">uniform</td>
<td align="left">设置这个变量为用户应用程序传递给着色器的数据，它对于给定的图元而言是一个常量</td>
</tr>
<tr>
<td align="left">buffer</td>
<td align="left">设置应用程序共享的一块可读写的内存。这块内存也作为着色器中的存储缓存使用</td>
</tr>
<tr>
<td align="left">shared</td>
<td align="left">设置变量是本地工作组中共享的。它只能用于计算着色器中</td>
</tr>
</tbody></table>
<p>获取uniform变量的索引并且设置具体值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GLint timeLoc;                                      <span class="comment">#着色器中的uniform变量time的索引</span></span><br><span class="line">GLfloat timeValue;                                  <span class="comment">#程序运行的时间</span></span><br><span class="line">timeLoc = glGetUniformLocation(program, <span class="string">"time"</span>)     <span class="comment">#返回着色器中nuiform变量time对应的索引值</span></span><br><span class="line">glUniformlf(timeLoc, timeValue);                    <span class="comment">#设置uniform变量timeLoc的值</span></span><br></pre></td></tr></table></figure>

<h1 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h1><table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">操作符</th>
<th align="left">可用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">()</td>
<td align="left">-</td>
<td align="left">成组的操作</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><br>[]<br> <br>f()<br>  <br>.<br> <br>++、–<br></td>
<td align="left"><br>[数组、矩阵、向量]<br> <br>函数<br>  <br>结构体<br> <br>算术类型<br></td>
<td align="left"><br>数组的下标<br> <br>函数的调用、构造函数<br>  <br>访问结构体的域变量/方法<br> <br>后置递增/递减<br></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><br>++、–<br> <br>+、-<br>  <br>~<br> <br>!<br></td>
<td align="left"><br>算术类型<br> <br>算术类型<br>  <br>整型<br> <br>布尔型<br></td>
<td align="left"><br>前置递增/递减<br> <br><br>  <br><br> <br><br></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>*、/、%</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>+、-</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><code>&lt;&lt;、&gt;&gt;</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><code>&lt;、&gt;、&lt;=、&gt;=</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><code>==、!=</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><code>&amp;</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><code>^</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">`</td>
<td align="left">`</td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><code>^^</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">`</td>
<td align="left"></td>
<td align="left">`</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><code>a?b:c</code></td>
<td align="left"><br><br></td>
<td align="left"><br><br></td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><br><code>==</code><br> <br><code>+=、-=</code><br>  <br><code>*=、/=</code><br> <br><code>%=、&lt;&lt;=、&gt;&gt;=</code><br> <br>`&amp;=、^=、</td>
<td align="left">=`<br></td>
<td align="left"><br>任意<br> <br>算术类型<br>  <br>算术类型<br>  <br>整型<br> <br>整型<br></td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><code>,</code></td>
<td align="left">任意</td>
<td align="left">操作符序列</td>
</tr>
</tbody></table>
<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><h1 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h1><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">break</td>
<td align="left">终止循环体的运行，并且继续执行循环体外的内容</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">终止循环体内当前迭代过程的执行，跳转到代码块开始部分并继续执行下一次迭代的内容</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">从当前子例程返回，可以待会一个函数返回值</td>
</tr>
<tr>
<td align="left">discard</td>
<td align="left">丢弃当前的片元，终止着色器的执行。discard语句只在片元着色器中有效</td>
</tr>
</tbody></table>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> HornerEval(<span class="built_in">float</span> coffee[10], <span class="built_in">float</span> x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> HornerEval(<span class="built_in">float</span> coffee[10], <span class="built_in">float</span> x)&#123;</span><br><span class="line">    ...+</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="计算的不变性"><a href="#计算的不变性" class="headerlink" title="计算的不变性"></a>计算的不变性</h1><p>GLSL无法保证在不同的着色器中，两个完全相同的计算式会得到完全一样的结果。为了解决这个问题，需要用到<code>invariant</code>或者<code>precise</code>关键字。</p>
<h2 id="invariant"><a href="#invariant" class="headerlink" title="invariant"></a>invariant</h2><p>将一个内置的输出变量声明为<code>invariant</code>，也可以声明一个用户自定义的变量为<code>invariant</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">invariant gl_Position;</span><br><span class="line">invariant centroid out vec3 Color</span><br></pre></td></tr></table></figure>

<p>在调试过程中，可能需要将着色器中的所有可变量都设置为<code>invariant</code>。可以通过顶点着色器的预编译命令<code>pragma</code>来完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pragma STDGL invariant(all)</span></span><br></pre></td></tr></table></figure>

<h2 id="precise"><a href="#precise" class="headerlink" title="precise"></a>precise</h2><p><code>precise</code>限制符可以设置任何计算中的变量或者函数的返回值。它的作用是增加计算的可复用性</p>
<h1 id="着色器的预处理器"><a href="#着色器的预处理器" class="headerlink" title="着色器的预处理器"></a>着色器的预处理器</h1><h2 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h2><p>控制常量与宏的定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define</span></span><br><span class="line"><span class="comment">#undef</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">代码的条件编译</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#if</span></span><br><span class="line"><span class="comment">#ifdef</span></span><br><span class="line"><span class="comment">#ifndef</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#elif</span></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<p>强制比那一起将text文字内容插入到着色器的信息日志中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#error text</span></span><br></pre></td></tr></table></figure>



<p>控制编译器的选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pragma options</span></span><br></pre></td></tr></table></figure>

<p>设置编译器支持特定GLSL扩展功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#extension options</span></span><br></pre></td></tr></table></figure>

<p>设置当前使用的GLSL版本名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#version number</span></span><br></pre></td></tr></table></figure>


<p>设置诊断行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#line options</span></span><br></pre></td></tr></table></figure>

<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define NUM_ELEMENTS 10</span></span><br></pre></td></tr></table></figure>

<p>取消之前定义过的宏</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#undef LPos</span></span><br></pre></td></tr></table></figure>


<h1 id="数据快接口"><a href="#数据快接口" class="headerlink" title="数据快接口"></a>数据快接口</h1><p>着色器与应用程序之间，或者着色器个阶段之间共享的变量可以组织为变量块的形式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uniform b &#123;     //限定符可以为：uniform、<span class="keyword">in</span>、out、buffer</span><br><span class="line">    vec4 v1;    //块中的变量列表</span><br><span class="line">    vec1 v2;    //</span><br><span class="line">&#125;;              //访问匿名块成员时使用v1、v2</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uniform b &#123;     //</span><br><span class="line">    vec4 v1;    //</span><br><span class="line">    vec1 v2;    //</span><br><span class="line">&#125;name;          ////访问匿名块成员时使用name.v1、name.v2</span><br></pre></td></tr></table></figure>

<h1 id="着色器的编译"><a href="#着色器的编译" class="headerlink" title="着色器的编译"></a>着色器的编译</h1><p>创建着色器对象且通过链接生成可执行着色器程序的流程：（两部分）</p>
<p>（第一部分）对于每个着色器都会：</p>
<ul>
<li>创建一个着色器对象。</li>
<li>将着色器源代码编译为对象。</li>
<li>验证着色器的比那一是否成功。</li>
</ul>
<p>（第二部分）将多个着色器对象链接为一个着色器程序：</p>
<ul>
<li>创建一个着色器程序。</li>
<li>将着色器对象关联到着色器程序。</li>
<li>链接着色器程序。</li>
<li>判断着色器的链接过程是否成功完成。</li>
<li>使用着色器来处理顶点和片元。</li>
</ul>
<h1 id="着色器子程序"><a href="#着色器子程序" class="headerlink" title="着色器子程序"></a>着色器子程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//第一步</span><br><span class="line">subroutine vec4 LightFunc(vec4);</span><br><span class="line"></span><br><span class="line">//第二步</span><br><span class="line">subroutine (LightFunc) vec4 ambient(vec3 n) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> Materials.ambient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subroutine (LightFunc) vec4 diffuse(vec3 n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> Materials.diffuse * max(dot (normalize(n), LightVec.xyz), 0.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三步</span><br><span class="line">subroutine uniform LightFunc materialShader;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL（三）</title>
    <url>/2020/03/28/OpenGL%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>从这篇开始，我们就跟着课本源码边调试边熟悉OpenGL函数的使用了。里面涉及的C++语法后面会在《C++重温》这里作补充。拿到课本源码，我们需要通过Cmake编译出Mac上运行的Xcode程序。</p>
<blockquote>
<p>01-keypress.cpp</p>
</blockquote>
<h1 id="程序概括"><a href="#程序概括" class="headerlink" title="程序概括"></a>程序概括</h1><p>程序先执行init函数<code>void KeyPressExample::Initialize(const char * title)</code>再执行display函数<code>void KeyPressExample::Display(bool auto_redraw)</code>.</p>
<p>按下键盘会调用<code>void KeyPressExample::OnKey(int key, int scancode, int action, int mods)</code></p>
<p>程序窗口缩放<code>void KeyPressExample::Resize(int width, int height)</code></p>
<h1 id="init函数说明"><a href="#init函数说明" class="headerlink" title="init函数说明"></a>init函数说明</h1><p><code>glGenVertexArrays( NumVAOs, VAOs );</code><br>分配NumVAOs个未使用的对象名到数组VAOs中，用作顶点数组对象。再看下其数组定义：GLuint  VAOs[NumVAOs];</p>
<p><code>glBindVertexArray( VAOs[Triangles] );</code><br>VAOs[Triangles]</p>
<ul>
<li>输入的变量array非0，且为<code>glGenVertexArrays</code>所分配时，激活顶点数组对象，并直接影响对象中所保存的顶点数组状态。</li>
<li>array为0，OpenGL不再使用之前绑定的顶点数组。</li>
<li>array不是<code>glGenVertexArrays</code>所分配的，或者它已经被<code>glDeleteVertexArray</code>函数释放了，这时会产生一个无效错误。</li>
</ul>
<p><code>glGenBuffers( NumBuffers, Buffers );</code><br>分配NumBuffers个当前未使用的缓存对象名称，并保存到Buffers数组中。</p>
<p><code>glBindBuffer( GL_ARRAY_BUFFER, Buffers[ArrayBuffer] );</code></p>
<ul>
<li>如果绑定到一个已经创建的缓存对象，那么他将成为当前GL_ARRAY_BUFFER中被激活的缓存对象。</li>
<li>如果绑定的Buffers[ArrayBuffer]值为0，那么OpenGL将不再对当前GL_ARRAY_BUFFER使用任何缓存对象。</li>
</ul>
<p><code>glBufferData( GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW );</code><br>将数据载入缓存对象。</p>
<p><code>glVertexAttribPointer( vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0) );</code><br>将输入顶点着色器的数据 关联到 一个顶点属性的数组。</p>
<p><code>glEnableVertexAttribArray( vPosition );</code><br>启用顶点属性数组。</p>
<h1 id="display函数说明"><a href="#display函数说明" class="headerlink" title="display函数说明"></a>display函数说明</h1><p><code>glClear( GL_COLOR_BUFFER_BIT );</code><br>清屏。</p>
<p><code>glBindVertexArray( VAOs[Triangles] );</code></p>
<p><code>glDrawArrays( GL_TRIANGLES, 0, NumVertices );</code><br>开始绘制。</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>程序默认效果<br><img src="/2020/03/28/OpenGL%EF%BC%88%E4%B8%89%EF%BC%89/keypress1.png" alt="keypress1.png"></p>
<p>按下键盘字母M的效果<br><img src="/2020/03/28/OpenGL%EF%BC%88%E4%B8%89%EF%BC%89/keypress2.png" alt="keypress2.png"></p>
<h1 id="详细源码"><a href="#详细源码" class="headerlink" title="详细源码"></a>详细源码</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//</span><br><span class="line">//  Triangles.cpp</span><br><span class="line">//</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;vermilion.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "vgl.h"</span></span><br><span class="line"><span class="comment">#include "vapp.h"</span></span><br><span class="line"><span class="comment">#include "LoadShaders.h"</span></span><br><span class="line"></span><br><span class="line">enum VAO_IDs &#123; Triangles, NumVAOs &#125;;</span><br><span class="line">enum Buffer_IDs &#123; ArrayBuffer, NumBuffers &#125;;</span><br><span class="line">enum Attrib_IDs &#123; vPosition = 0 &#125;;</span><br><span class="line"></span><br><span class="line">GLuint  VAOs[NumVAOs];</span><br><span class="line">GLuint  Buffers[NumBuffers];</span><br><span class="line"></span><br><span class="line">const GLuint  NumVertices = 6;</span><br><span class="line"></span><br><span class="line">BEGIN_APP_DECLARATION(KeyPressExample)</span><br><span class="line">    virtual void Initialize(const char * title);</span><br><span class="line">    virtual void Display(bool auto_redraw);</span><br><span class="line">    virtual void Finalize(void);</span><br><span class="line">    virtual void Resize(int width, int height);</span><br><span class="line">    void OnKey(int key, int scancode, int action, int mods);</span><br><span class="line">END_APP_DECLARATION()</span><br><span class="line"></span><br><span class="line">DEFINE_APP(KeyPressExample, <span class="string">"Key Press Example"</span>)</span><br><span class="line">//----------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">// init</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">void KeyPressExample::Initialize(const char * title)</span><br><span class="line">&#123;</span><br><span class="line">    //typedef class VermilionApplication base</span><br><span class="line">    base::Initialize(title);</span><br><span class="line"></span><br><span class="line">    glGenVertexArrays( NumVAOs, VAOs );</span><br><span class="line">    glBindVertexArray( VAOs[Triangles] );</span><br><span class="line"></span><br><span class="line">    GLfloat  vertices[NumVertices][2] = &#123;</span><br><span class="line">        &#123; -0.90f, -0.90f &#125;, &#123;  0.85f, -0.90f &#125;, &#123; -0.90f,  0.85f &#125;,  // Triangle 1</span><br><span class="line">        &#123;  0.90f, -0.85f &#125;, &#123;  0.90f,  0.90f &#125;, &#123; -0.85f,  0.90f &#125;   // Triangle 2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    glGenBuffers( NumBuffers, Buffers );</span><br><span class="line">    glBindBuffer( GL_ARRAY_BUFFER, Buffers[ArrayBuffer] );</span><br><span class="line">    glBufferData( GL_ARRAY_BUFFER, sizeof(vertices),</span><br><span class="line">                  vertices, GL_STATIC_DRAW );</span><br><span class="line"></span><br><span class="line">    ShaderInfo  shaders[] = &#123;</span><br><span class="line">        &#123; GL_VERTEX_SHADER, <span class="string">"../media/shaders/keypress/keypress.vert"</span> &#125;,</span><br><span class="line">        &#123; GL_FRAGMENT_SHADER, <span class="string">"../media/shaders/keypress/keypress.frag"</span> &#125;,</span><br><span class="line">        &#123; GL_NONE, NULL &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    GLuint program = LoadShaders( shaders );</span><br><span class="line">    glUseProgram( program );</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer( vPosition, 2, GL_FLOAT,</span><br><span class="line">                           GL_FALSE, 0, BUFFER_OFFSET(0) );</span><br><span class="line">    glEnableVertexAttribArray( vPosition );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void KeyPressExample::OnKey(int key, int scancode, int action, int mods)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == GLFW_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        switch (key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> GLFW_KEY_M:</span><br><span class="line">                &#123;</span><br><span class="line">                    static GLenum  mode = GL_FILL;</span><br><span class="line"></span><br><span class="line">                    mode = ( mode == GL_FILL ? GL_LINE : GL_FILL );</span><br><span class="line">                    glPolygonMode( GL_FRONT_AND_BACK, mode );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    base::OnKey(key, scancode, action, mods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//----------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">// display</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">void KeyPressExample::Display(bool auto_redraw)</span><br><span class="line">&#123;</span><br><span class="line">    glClear( GL_COLOR_BUFFER_BIT );</span><br><span class="line"></span><br><span class="line">    glBindVertexArray( VAOs[Triangles] );</span><br><span class="line">    // GL_TRIANGLES并没有指定是画三角形的边沿还是内部也画，</span><br><span class="line">    glDrawArrays( GL_TRIANGLES, 0, NumVertices );</span><br><span class="line"></span><br><span class="line">    base::Display(auto_redraw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void KeyPressExample::Resize(int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(0, 0, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void KeyPressExample::Finalize(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL（二）</title>
    <url>/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在<a href="https://samtake.github.io/2020/03/27/OpenGL/" target="_blank" rel="noopener">上篇</a>我们停留在概念上的，现在动手写写代码。</p>
<p>在<a href="https://www.khronos.org/opengl/wiki/Getting_Started#macOS" target="_blank" rel="noopener">OpenGL官网</a>我们可以看到这么一段话：</p>
<blockquote>
<p>macOS<br>Unlike other platforms, where the Operating System and OpenGL implementations are often updated separately, OpenGL updates are included as part of macOS system updates. To obtain the latest OpenGL on macOS, users should upgrade to the latest OS release, which can be found at Apple.com.</p>
</blockquote>
<p>换句话来说OpenGL已经集成在我们的Mac系统中，但是我们还需要一些执行窗口任务或者处理用户输入的函数，这里需要用到的库有：</p>
<ul>
<li>GLEW</li>
<li><a href="https://www.glfw.org/docs/latest/quick_guide.html" target="_blank" rel="noopener">GLFW</a></li>
<li><a href="https://glad.dav1d.de/" target="_blank" rel="noopener">GLAD</a></li>
</ul>
<h1 id="安装GLEW、GLEW"><a href="#安装GLEW、GLEW" class="headerlink" title="安装GLEW、GLEW"></a>安装GLEW、GLEW</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blogs brew install glfw3</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Downloading https://homebrew.bintray.com/bottles/glfw-3.3.2.mojave.bottle.tar.gz</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; Pouring glfw-3.3.2.mojave.bottle.tar.gz</span><br><span class="line">🍺  /usr/<span class="built_in">local</span>/Cellar/glfw/3.3.2: 14 files, 492.8KB   <span class="comment">#安装位置</span></span><br><span class="line">➜  blogs brew install glew </span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Downloading https://homebrew.bintray.com/bottles/glew-2.1.0_1.mojave.bottle.tar.gz</span><br><span class="line">==&gt; Downloading from https://akamai.bintray.com/66/66638564b5b9d2d915b97841ef1cc117f701c7ec34707734fa1ce11919c28</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; Pouring glew-2.1.0_1.mojave.bottle.tar.gz</span><br><span class="line">🍺  /usr/<span class="built_in">local</span>/Cellar/glew/2.1.0_1: 38 files, 3MB  <span class="comment">#安装位置</span></span><br></pre></td></tr></table></figure>

<h1 id="在Xcode配置GLEW、GLEW"><a href="#在Xcode配置GLEW、GLEW" class="headerlink" title="在Xcode配置GLEW、GLEW"></a>在Xcode配置GLEW、GLEW</h1><p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/opengl2-xcode1.png" alt="opengl2-xcode1.png"></p>
<p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/opengl2-xcode2.png" alt="opengl2-xcode2.png"></p>
<p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/opengl2-xcode3.png" alt="opengl2-xcode3.png"></p>
<p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/opengl2-xcode4.png" alt="opengl2-xcode4.png"></p>
<p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/opengl2-xcode5.png" alt="opengl2-xcode5.png"></p>
<p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/opengl2-xcode6.png" alt="opengl2-xcode6.png"></p>
<p>添加两个dylib文件的方法时，没有在framework中搜索到这两个文件时，点击add other，然后点击shift+command+G进入<code>/usr/local</code>文件夹对应的安装路径找。</p>
<h1 id="下载GLAD库"><a href="#下载GLAD库" class="headerlink" title="下载GLAD库"></a>下载GLAD库</h1><p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/glad1.png" alt="glad1.png"></p>
<p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/glad2.png" alt="glad2.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cd</span> /Users/samtake/Downloads/glad </span><br><span class="line">➜  glad ls</span><br><span class="line">include src</span><br><span class="line">➜  glad <span class="built_in">alias</span> tree=<span class="string">"find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"</span></span><br><span class="line">➜  glad tree </span><br><span class="line">|____include</span><br><span class="line">| |____KHR</span><br><span class="line">| | |____khrplatform.h</span><br><span class="line">| |____glad</span><br><span class="line">| | |____glad.h</span><br><span class="line">|____src</span><br><span class="line">| |____glad.c</span><br><span class="line">➜  glad</span><br></pre></td></tr></table></figure>
<p>将include文件夹中的两个文件复制到<code>/usr/local/include</code>内，然后添加<code>glad.c</code>文件到XCode工程中.</p>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>复制源码代替原有的main.cpp文件，build一下编译通过即可。</p>
<p><img src="/2020/03/27/OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/demo.png" alt="demo.png"></p>
<p><a href="https://github.com/samtake/helloOpenGL/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" target="_blank" rel="noopener">demo源码</a></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL</title>
    <url>/2020/03/27/OpenGL/</url>
    <content><![CDATA[<p><img src="/2020/03/27/OpenGL/opengl-book.jpeg" alt="opengl-book.jpeg"></p>
<p>啃书了！这本书买了很久都没看完，也忘的差不多了。现在试着用简洁的语言记录学习过程。</p>
<h1 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL?"></a>什么是OpenGL?</h1><p>OpenGL是一种可以对图形进行访问的软件库。它的接口与硬件无关，自身不包含任何执行窗口任务或者处理用户输入的函数（这些操作我们需要系统提供的接口来实现）。</p>
<h1 id="通过OpenGL渲染图像的主要操作-详细参考：渲染管线流程"><a href="#通过OpenGL渲染图像的主要操作-详细参考：渲染管线流程" class="headerlink" title="通过OpenGL渲染图像的主要操作(详细参考：渲染管线流程)"></a>通过OpenGL渲染图像的主要操作(详细参考：渲染管线流程)</h1><ul>
<li>设置数据，构建形状</li>
<li>着色器</li>
<li>光栅栏化，产生每个片元</li>
<li>执行片元着色器</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>光栅化（rasterization）</code>将输入图元的数学描述转换为与屏幕位置对应的像素片元。<br><code>渲染（render）</code>计算机从模型创建到最终图像的过程。<br><code>像素（pixel）</code>显示器上最小的可见单元。</p>
<p><code>着色器（shader）</code>专为图形处理单元编译的一种小型程序。</p>
<ul>
<li><code>定点着色器（vertex shader）</code>处理定点数据</li>
<li><code>片元着色器</code>处理光栅化的片元数据</li>
</ul>
<p><code>渲染管线（rendering pipeline）</code>OpenGL一系列数据处理过程，并且将应用程序的数据转换到最终渲染的图像。</p>
<h1 id="渲染管线流程"><a href="#渲染管线流程" class="headerlink" title="渲染管线流程"></a>渲染管线流程</h1><p><img src="/2020/03/27/OpenGL/rendering-pipeline.jpeg" alt="rendering-pipeline.jpeg"></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（六）</title>
    <url>/2020/03/24/FFmpeg%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK"><a href="#通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK" class="headerlink" title="通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK"></a>通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK</h1><p>具体脚本链接：<a href="https://github.com/kewlbear/FFmpeg-iOS-build-script" target="_blank" rel="noopener">FFmpeg-iOS-build-script</a></p>
<ul>
<li>在FFmpeg源码的上一级目录添加<code>build-ffmpeg.sh</code>文件</li>
<li>命令行执行：<code>./build-ffmpeg.sh</code></li>
<li>如果无执行权限的话执行：<code>chmod 777 ./build-ffmpeg.sh</code></li>
<li>注意：打包上传到商店时使用的SDK只需要真机的</li>
</ul>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（五）</title>
    <url>/2020/03/24/FFmpeg%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>FFmpeg与SDL结合，实现多媒体播放器，内容有：多线程与锁， 锁与条件变量在实际中的应用，音视频同步，seek等。</p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（四）</title>
    <url>/2020/03/24/FFmpeg%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://samtake.github.io/2019/11/04/FFmpeg/" target="_blank" rel="noopener">FFmpeg-安装及基本概念</a><br><a href="https://samtake.github.io/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">FFmpeg-命令</a><br><a href="https://samtake.github.io/2020/03/23/FFmpeg%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="noopener">通过 C语言 操作FFmpeg对多媒体文件的处理</a></p>
<h1 id="SDL简介"><a href="#SDL简介" class="headerlink" title="SDL简介"></a>SDL简介</h1><p><a href="http://libsdl.org/download-2.0.php" target="_blank" rel="noopener">SDL</a>可以对音视频进行渲染，这里主要部分有：安装SDL、使用SDL的基本步骤、SDL窗口渲染、SDL事件处理、SDL纹理渲染。</p>
<h1 id="安装SDL"><a href="#安装SDL" class="headerlink" title="安装SDL"></a>安装SDL</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ brew info SDl2</span><br><span class="line">➜  ~ brew info SDl2</span><br><span class="line">SDl2: stable 2.0.10 (bottled), HEAD</span><br><span class="line">Low-level access to audio, keyboard, mouse, joystick, and graphics</span><br><span class="line">https://www.libsdl.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/SDl2/2.0.10 (87 files, 4.6MB)</span><br><span class="line">  Poured from bottle on 2020-03-24 at 14:13:57</span><br><span class="line">From: git://mirrors.ustc.edu.cn/homebrew-core.git//Formula/sdl2.rb</span><br><span class="line">==&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">	Install HEAD version</span><br></pre></td></tr></table></figure>


<h1 id="使用SDL的基本步骤"><a href="#使用SDL的基本步骤" class="headerlink" title="使用SDL的基本步骤"></a>使用SDL的基本步骤</h1><h1 id="SDL窗口渲染"><a href="#SDL窗口渲染" class="headerlink" title="SDL窗口渲染"></a>SDL窗口渲染</h1><h1 id="SDL事件处理"><a href="#SDL事件处理" class="headerlink" title="SDL事件处理"></a>SDL事件处理</h1><h1 id="SDL彻底理解纹理渲染"><a href="#SDL彻底理解纹理渲染" class="headerlink" title="SDL彻底理解纹理渲染"></a>SDL彻底理解纹理渲染</h1>]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（三）</title>
    <url>/2020/03/23/FFmpeg%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://samtake.github.io/2019/11/04/FFmpeg/" target="_blank" rel="noopener">FFmpeg-安装及基本概念</a><br><a href="https://samtake.github.io/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">FFmpeg-命令</a><br><a href="https://github.com/samtake/FFmpeg-demo" target="_blank" rel="noopener">FFmpeg-demo源码地址</a><br>这里记录通过 C语言 操作FFmpeg对多媒体文件的处理</p>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>常用日志级别（级别由高到底排列）<br>1.AV_LOFG_ERROR<br>2.AV_LOG_WARNING<br>3.AV_LOG_INFO</p>
<p>启用步骤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include &lt;libavutil/log.h&gt;</span><br><span class="line">av_log_set_level(AV_LOG_DEBUG) <span class="comment">#只有该级别以及该级别之上的日志才会打印</span></span><br><span class="line">av_log(NULL,AV_LOG_INFO,<span class="string">"hello world:%s\n"</span>,<span class="string">"op"</span> )</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) clang -g -o ffmpeg_log ffmpeg_log.c -lavutil</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./ffmpeg_log</span><br><span class="line">hello world!</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗</span><br></pre></td></tr></table></figure>


<h1 id="文件的删除-amp-重命名"><a href="#文件的删除-amp-重命名" class="headerlink" title="文件的删除&amp;重命名"></a>文件的删除&amp;重命名</h1><p><code>avpriv_io_move(&quot;111.txt&quot;,&quot;222.txt&quot;);</code>重命名<br><code>avpriv_io_delete(&quot;./mytestfile.txt&quot;);</code>删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ pkg-config --libs libavformat  <span class="comment">#这一命令的作用时：在系统中寻找到libavformat库所在的位置</span></span><br><span class="line">-L/usr/<span class="built_in">local</span>/Cellar/ffmpeg/4.2.2_2/lib -lavformat</span><br></pre></td></tr></table></figure>

<h1 id="操作目录"><a href="#操作目录" class="headerlink" title="操作目录"></a>操作目录</h1><p><code>avio_open_dir</code><br><code>avio_read_dir</code><br><code>avio_free_directory_entry</code><br><code>avio_close_dir</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">av_log(NULL, AV_LOG_INFO, <span class="string">"%12"</span>PRId64<span class="string">"%s \n"</span>,entry-&gt;size,entry-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="comment"># PRId64 是ffmpeg里面定义的一个宏，ffmpeg里面读取的文件也是64位的。</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil`</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./list</span><br><span class="line">         186ffmpeg_log.c </span><br><span class="line">        2442build_ffmpeg_for_android.sh </span><br><span class="line">        4433list.c </span><br><span class="line">         818ffmpeg_list.c </span><br><span class="line">          96list.dSYM </span><br><span class="line">          96ffmpeg_del.dSYM </span><br><span class="line">        5209encode_audio.c </span><br><span class="line">        1051read_file.c </span><br><span class="line">       11151extr_video.c </span><br><span class="line">       11027avmerge.c </span><br><span class="line">        9532decode_video.c </span><br><span class="line">        5747cutvideo.c </span><br><span class="line">        8760ffmpeg_del </span><br><span class="line">        4265encode_video.c </span><br><span class="line">        8760ffmpeg_log </span><br><span class="line">        6500extr_audio.c </span><br><span class="line">        9380list </span><br><span class="line">          96android </span><br><span class="line">        1073mediainfo.c </span><br><span class="line">        7020decode_audio.c </span><br><span class="line">         541ffmpeg_file.c </span><br><span class="line">        5132remuxing.c </span><br><span class="line">         448.git </span><br><span class="line">          96ffmpeg_log.dSYM </span><br><span class="line">         803write_file.c </span><br><span class="line">        5066extra_audio_ffapi.c </span><br><span class="line">         288player</span><br></pre></td></tr></table></figure>

<h1 id="打印音视频meta信息"><a href="#打印音视频meta信息" class="headerlink" title="打印音视频meta信息"></a>打印音视频meta信息</h1><p><code>av_register_all</code><br><code>avformat_open_input</code><br><code>av_dump_format(fmt_ctx, 0, &quot;./test.mp4&quot;, 0/**输入信息*/);</code></p>
<p>输入信息 填0<br>输入信息 填1</p>
<p><code>avformat_close_input</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o mediainfo mediainfo.c `pkg-config --libs libavutil libavformat`</span><br><span class="line">mediainfo.c:17:5: warning: <span class="string">'av_register_all'</span> is deprecated [-Wdeprecated-declarations]</span><br><span class="line">    av_register_all();</span><br><span class="line">    ^</span><br><span class="line">/usr/<span class="built_in">local</span>/include/libavformat/avformat.h:2049:1: note: <span class="string">'av_register_all'</span> has been explicitly marked deprecated here</span><br><span class="line">attribute_deprecated</span><br><span class="line">^</span><br><span class="line">/usr/<span class="built_in">local</span>/include/libavutil/attributes.h:94:49: note: expanded from macro <span class="string">'attribute_deprecated'</span></span><br><span class="line"><span class="comment">#    define attribute_deprecated __attribute__((deprecated))</span></span><br><span class="line">                                                ^</span><br><span class="line">1 warning generated.</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./mediainfo</span><br><span class="line">Input <span class="comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from './test.mp4':</span></span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : mp42</span><br><span class="line">    minor_version   : 0</span><br><span class="line">    compatible_brands: isommp42</span><br><span class="line">    creation_time   : 2020-03-19T07:15:55.000000Z</span><br><span class="line">  Duration: 00:00:55.51, start: 0.000000, bitrate: 8422 kb/s</span><br><span class="line">    Stream <span class="comment">#0:0(eng): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 380 kb/s (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2020-03-19T07:15:55.000000Z</span><br><span class="line">      handler_name    : Mainconcept MP4 Sound Media Handler</span><br><span class="line">    Stream <span class="comment">#0:1(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 1280x720 [SAR 1:1 DAR 16:9], 8040 kb/s, 50 fps, 50 tbr, 50k tbn, 100 tbc (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2020-03-19T07:15:55.000000Z</span><br><span class="line">      handler_name    : Mainconcept MP4 Video Media Handler</span><br><span class="line">      encoder         : AVC Cod</span><br></pre></td></tr></table></figure>

<h1 id="抽取多媒体中的音频数据"><a href="#抽取多媒体中的音频数据" class="headerlink" title="抽取多媒体中的音频数据"></a>抽取多媒体中的音频数据</h1><p>av_init_packet(&amp;pkt);</p>
<p>av_find_best_stream</p>
<p>av_read_frame/av_packet_unref</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o extr_audio  extr_audio.c `pkg-config --libs libavutil libavformat`</span><br><span class="line">./extr_audio  ./test.mp4  ./test.aac  </span><br><span class="line">ffplay test.aac</span><br></pre></td></tr></table></figure>

<h1 id="抽取多媒体中的H264视频数据"><a href="#抽取多媒体中的H264视频数据" class="headerlink" title="抽取多媒体中的H264视频数据"></a>抽取多媒体中的H264视频数据</h1><p>先要知道的三点：<br>1.将多媒体中的H264视频数据抽取后，它其实是由一帧一帧压缩后的视频帧组成的，如何区分这一帧一帧的视频帧呢？两种方法：</p>
<ul>
<li>在每一帧的长度前面加一个真的长度，当读取第一帧的时候先读取这一帧的长度，根据这一帧的长度在读取帧的数据长度，依次下去。。。</li>
<li>在每一帧的前面加关键字（特征码），只要遇到特征码就知道这一帧开始了，上一帧结束了。</li>
</ul>
<p>2.SPS/PPS（它只有几个字节，不会增加网络负担）<br>解码的视频参数，以及视频帧的宽高（也就是常说的视频分辨率），等等都是存在于SPS/PPS。</p>
<p>视频播放时，每次切换分辨率都要更新SPS/PPS。</p>
<p>而在视频直播时，在每个关键帧里面都会有一个SPS/PPS。</p>
<p>3.ffmpeg如何获取SPS/PPS？<br>codec-&gt;extradata</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o extr_video  extr_video.c `pkg-config --libs libavutil libavformat`</span><br><span class="line">./extr_video ./test.mp4  test.h264</span><br><span class="line">ffplay test.h264</span><br></pre></td></tr></table></figure>

<h1 id="mp4转flv"><a href="#mp4转flv" class="headerlink" title="mp4转flv"></a>mp4转flv</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">avformat_alloc_output_context2/avformat_free_context</span><br><span class="line"></span><br><span class="line">avformat_new_stream</span><br><span class="line"></span><br><span class="line">avcodec_parameters_copy</span><br><span class="line"></span><br><span class="line">avformat_write_header  <span class="comment">#头</span></span><br><span class="line"></span><br><span class="line">av_interleaved_write_frame  <span class="comment">#头数据</span></span><br><span class="line"></span><br><span class="line">av_write_trailer   <span class="comment">#尾</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o remuxing  remuxing.c `pkg-config --libs  libavformat`</span><br><span class="line">./remuxing ./test.mp4 test.flv   </span><br><span class="line">ffplay  test.flv</span><br></pre></td></tr></table></figure>

<h1 id="音视频裁剪"><a href="#音视频裁剪" class="headerlink" title="音视频裁剪"></a>音视频裁剪</h1><p>av_seek_frame</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o cutvideo  cutvideo.c `pkg-config --libs  libavformat  libavcodec`</span><br><span class="line">./cutvideo  10  20  ./test.mp4 cutvideo.mp4</span><br><span class="line">ffplay cutvideo.mp4</span><br></pre></td></tr></table></figure>


<h1 id="FFmpeg编解码概括"><a href="#FFmpeg编解码概括" class="headerlink" title="FFmpeg编解码概括"></a>FFmpeg编解码概括</h1><p>类型：</p>
<ul>
<li>H264解码</li>
<li>H264编码</li>
<li>AAC解码</li>
<li>AAC编码</li>
</ul>
<p>用到的头文件：</p>
<ul>
<li>libavcodec/avcodec.h</li>
</ul>
<p>用到的结构体：</p>
<ul>
<li>AVCodec编解码结构体</li>
<li>AVCodecContext 编解码器上下文</li>
<li>AVFrame 解码后的帧</li>
</ul>
<p>结构体内存的分配和释放API：</p>
<ul>
<li>av_frame_alloc/av_frame_free()</li>
<li>avcodec_alloc_context3()</li>
<li>avcodec_free_context()</li>
</ul>
<p>解码步骤：</p>
<ul>
<li><code>avcodec_find_decoder</code>查找解码器</li>
<li><code>avcodec_open2</code>打开解码器</li>
<li><code>avcodec_decode_video2</code>解码，得到RGB或者YUV数据</li>
</ul>
<h1 id="H264编码"><a href="#H264编码" class="headerlink" title="H264编码"></a>H264编码</h1><p>步骤：</p>
<ul>
<li><code>avcodec_find_encoder_by_name</code>查看编码器</li>
<li><code>avcodec_open2</code>设置编码参数，并打开编码器</li>
<li><code>avcodec_encode_video2</code>编码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o encode_video  encode_video.c `pkg-config --libs  libavcodec` </span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./encode_video  </span><br><span class="line">Usage: ./encode_video &lt;output file&gt; &lt;codec name&gt;</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./encode_video  encode_video.h264 libx264</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ffplay encode_video.h264</span><br></pre></td></tr></table></figure>

<h1 id="视频转图片"><a href="#视频转图片" class="headerlink" title="视频转图片"></a>视频转图片</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o decode_video  decode_video.c `pkg-config --libs  libavformat libavutil libavcodec libswscale`</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./decode_video ./test.mp4 ./</span><br></pre></td></tr></table></figure>



<h1 id="AAC编码"><a href="#AAC编码" class="headerlink" title="AAC编码"></a>AAC编码</h1><p>avcodec_encodec_audio2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o encode_audio encode_audio.c `pkg-config --libs libavcodec`</span><br><span class="line">./encode_audio encode_audio.aac</span><br><span class="line">ffplay  encode_audio.aac</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（二）</title>
    <url>/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>接着<a href="https://samtake.github.io/2019/11/04/FFmpeg/" target="_blank" rel="noopener">FFmpeg这一篇</a>，这里记录FFmpeg的命令。</p>
<h1 id="命令分成以下几类："><a href="#命令分成以下几类：" class="headerlink" title="命令分成以下几类："></a>命令分成以下几类：</h1><ul>
<li>基本信息查询命令</li>
<li>录制</li>
<li>分解/复用</li>
<li>处理原始数据</li>
<li>滤镜</li>
<li>切割与合并</li>
<li>图／视互转</li>
<li>直播相关<br>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</li>
</ul>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/ffmpeg%E6%92%AD%E6%94%BE%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="ffmpeg播放多媒体文件的流程"></p>
<p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。<br>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。<br>您可以通过使用-vn / -an / -sn / -dn选项来禁用某些默认设置。 要进行全面的手动控制，请使用-map选项，该选项禁用刚描述的默认设置。<br>下面我们就来详细介绍一下这些命令。</p>
<h1 id="基本信息查询命令"><a href="#基本信息查询命令" class="headerlink" title="基本信息查询命令"></a>基本信息查询命令</h1><h2 id="基本信息查询"><a href="#基本信息查询" class="headerlink" title="基本信息查询"></a>基本信息查询</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 ffmpeg -filters 来查询。详细参数说明如下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-version</td>
<td align="left">显示版本。</td>
</tr>
<tr>
<td align="left">-formats</td>
<td align="left">显示可用的格式（包括设备）。</td>
</tr>
<tr>
<td align="left">-demuxers</td>
<td align="left">显示可用的demuxers。</td>
</tr>
<tr>
<td align="left">-muxers</td>
<td align="left">显示可用的muxers。</td>
</tr>
<tr>
<td align="left">-devices</td>
<td align="left">显示可用的设备。</td>
</tr>
<tr>
<td align="left">-codecs</td>
<td align="left">显示libavcodec已知的所有编解码器。</td>
</tr>
<tr>
<td align="left">-decoders</td>
<td align="left">显示可用的解码器。</td>
</tr>
<tr>
<td align="left">-encoders</td>
<td align="left">显示所有可用的编码器。</td>
</tr>
<tr>
<td align="left">-bsfs</td>
<td align="left">显示可用的比特流filter。</td>
</tr>
<tr>
<td align="left">-protocols</td>
<td align="left">显示可用的协议。</td>
</tr>
<tr>
<td align="left">-filters</td>
<td align="left">显示可用的libavfilter过滤器。</td>
</tr>
<tr>
<td align="left">-pix_fmts</td>
<td align="left">显示可用的像素格式。</td>
</tr>
<tr>
<td align="left">-sample_fmts</td>
<td align="left">显示可用的采样格式。</td>
</tr>
<tr>
<td align="left">-layouts</td>
<td align="left">显示channel名称和标准channel布局。</td>
</tr>
<tr>
<td align="left">-colors</td>
<td align="left">显示识别的颜色名称。</td>
</tr>
</tbody></table>
<h2 id="命令格式与参数"><a href="#命令格式与参数" class="headerlink" title="命令格式与参数"></a>命令格式与参数</h2><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。<br>下面是 FFMPEG 的基本命令格式：<br><code>ffmpeg [global_options] {[input_file_options] -i input_url} ...</code><br>                        <code>{[output_file_options] output_url} ...</code></p>
<p><code>ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等，并写入任意数量的输出“文件”。</code></p>
<p>原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。 流的数量和/或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。<br>要引用选项中的输入文件，您必须使用它们的索引（从0开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如。 2：3是指第三个输入文件中的第四个流。<br>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p>
<h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><p>参数    说明<br><code>-f fmt（输入/输出）</code>    强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。<br><code>-i url（输入）</code>    输入文件的网址<br><code>-y（全局参数）</code>    覆盖输出文件而不询问。<br><code>-n（全局参数）</code>    不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。<br><code>-c [：stream_specifier] codec（输入/输出，每个流）</code>    选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT<br><code>-codec [：stream_specifier]编解码器（输入/输出，每个流）    同 -c</code>-t duration（输入/输出）<code>当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</code>-ss位置（输入/输出）`    当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</p>
<p><code>-frames [：stream_specifier] framecount（output，per-stream）</code>    停止在帧计数帧之后写入流。</p>
<p><code>-filter [：stream_specifier] filtergraph（output，per-stream）</code>    创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</p>
<h2 id="视频参数"><a href="#视频参数" class="headerlink" title="视频参数"></a>视频参数</h2><p>参数    说明<br><code>-vframes num（输出）</code>    设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。<br><code>-r [：stream_specifier] fps（输入/输出，每个流）</code>    设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。<br><code>-s [：stream_specifier]大小（输入/输出，每个流）</code>    设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。<br><code>-aspect [：stream_specifier] 宽高比（输出，每个流）</code>    设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。<br><code>-vn（输出）</code>    禁用视频录制。<br><code>-vcodec编解码器（输出）</code>    设置视频编解码器。这是-codec：v的别名。<br><code>-vf filtergraph（输出）</code>    创建由filtergraph指定的过滤器图，并使用它来过滤流。</p>
<h2 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h2><p>参数    说明<br><code>-aframes（输出）</code>    设置要输出的音频帧的数量。这是-frames：a的一个过时的别名。<br><code>-ar [：stream_specifier] freq（输入/输出，每个流）</code>    设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。<br><code>-ac [：stream_specifier]通道（输入/输出，每个流）</code>    设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。<br><code>-an（输出）</code>    禁用录音。<br><code>-acodec编解码器（输入/输出）</code>    设置音频编解码器。这是-codec的别名：a。<br><code>-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</code>    设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。<br><code>-af filtergraph（输出）</code>    创建由filtergraph指定的过滤器图，并使用它来过滤流。<br>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p>
<h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。<br><code>ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</code></p>
<h3 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h3><p><code>ffmpeg -f avfoundation -i 1 -r 30 out.yuv</code></p>
<ul>
<li>-f 指定使用 avfoundation 采集数据。</li>
<li>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</li>
<li>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r用于限制输出。<br>注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</li>
</ul>
<h3 id="录屏-声音"><a href="#录屏-声音" class="headerlink" title="录屏+声音"></a>录屏+声音</h3><p><code>ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</code></p>
<ul>
<li>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</li>
<li>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</li>
<li>-crf 是 x264 的参数。 0 表式无损压缩。</li>
<li>-c:a 与参数 -acodec 一样，表示音频编码器。</li>
<li>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</li>
<li>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</li>
</ul>
<h3 id="录视频"><a href="#录视频" class="headerlink" title="录视频"></a>录视频</h3><p><code>ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</code> </p>
<ul>
<li>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</li>
<li>-f 指定使用 avfoundation 采集数据。</li>
<li>-i 指定视频设备的索引号。</li>
</ul>
<h3 id="视频-音频"><a href="#视频-音频" class="headerlink" title="视频+音频"></a>视频+音频</h3><p><code>ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</code> </p>
<h3 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h3><p><code>ffmpeg -f avfoundation -i :0 out.wav</code></p>
<h3 id="录制音频裸数据"><a href="#录制音频裸数据" class="headerlink" title="录制音频裸数据"></a>录制音频裸数据</h3><p><code>ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</code></p>
<h2 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%8D%E7%94%A8.png" alt="分解与复用"></p>
<p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p>
<h3 id="抽取音频流"><a href="#抽取音频流" class="headerlink" title="抽取音频流"></a>抽取音频流</h3><p><code>ffmpeg -i input.mp4 -acodec copy -vn out.aac</code></p>
<ul>
<li>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</li>
<li>vn: v 代表视频，n 代表 no 也就是无视频的意思。</li>
</ul>
<h3 id="抽取视频流"><a href="#抽取视频流" class="headerlink" title="抽取视频流"></a>抽取视频流</h3><p><code>ffmpeg -i input.mp4 -vcodec copy -an out.h264</code></p>
<ul>
<li>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</li>
<li>an: a 代表视频，n 代表 no 也就是无音频的意思。</li>
</ul>
<h3 id="转格式"><a href="#转格式" class="headerlink" title="转格式"></a>转格式</h3><p><code>ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</code><br>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv。</p>
<h3 id="音视频合并"><a href="#音视频合并" class="headerlink" title="音视频合并"></a>音视频合并</h3><p><code>ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</code></p>
<h2 id="处理原始数据"><a href="#处理原始数据" class="headerlink" title="处理原始数据"></a>处理原始数据</h2><h3 id="提取YUV数据"><a href="#提取YUV数据" class="headerlink" title="提取YUV数据"></a>提取YUV数据</h3><p><code>ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv
ffplay -s wxh out.yuv</code></p>
<ul>
<li>-c:v rawvideo 指定将视频转成原始数据</li>
<li>-pixel_format yuv420p 指定转换格式为yuv420p</li>
</ul>
<h3 id="YUV转H264"><a href="#YUV转H264" class="headerlink" title="YUV转H264"></a>YUV转H264</h3><p><code>ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</code></p>
<h3 id="提取PCM数据"><a href="#提取PCM数据" class="headerlink" title="提取PCM数据"></a>提取PCM数据</h3><p><code>ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm
ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</code></p>
<h3 id="PCM转WAV"><a href="#PCM转WAV" class="headerlink" title="PCM转WAV"></a>PCM转WAV</h3><p><code>ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</code></p>
<h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>在编码之前，ffmpeg可以使用libavfilter库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg区分两种类型的过滤器图形：简单和复杂。</p>
<h3 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E7%AE%80%E5%8D%95%E6%BB%A4%E9%95%9C1.png" alt="简单滤镜1"></p>
<p>简单的filtergraphs配置了per-stream-filter选项（分别为视频和音频使用-vf和-af别名）。 一个简单的视频filtergraph可以看起来像这样的例子：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E7%AE%80%E5%8D%95%E6%BB%A4%E9%95%9C2.png" alt="简单滤镜2"></p>
<p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的fps过滤器会改变帧数，但不会触及帧内容。 另一个例子是setpts过滤器，它只设置时间戳，否则不改变帧。</p>
<h3 id="复杂滤镜"><a href="#复杂滤镜" class="headerlink" title="复杂滤镜"></a>复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%A4%8D%E6%9D%82%E6%BB%A4%E9%95%9C1.png" alt="复杂滤镜1.png"></p>
<p>复杂的过滤器图使用-filter_complex选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。<br>-lavfi选项等同于-filter_complex。<br>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是amix滤波器。</p>
<h3 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h3><p><code>ffmpeg -i out.mp4  -vf &quot;movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]&quot; water.mp4</code></p>
<ul>
<li>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。<h3 id="删除水印"><a href="#删除水印" class="headerlink" title="删除水印"></a>删除水印</h3>先通过 ffplay 找到要删除 LOGO 的位置<br><code>ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1</code><br>使用 delogo 滤镜删除 LOGO<br><code>ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv</code><h3 id="视频缩小一倍"><a href="#视频缩小一倍" class="headerlink" title="视频缩小一倍"></a>视频缩小一倍</h3><code>ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</code></li>
<li>vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。<h3 id="视频裁剪"><a href="#视频裁剪" class="headerlink" title="视频裁剪"></a>视频裁剪</h3><code>ffmpeg -i VR.mov  -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</code><br>crop 格式：crop=out_w:out_h:x:y</li>
<li>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</li>
<li>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</li>
<li>x : X坐标</li>
<li>y : Y坐标</li>
</ul>
<p>如果 x和y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。</p>
<h3 id="倍速播放"><a href="#倍速播放" class="headerlink" title="倍速播放"></a>倍速播放</h3><p><code>ffmpeg -i out.mp4 -filter_complex &quot;[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]&quot; -map &quot;[v]&quot; -map &quot;[a]&quot; speed2.0.mp4</code></p>
<ul>
<li>-filter_complex 复杂滤镜，[0:v]表示第一个（文件索引号是0）文件的视频作为输入。setpts=0.5*PTS表示每帧视频的pts时间戳都乘0.5 ，也就是差少一半。[v]表示输出的别名。音频同理就不详述了。</li>
<li>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</li>
</ul>
<h3 id="对称视频"><a href="#对称视频" class="headerlink" title="对称视频"></a>对称视频</h3><p><code>ffmpeg  -i out.mp4 -filter_complex &quot;[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w&quot; duicheng.mp4</code></p>
<ul>
<li>hflip 水平翻转<br>如果要修改为垂直翻转可以用vflip。<h3 id="画中画"><a href="#画中画" class="headerlink" title="画中画"></a>画中画</h3><code>ffmpeg -i out.mp4 -i out1.mp4 -filter_complex &quot;[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]&quot; -map &quot;[out]&quot; -movflags faststart new.mp4</code></li>
</ul>
<h3 id="录制画中画"><a href="#录制画中画" class="headerlink" title="录制画中画"></a>录制画中画</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation -i <span class="string">"0:0"</span></span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast </span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 </span><br><span class="line">-filter_complex <span class="string">"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]"</span> </span><br><span class="line">-map <span class="string">"[out]"</span> -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure>

<h3 id="多路视频拼接"><a href="#多路视频拼接" class="headerlink" title="多路视频拼接"></a>多路视频拼接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation   -i <span class="string">"0:0"</span> -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex <span class="string">"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart  -map 1:a  c.mp4</span><br></pre></td></tr></table></figure>

<h2 id="音视频的拼接与裁剪"><a href="#音视频的拼接与裁剪" class="headerlink" title="音视频的拼接与裁剪"></a>音视频的拼接与裁剪</h2><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p><code>ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</code></p>
<ul>
<li>-ss 指定裁剪的开始时间，精确到秒</li>
<li>-t 被裁剪后的时长。</li>
</ul>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>首先创建一个 inputs.txt 文件，文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file <span class="string">'1.flv'</span></span><br><span class="line">file <span class="string">'2.flv'</span></span><br><span class="line">file <span class="string">'3.flv'</span></span><br></pre></td></tr></table></figure>
<p>然后执行下面的命令：<br><code>ffmpeg -f concat -i inputs.txt -c copy output.flv</code></p>
<p>hls切片<br><code>ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</code></p>
<ul>
<li>-strict -2 指明音频使有AAC。</li>
<li>-f hls 转成 m3u8 格式。</li>
</ul>
<h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><h3 id="视频转JPEG"><a href="#视频转JPEG" class="headerlink" title="视频转JPEG"></a>视频转JPEG</h3><p><code>ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</code></p>
<h3 id="视频转gif"><a href="#视频转gif" class="headerlink" title="视频转gif"></a>视频转gif</h3><p><code>ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</code></p>
<h3 id="图片转视频"><a href="#图片转视频" class="headerlink" title="图片转视频"></a>图片转视频</h3><p><code>ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</code></p>
<h2 id="直播相关"><a href="#直播相关" class="headerlink" title="直播相关"></a>直播相关</h2><h3 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h3><p><code>ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</code></p>
<h3 id="拉流保存"><a href="#拉流保存" class="headerlink" title="拉流保存"></a>拉流保存</h3><p><code>ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</code></p>
<h3 id="转流"><a href="#转流" class="headerlink" title="转流"></a>转流</h3><p><code>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream</code></p>
<h3 id="实时推流"><a href="#实时推流" class="headerlink" title="实时推流"></a>实时推流</h3><p><code>ffmpeg -framerate 15 -f avfoundation -i &quot;1&quot; -s 1280x720 -c:v libx264  -f  flv rtmp://localhost:1935/live/room
ffplay</code></p>
<h3 id="播放YUV-数据"><a href="#播放YUV-数据" class="headerlink" title="播放YUV 数据"></a>播放YUV 数据</h3><p><code>ffplay -pix_fmt nv12 -s 192x144 1.yuv</code></p>
<h3 id="播放YUV中的-Y平面"><a href="#播放YUV中的-Y平面" class="headerlink" title="播放YUV中的 Y平面"></a>播放YUV中的 Y平面</h3><p><code>ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes=&#39;y&#39; 1.yuv</code></p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC（二）</title>
    <url>/2020/03/22/WebRTC%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://samtake.github.io/2019/11/04/WebRTC/" target="_blank" rel="noopener">前一篇</a>有对WebRTC以及用到的协议做了一些简单介绍。</p>
<p>先回忆下WebRTC终端的五个流程：</p>
<ul>
<li>获取权限（摄像头、麦克风）</li>
<li>本地视频的采集与展示</li>
<li>创建<code>RTCPeerConnection</code></li>
<li>媒体协商</li>
<li>远端视频的展示</li>
</ul>
<h1 id="媒体协商"><a href="#媒体协商" class="headerlink" title="媒体协商"></a>媒体协商</h1><p>在双方通信时，双方必须清楚彼此使用的编解码器是什么，也必须知道传输过来的音视频流的 SSRC。媒体协商的作用就是让双方找到共同支持的媒体能力，如双方都支持的编解码器，从而最终实现彼此之间的音视频通信。</p>
<p>步骤：</p>
<ul>
<li>创建一个 RTCPeerConnection 对象</li>
<li>createOffer ，创建 Offer；</li>
<li>createAnswer，创建 Answer；</li>
<li>setLocalDescription，设置本地 SDP 信息；</li>
<li>setRemoteDescription，设置远端的 SDP 信息。</li>
</ul>
<p>流程叙述：</p>
<p>首先，呼叫方创建 Offer 类型的 SDP 消息。创建完成后，调用 setLocalDescriptoin 方法将该 Offer 保存到本地 Local 域，然后通过信令将 Offer 发送给被呼叫方。</p>
<p>被呼叫方收到 Offer 类型的 SDP 消息后，调用 setRemoteDescription 方法将 Offer 保存到它的 Remote 域。作为应答，被呼叫方要创建 Answer 类型的 SDP 消息，Answer 消息创建成功后，再调用 setLocalDescription 方法将 Answer 类型的 SDP 消息保存到本地的 Local 域。最后，被呼叫方将 Answer 消息通过信令发送给呼叫方。至此，被呼叫方的工作就完部完成了。</p>
<p>接下来是呼叫方的收尾工作，呼叫方收到 Answer 类型的消息后，调用 RTCPeerConnecton 对象的 setRemoteDescription 方法，将 Answer 保存到它的 Remote 域。</p>
<p>至此，整个媒体协商过程处理完毕。</p>
<h1 id="WebRTC建立连接"><a href="#WebRTC建立连接" class="headerlink" title="WebRTC建立连接"></a>WebRTC建立连接</h1><p><img src="/2020/03/22/WebRTC%EF%BC%88%E4%BA%8C%EF%BC%89/1to1-connected.png" alt></p>
<p>首先会尝试 NAT 穿越，即尝试端到端直连。如果能够穿越成功，那双方就通过直连的方式传输数据，这是最高效的。但如果 NAT 穿越失败，为了保障通信双方的连通性，WebRTC 会使用中继方式，当然使用这种方式传输效率会低一些。</p>
<p>在整个过程中，WebRTC 使用优先级的方法去建立连接，即局域网内的优先级最高，其次是 NAT 穿越，再次是通过中继服务器进行中转，这样就巧妙地实现了“既要高效传输，又能保证连通率”这个目标。</p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>lightworks视频剪辑软件基本操作教程</title>
    <url>/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p><code>LOG</code>放文件内容<br><code>EDIT</code>剪辑<br><code>VFX</code>加文字等效果<br><code>AUDIO</code>添加音频</p>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><p>Project Contents<br>Local Files<br>Audio Network<br>Pond5</p>
<h2 id="EDIT"><a href="#EDIT" class="headerlink" title="EDIT"></a>EDIT</h2><p>A开头的是视频文件本身自带的音效，点一下变暗后播放就没有这个音效了</p>
<p>剪切和合并点X键，剪切后可以随意看奥运与组合，点击不要的部分点邮件删除</p>
<p>右键点击速度可变慢或加快播放速度，不要的话就点删除，跨界见CTRL+Z可以还原上一步操作</p>
<p>可覆盖原本的音频或家在下面</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/EDIT-Audio.png" alt></p>
<h2 id="VFX"><a href="#VFX" class="headerlink" title="VFX"></a>VFX</h2><p>点击+添加文字，改变字体大小和颜色</p>
<h2 id="AUDIO"><a href="#AUDIO" class="headerlink" title="AUDIO"></a>AUDIO</h2><p>音量大小等修改</p>
<p>保存文件点右键出口-媒体文件-一般是MP4/AVI 720适宜，当然越大也越清楚，文件内存也越大</p>
<h1 id="2-界面和新建工程"><a href="#2-界面和新建工程" class="headerlink" title="2.界面和新建工程"></a>2.界面和新建工程</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-setting.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-project-type.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-project-contents.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-project-contents-windows.png" alt></p>
<h1 id="3-导入素材和新建序列"><a href="#3-导入素材和新建序列" class="headerlink" title="3.导入素材和新建序列"></a>3.导入素材和新建序列</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial3-import-setting3.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial3-import-setting3.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial3-new-serial1.png" alt></p>
<p>序列之间是不能嵌套的。</p>
<h1 id="4-时间线操作-amp-选定素材区域插入时间轴"><a href="#4-时间线操作-amp-选定素材区域插入时间轴" class="headerlink" title="4.时间线操作&amp;选定素材区域插入时间轴"></a>4.时间线操作&amp;选定素材区域插入时间轴</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-operation.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-blank.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-source.png" alt></p>
<p>同时时间轴上的素材可以左右拖拉：切换位置、前后时间延长</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-source-only.png" alt></p>
<h1 id="5-时间轴素材调整-amp-音频轨道同步"><a href="#5-时间轴素材调整-amp-音频轨道同步" class="headerlink" title="5.时间轴素材调整&amp;音频轨道同步"></a>5.时间轴素材调整&amp;音频轨道同步</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-zoom.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut2.png" alt></p>
<p>键盘的加减号是放大和缩小时间轴</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2.png" alt></p>
<p><code>Slip - Y</code>点击空格键播放，选中素材的另外前后素材位置没有变化，播放时长也没有变化，而该选中素材则随着播放，时间慢慢增加。<br><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-slip.png" alt></p>
<p><code>Slide - T</code>选中素材没有变化。</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-Slide.png" alt></p>
<p><code>Trim In - W</code></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-trim-in.png" alt></p>
<p><code>Trim Out - E</code>在出点标记处进行延长或缩短</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>1.假设只对视频进行缩减时，这会导致音视频不同轨，处理方法<br><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-auto-track.png" alt></p>
<p>2.<br><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-track-operation.png" alt></p>
<p> 3.快捷键</p>
<p> <code>j</code> 倒方</p>
<p> <code>k</code> 停止 </p>
<p> <code>l</code> 素材向右播放，重复按下<code>j</code>会加速向右播放</p>
<h1 id="6-添加转场-amp-转场相关设置"><a href="#6-添加转场-amp-转场相关设置" class="headerlink" title="6.添加转场&amp;转场相关设置"></a>6.添加转场&amp;转场相关设置</h1><h2 id="添加转场步骤"><a href="#添加转场步骤" class="headerlink" title="添加转场步骤"></a>添加转场步骤</h2><p>先要通过拖动素材，让两个素材的某个部分重叠，留出转场的空间。</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-steps.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-other.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-other2.png" alt></p>
<p>音频和视频转场都是一样～～～操作差不多</p>
<h2 id="让结尾处渐暗"><a href="#让结尾处渐暗" class="headerlink" title="让结尾处渐暗"></a>让结尾处渐暗</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-black1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-black2.png" alt></p>
<h1 id="7-VFX节本操作-amp-剪辑播放速度调整"><a href="#7-VFX节本操作-amp-剪辑播放速度调整" class="headerlink" title="7.VFX节本操作&amp;剪辑播放速度调整"></a>7.VFX节本操作&amp;剪辑播放速度调整</h1><h2 id="添加字幕"><a href="#添加字幕" class="headerlink" title="添加字幕"></a>添加字幕</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial7-VFX1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial7-VFX2.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial7-VFX3.png" alt></p>
<h2 id="8-调整素材播放速度"><a href="#8-调整素材播放速度" class="headerlink" title="8.调整素材播放速度"></a>8.调整素材播放速度</h2><p>时间轴-右键-Speed-设置速度即可</p>
<h1 id="8-Routing简介-amp-应用"><a href="#8-Routing简介-amp-应用" class="headerlink" title="8.Routing简介&amp;应用"></a>8.Routing简介&amp;应用</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial8-routing.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial8-routing-use1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial8-routing-use2.png" alt></p>
<h1 id="9-音频效果窗口-amp-导出设置"><a href="#9-音频效果窗口-amp-导出设置" class="headerlink" title="9.音频效果窗口&amp;导出设置"></a>9.音频效果窗口&amp;导出设置</h1><h2 id="渐入音效"><a href="#渐入音效" class="headerlink" title="渐入音效"></a>渐入音效</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-audio1.png" alt></p>
<h2 id="让关键帧效果位置整体改变"><a href="#让关键帧效果位置整体改变" class="headerlink" title="让关键帧效果位置整体改变"></a>让关键帧效果位置整体改变</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-audio2.png" alt></p>
<h2 id="其他的修音设置"><a href="#其他的修音设置" class="headerlink" title="其他的修音设置"></a>其他的修音设置</h2><h2 id="导出设置"><a href="#导出设置" class="headerlink" title="导出设置"></a>导出设置</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-export1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-export2.jpeg" alt></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://www.bilibili.com/video/av31939070" target="_blank" rel="noopener">Lightworks 14 Tutorials 中文字幕教程</a></p>
<p><a href="https://www.lwks.com/" target="_blank" rel="noopener">Lightworks 软件官方地址</a></p>
]]></content>
      <categories>
        <category>lightworks</category>
      </categories>
      <tags>
        <tag>lightworks</tag>
      </tags>
  </entry>
  <entry>
    <title>读书记录-20200311</title>
    <url>/2020/03/11/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-20200311/</url>
    <content><![CDATA[<p><img src="/2020/03/11/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-20200311/20200311-%E4%B9%A6%E5%8D%95.jpeg" alt></p>
<p>附录</p>
<p><a href="https://www.bilibili.com/video/av3755315?from=search&seid=1211682021322553260" target="_blank" rel="noopener">100个梦想的赞助商（微电影）</a></p>
<p><a href="https://www.bilibili.com/video/av37465443?from=search&seid=14561064290056795500" target="_blank" rel="noopener">我们的时代</a></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>ant-design学习</title>
    <url>/2020/03/03/ant-design%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>全篇下来太啰嗦，<a href="https://github.com/sorrycc/blog/issues/62" target="_blank" rel="noopener">umi + dva，完成用户管理的 CURD 应用</a>是重点，看这里就行了！！！</p>
<h2 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h2><p><a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a>,<code>antd</code> 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。</p>
<h3 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h3><ul>
<li><p>config：配置信息<br><code>config.js</code>全局配置，路由配置<br><code>defaultSettings.js</code>一些默认配置<br><code>plugin.config.js</code>插件配置</p>
</li>
<li><p>mock 模拟数据请求的</p>
</li>
<li><p>mode_modules 第三方库</p>
</li>
<li><p>public 放置第三方文件（比如说图片，第三方的json文件）</p>
</li>
<li><p>tests 做一些测试的</p>
</li>
<li><p>package.json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"ant-design-pro"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"An out-of-box UI solution for enterprise applications"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"analyze"</span>: <span class="string">"分析"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"编译"</span>,</span><br><span class="line">    <span class="string">"deploy"</span>: <span class="string">"部署"</span>,</span><br><span class="line">    <span class="string">"fetch:blocks"</span>: <span class="string">"从官网git里面去拉模块"</span>,</span><br><span class="line">    <span class="string">"format-imports"</span>: <span class="string">"代码格式（例如空格）"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"启动"</span>,</span><br><span class="line">    <span class="string">"start:no-mock"</span>: <span class="string">"cross-env MOCK=none umi dev"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"测试"</span>,</span><br><span class="line">    <span class="string">"test:all"</span>: <span class="string">"node ./tests/run-tests.js"</span>,</span><br><span class="line">    <span class="string">"test:component"</span>: <span class="string">"umi test ./src/components"</span>,</span><br><span class="line">    <span class="string">"ui"</span>: <span class="string">"umi ui"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>src</p>
</li>
</ul>
<p><code>assets</code>静态资源<br><code>components</code>组件目录<br><code>e2e</code><br><code>layouts</code>布局<br><code>locales</code>多语言<br><code>models</code>模型目录<br><code>pages</code>页面<br><code>services</code>提供服务，给页面提供请求<br><code>utils</code>工具类<br><code>global.less</code><br><code>global.tsx</code><br><code>manifelst.json</code><br><code>service-worker.js</code><br><code>typings.d.ts</code></p>
<h3 id="增加新页面"><a href="#增加新页面" class="headerlink" title="增加新页面"></a>增加新页面</h3><p>1.在config-config.js文件的routers节点添加代码</p>
<p>{name: ‘demo’, path: ‘/demo’, component: ‘./demo’},</p>
<p>2.在page目录下创建demo目录，并新建一个index.jsx文件。<br>3.添加源码。</p>
<h2 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h2><ul>
<li><a href="https://dvajs.com" target="_blank" rel="noopener">dva官网</a></li>
<li><a href="https://www.bilibili.com/video/av55863089?from=search&seid=7612457114058753391" target="_blank" rel="noopener">dva视频教程</a>，以及练习<a href="https://github.com/samtake/dva" target="_blank" rel="noopener">源码</a></li>
<li><a href="https://www.jianshu.com/p/0568a725f8f9" target="_blank" rel="noopener">dva.js的使用与说明</a></li>
</ul>
<h2 id="UmiJS"><a href="#UmiJS" class="headerlink" title="UmiJS"></a>UmiJS</h2><ul>
<li><a href="https://umijs.org/zh-CN" target="_blank" rel="noopener">UmiJS</a></li>
<li><a href="https://www.bilibili.com/video/av74033079?p=51" target="_blank" rel="noopener">UmiJS视频教程</a>，以及<a href="https://github.com/plter/ReactCourse20191031" target="_blank" rel="noopener">源码</a></li>
<li><a href="https://www.cnblogs.com/lihuijuan/p/11242976.html" target="_blank" rel="noopener">Ant Design Pro 脚手架+umiJS 实践总结</a></li>
</ul>
<h2 id="dva-umi"><a href="#dva-umi" class="headerlink" title="dva + umi"></a>dva + umi</h2><p>主要搞懂model、service的关系</p>
<ul>
<li><a href="https://github.com/sorrycc/blog/issues/62" target="_blank" rel="noopener">umi + dva，完成用户管理的 CURD 应用</a></li>
<li><a href="https://github.com/umijs/umi-example-dva-user-dashboard" target="_blank" rel="noopener">umi-example-dva-user-dashboard</a></li>
</ul>
]]></content>
      <categories>
        <category>ant-design</category>
      </categories>
      <tags>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitea</title>
    <url>/2020/03/02/Gitea/</url>
    <content><![CDATA[<p><a href="https://gitea.io/zh-cn/" target="_blank" rel="noopener">Gitea</a>:一个开源社区驱动的轻量级代码托管解决方案</p>
]]></content>
  </entry>
  <entry>
    <title>Golang搭建并行处理管道</title>
    <url>/2020/03/02/Golang%E6%90%AD%E5%BB%BA%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang练习笔记</title>
    <url>/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableZeroValue</span></span>() &#123;</span><br><span class="line">	var a int</span><br><span class="line">	var s string</span><br><span class="line">	fmt.Printf(<span class="string">"%d %q\n"</span>, a, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableInitialValue</span></span>() &#123;</span><br><span class="line">	var a, b int = 3, 4</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型推断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableTypeDeduction</span></span>() &#123;</span><br><span class="line">	var a, b, c, d = 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>利用冒号定义的简单写法  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableShorter</span></span>() &#123;</span><br><span class="line">	a, b, c, d := 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	b = 6</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数外的变量定义(不能使用冒号定义，且它的作用域只在该包内部)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var aa = 55</span><br><span class="line">var ss = <span class="string">"llll"</span></span><br><span class="line">var bb = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">	bbb = 666</span><br><span class="line">	sss = <span class="string">"jjj"</span></span><br><span class="line">	ttt = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h2><p><code>bool</code>, <code>string</code>,</p>
<p><code>(u)int</code>, <code>(u)int8</code>, <code>(u)int16</code>, <code>(u)int32</code>, <code>(u)int64</code>, <code>uintptr</code>,</p>
<p><code>byte</code>, <code>rune</code>,</p>
<p><code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>,</p>
<h2 id="常量与枚举"><a href="#常量与枚举" class="headerlink" title="常量与枚举"></a>常量与枚举</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> func <span class="function"><span class="title">consts</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	const a, b = 3, 4</span><br><span class="line">	var c int</span><br><span class="line">	c = int(math.Sqrt(a*a + b + b))</span><br><span class="line">	fmt.Println(filename, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">enums</span></span>() &#123;</span><br><span class="line">	const (</span><br><span class="line">		cpp = iota</span><br><span class="line">		java</span><br><span class="line">		golang</span><br><span class="line">		swift</span><br><span class="line">		_</span><br><span class="line">		C</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	const (</span><br><span class="line">		b = 1 &lt;&lt; (10 * iota)</span><br><span class="line">		bb</span><br><span class="line">		bbb</span><br><span class="line">		bbbb</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	fmt.Println(cpp, java, golang, C)</span><br><span class="line">	fmt.Println(b, bb, bbb, bbbb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abc.txt 4</span><br><span class="line">0 1 2 5</span><br><span class="line">1 1024 1048576 1073741824</span><br></pre></td></tr></table></figure>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if的条件里可以赋值<br>if的条件里赋值的变量作用域就在这个if语句里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	<span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch后面可以没有表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func grade(score int) string &#123;</span><br><span class="line">	g := <span class="string">""</span></span><br><span class="line">	switch &#123;</span><br><span class="line">	<span class="keyword">case</span> score &lt; 0 || score &gt; 100:</span><br><span class="line">		panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	<span class="keyword">case</span> score &lt; 60:</span><br><span class="line">		g = <span class="string">"F"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 80:</span><br><span class="line">		g = <span class="string">"C"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 90:</span><br><span class="line">		g = <span class="string">"B"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 100:</span><br><span class="line">		g = <span class="string">"A"</span></span><br><span class="line">		// default:</span><br><span class="line">		// 	panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func convertToBin(n int) string &#123;</span><br><span class="line">	res := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> ; n &gt; 0; n /= 2 &#123;</span><br><span class="line">		lsb := n % 2</span><br><span class="line">		res = strconv.Itoa(lsb) + res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printFile(filename string) &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	scanner := bufio.NewScanner(file)</span><br><span class="line">	<span class="keyword">for</span> scanner.<span class="function"><span class="title">Scan</span></span>() &#123;</span><br><span class="line">		fmt.Println(scanner.Text)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">forever</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"abc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>返回值类型写在后面</li>
<li>可返回多个值</li>
<li>函数作为参数</li>
<li>没有默认参数，有可选参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func div(a, b int) (q, r int) &#123;</span><br><span class="line">	// <span class="built_in">return</span> a / b, a % b</span><br><span class="line">	q = a / b</span><br><span class="line">	r = a % b</span><br><span class="line">	<span class="built_in">return</span> q, r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func pow(a, b int) int &#123;</span><br><span class="line">	<span class="built_in">return</span> int(math.Pow(float64(a), float64(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	q, r := div(8, 6)</span><br><span class="line">	fmt.Println(q, r)</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(pow, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者以匿名函数的形式进行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(</span><br><span class="line">		func(a int, b int) int &#123;</span><br><span class="line">			<span class="built_in">return</span> int(math.Pow(</span><br><span class="line">				float64(a), float64(b)))</span><br><span class="line">		&#125;, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>函数作为参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func apply(op func(int, int) int, a, b int) int &#123;</span><br><span class="line">	p := reflect.ValueOf(op).Pointer()</span><br><span class="line">	opName := runtime.FuncForPC(p).Name()</span><br><span class="line">	fmt.Printf(<span class="string">"Calling function %s with args "</span>+</span><br><span class="line">		<span class="string">"(%d, %d)\n"</span>, opName, a, b)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> op(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func sum(numbers ...int) int &#123;</span><br><span class="line">	s := 0</span><br><span class="line">	<span class="keyword">for</span> i := range numbers &#123;</span><br><span class="line">		s += numbers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>参数传递</p>
<ul>
<li><p>go语言只有值传递一种方式<br><code>var a int</code> 当参数传递给<code>fun f(pa *int)</code>它其实就是将a的指针&amp;a拷贝一份传递给pa,pa也跟&amp;a一样，同时指向a</p>
</li>
<li><p>再如：<code>var cache Cache</code> 当参数传递给<code>func f(cache Cache)</code>,参数Cache那么大不可能拷贝一份的，实际上Cache也只是一个指向data的指针，所以cache当参数的时候，它只是拷贝了一份指针，它同时也指向了data</p>
</li>
</ul>
<p>交换两个变量的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func swap(a, b int) &#123;</span><br><span class="line">	b, a = a, b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(a, b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  hello go run point.go</span><br><span class="line">3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>我们发现值没有变，这是需要使用指针，将a,b所指向的值改变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) &#123;</span><br><span class="line">	*b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(&amp;a, &amp;b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var arr1 [5]int</span><br><span class="line">	arr2 := [3]int&#123;1, 2, 3&#125;      //冒号等于的定义，需要给数组一个初值</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; //或者不指定数组个数</span><br><span class="line">	fmt.Println(arr1, arr2, arr3)</span><br><span class="line"></span><br><span class="line">	//二维数组定义</span><br><span class="line">	var grid [4][5]int</span><br><span class="line">	fmt.Println(grid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := 0; i &lt; len(arr3); i++ &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>下标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := range arr3 &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>下标和值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>数组是值类型的，所以当参数用的时候需要指定长度<code>cannot use arr1 (type [5]int) as type [4]int in argument to printArray</code>，且在函数里面再次赋值后，它在外面是不会改变的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printArray(arr [4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，依旧是1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以，[10]int和[20]int 是不同类型；调用func f(arr [10]int)会拷贝数组。需要改变它就需要用到指针了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; </span><br><span class="line"></span><br><span class="line">	printArray(&amp;arr3)</span><br><span class="line">	fmt.Println(arr3, arr3[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printArray(arr *[4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，改变为100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func updateSlice(s []int)&#123;</span><br><span class="line">	s[0] = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	//s := arr[2:6]</span><br><span class="line">	fmt.Println(<span class="string">"arr[2:6] ="</span>, arr[2:6])<span class="comment">#arr[2:6] = [2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[:6] ="</span>, arr[:6])<span class="comment">#arr[:6] = [0 1 2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[2:] ="</span>, arr[2:])<span class="comment">#arr[2:] = [2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[:] ="</span>, arr[:])<span class="comment">#arr[:] = [0 1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	s1 := arr[2:]</span><br><span class="line">	s2 := arr[:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s1"</span>)</span><br><span class="line">	updateSlice(s1)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 	after updateSlice(s1</span></span><br><span class="line"><span class="comment">#   [100 3 4 5 6 7]</span></span><br><span class="line"><span class="comment"># 	[0 1 100 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s2"</span>)</span><br><span class="line">	updateSlice(s2)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 	after updateSlice(s2</span></span><br><span class="line"><span class="comment"># 	[100 1 100 3 4 5 6 7] </span></span><br><span class="line"><span class="comment"># 	[100 1 100 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"printArray"</span>)</span><br><span class="line">	printArray(arr[:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 	printArray</span></span><br><span class="line"><span class="comment"># 	0 100</span></span><br><span class="line"><span class="comment"># 	1 50</span></span><br><span class="line"><span class="comment"># 	2 100</span></span><br><span class="line"><span class="comment"># 	3 3</span></span><br><span class="line"><span class="comment"># 	4 4</span></span><br><span class="line"><span class="comment">#	 5 5</span></span><br><span class="line"><span class="comment"># 	6 6</span></span><br><span class="line"><span class="comment"># 	7 7</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"reslice"</span>)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[:5]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[2:]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 	reslice</span></span><br><span class="line"><span class="comment"># 	[100 50 100 3 4 5 6 7]</span></span><br><span class="line"><span class="comment"># 	[100 50 100 3 4]</span></span><br><span class="line"><span class="comment"># 	[100 3 4]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/slice.png" alt="slice"></p>
<p>slice可以向后扩展，不可以向前扩展<br>s[i]不可以超越len(s)，向后扩展不可以超越底层数组 cap(s)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceExtension</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"sliceExtension"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]</span><br><span class="line">	s2 := s1[3:5]</span><br><span class="line">	fmt.Println(<span class="string">"s1="</span>, s1)</span><br><span class="line">	fmt.Println(<span class="string">"s2="</span>, s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># sliceExtension</span></span><br><span class="line"><span class="comment"># s1= [2 3 4 5]</span></span><br><span class="line"><span class="comment"># s2= [5 6]</span></span><br></pre></td></tr></table></figure>

<p>向slice添加元素时，如果超越了cap，系统会重新分配更大的底层数组<br>新的slice里面， ptr len cap都会变掉，所以必须接收append的返回值</p>
<p>s = append(s, value)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceAppend</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"slice append"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]       <span class="comment">#	2 3 4 5</span></span><br><span class="line">	s2 := s1[3:5]        <span class="comment">#	5 6</span></span><br><span class="line">	s3 := append(s2, 10) <span class="comment">#	5 6 10</span></span><br><span class="line">	s4 := append(s3, 11) <span class="comment">#	5 6 10 11</span></span><br><span class="line">	s5 := append(s4, 12) <span class="comment">#	5 6 10 11 12</span></span><br><span class="line">	fmt.Println(<span class="string">"s3="</span>, s3)</span><br><span class="line">	fmt.Println(<span class="string">"s4="</span>, s4)</span><br><span class="line">	fmt.Println(<span class="string">"s5="</span>, s5)</span><br><span class="line">	fmt.Println(<span class="string">"arr="</span>, arr) <span class="comment">#	0, 1, 2, 3, 4, 5, 6 10  数组长度不变的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice的创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceCreate</span></span>() &#123;</span><br><span class="line">	var s []int  <span class="comment">#定义一个空slice</span></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		printSlice(s)</span><br><span class="line">		s = append(s, 2*i+1)</span><br><span class="line">	&#125;</span><br><span class="line">	println(s)</span><br><span class="line"></span><br><span class="line">	s1 := []int&#123;2, 3, 5, 6, 8, 2, 5&#125;</span><br><span class="line">	println(s1)</span><br><span class="line"></span><br><span class="line">	s2 := make([]int, 16)</span><br><span class="line">	s3 := make([]int, 10, 32) //32是开辟的空间<span class="built_in">cap</span></span><br><span class="line">	println(<span class="string">"print Slice  s2 s3"</span>)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">	printSlice(s3)</span><br><span class="line"></span><br><span class="line">	println(<span class="string">"Slice copy"</span>)</span><br><span class="line">	copy(s2, s1) <span class="comment"># 将s1复制给s2</span></span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">	//如何删除8</span><br><span class="line">	println(<span class="string">"Slice delete"</span>)</span><br><span class="line">	s2 = append(s2[:4], s2[5:]...)</span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//删除头尾</span><br><span class="line">	fmt.Println(<span class="string">"pop from front"</span>)</span><br><span class="line">	front := s2[0]</span><br><span class="line">	s2 = s2[1:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"pop from back"</span>)</span><br><span class="line">	back := s2[len(s2)-1]</span><br><span class="line">	s2 = s2[:len(s2)-1]</span><br><span class="line">	fmt.Println(front, back)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> Slice  s2 s3</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0], len=10, <span class="built_in">cap</span>= 32</span><br><span class="line">Slice copy</span><br><span class="line">[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">Slice delete</span><br><span class="line">[2 3 5 6 2 5 0 0 0 0 0 0 0 0 0], len=15, <span class="built_in">cap</span>= 16</span><br><span class="line">pop from front</span><br><span class="line">pop from back</span><br><span class="line">2 0</span><br><span class="line">[3 5 6 2 5 0 0 0 0 0 0 0 0], len=13, <span class="built_in">cap</span>= 15</span><br></pre></td></tr></table></figure>



<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	m := map[string]string&#123;</span><br><span class="line">		<span class="string">"name"</span>:  <span class="string">"sam"</span>,</span><br><span class="line">		<span class="string">"class"</span>: <span class="string">"go"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	m2 := make(map[string]int)</span><br><span class="line"></span><br><span class="line">	var m3 map[string]int</span><br><span class="line"></span><br><span class="line">	fmt.Println(m2, m3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>遍历，key在map里是无序的～</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := range m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当key打错了，获取到的是空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取值</span><br><span class="line">	fmt.Println(<span class="string">"getting values"</span>)</span><br><span class="line">	name := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name)</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">	println(name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	println(<span class="string">"key does not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//删除</span><br><span class="line">	fmt.Println(<span class="string">"delete values"</span>)</span><br><span class="line">	name1, ok := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name1, ok)</span><br></pre></td></tr></table></figure>

<p>map的key的类型可以是<br>除了slice,map,function的内建类型都可以作为key<br>struct类型不包含上述字段，也可以作为key</p>
<h2 id="字符和字符串的处理"><a href="#字符和字符串的处理" class="headerlink" title="字符和字符串的处理"></a>字符和字符串的处理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	s := <span class="string">"yes中文中文"</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	<span class="keyword">for</span> _, b := range []byte(s) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%X  "</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := range s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"(%d %X)"</span>, i, ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">"rune count:"</span>, utf8.RuneCountInString(s))</span><br><span class="line"></span><br><span class="line">	//单个字符转义</span><br><span class="line">	bytes := []byte(s)</span><br><span class="line">	<span class="keyword">for</span> len(bytes) &gt; 0 &#123;</span><br><span class="line">		ch, size := utf8.DecodeRune(bytes)</span><br><span class="line">		bytes = bytes[size:]</span><br><span class="line">		fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yes中文中文</span><br><span class="line">79  65  73  E4  B8  AD  E6  96  87  E4  B8  AD  E6  96  87  </span><br><span class="line">(0 79)(1 65)(2 73)(3 4E2D)(6 6587)(9 4E2D)(12 6587)</span><br><span class="line">rune count: 7</span><br><span class="line">y e s 中 文 中 文</span><br></pre></td></tr></table></figure>
<p>rune相当于go的char<br>使用range遍历string，rune对<br>使用utf8.RuneCountInString(s)获得字符数量<br>使用len获得字节长度<br>使用[]byte获得所有的字节</p>
<p>寻找最长不含重复字符的字串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func lengthOfNonRepeatSubStr(s string) int &#123;</span><br><span class="line">	lastOccurred := make(map[rune]int)</span><br><span class="line">	start := 0</span><br><span class="line">	maxLength := 0</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := range []rune(s) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123;</span><br><span class="line">			start = lastI + 1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i-start+1 &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start + 1</span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其它字符串操作<br>Fields Split Join<br>Contains Index<br>ToLower ToUpper<br>Trim TrimRight TrimLeft</p>
<h2 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>go仅支持封装，不支持继承和多态</p>
<p>结构体的创建：不论地址还是结构本身，一律使用<code>.</code>来访问成员</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定义</span><br><span class="line"><span class="built_in">type</span> treeNode struct &#123;</span><br><span class="line">	value       int</span><br><span class="line">	left, right *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂函数创建</span><br><span class="line">func createNode(value int) *treeNode &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;treeNode&#123;value: value&#125; //这里返回的是局部变量的地址给外部使用，在go依旧是可以的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var root treeNode</span><br><span class="line">	fmt.Println(root)</span><br><span class="line"></span><br><span class="line">	//创建</span><br><span class="line">	root = treeNode&#123;value: 3&#125;</span><br><span class="line">	root.left = &amp;treeNode&#123;&#125;</span><br><span class="line">	root.right = &amp;treeNode&#123;5, nil, nil&#125;</span><br><span class="line">	root.right.left = new(treeNode)</span><br><span class="line">	fmt.Println(root)</span><br><span class="line">	nodes := []treeNode&#123;</span><br><span class="line">		&#123;value: 3&#125;,</span><br><span class="line">		&#123;&#125;, </span><br><span class="line">		&#123;6, nil, &amp;root&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(nodes)</span><br><span class="line"></span><br><span class="line">	root.left.right = createNode(2)</span><br><span class="line">	fmt.Println(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给结构定义方法:<br>func后面括号的是方法接收者（其实就跟函数的返回值一样）<br>只有使用指针才可以改变结构的内容<br>nil指针也可以调用方法（可以将值传进来，但是nil的赋值会报错，需要做return处理）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//树的遍历:给结构定义方法</span><br><span class="line">func (node *treeNode) setValue(value int) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == nil &#123;</span><br><span class="line">		fmt.Println(<span class="string">"setting value to nil node"</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	node.value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//值不会变</span><br><span class="line">// func (node treeNode) setValue(value int) &#123;</span><br><span class="line">// 	node.value = value</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">func (node *treeNode) setValue(value int) &#123;</span><br><span class="line">	node.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">"print\n"</span>)</span><br><span class="line">	root.print()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\nsetValue\n"</span>)</span><br><span class="line">	root.right.left.setValue(9)</span><br><span class="line">	root.right.left.print()</span><br></pre></td></tr></table></figure>


<p>中序遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"> 总结：</span><br><span class="line"> 要改变内容必须使用指针接收者</span><br><span class="line"> 结构过大也考虑使用指针接收者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 包和封装</span></span><br><span class="line"></span><br><span class="line">封装</span><br><span class="line">名字一般使用驼峰命名</span><br><span class="line">首字母大写：public（针对于包）</span><br><span class="line">首字母小写：private（针对于包）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">包</span><br><span class="line">每个目录一个包</span><br><span class="line">main包包含可执行入口</span><br><span class="line">为结构定义的方法必须放在同一个包内</span><br><span class="line">一个包可以放不同的文件</span><br><span class="line">建议结构体都不需要前缀包名（TreeNode改为Node即可）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 拓展已有类型</span></span><br><span class="line"></span><br><span class="line">定义别名</span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">type</span> myTreeNode struct &#123;</span><br><span class="line">	node *tree.TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后序遍历</span><br><span class="line">func (myNode *myTreeNode) <span class="function"><span class="title">postOrder</span></span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> myNode == nil || myNode.node == nil &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	left := myTreeNode&#123;myNode.node.Left&#125;</span><br><span class="line">	left.postOrder()</span><br><span class="line"></span><br><span class="line">	right := myTreeNode&#123;myNode.node.Right&#125;</span><br><span class="line">	right.postOrder()</span><br><span class="line"></span><br><span class="line">	myNode.node.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用组合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package queue</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Queue []int</span><br><span class="line"></span><br><span class="line">func (q *Queue) Push(v int) &#123;</span><br><span class="line">	*q = append(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Pop() int &#123;</span><br><span class="line">	head := (*q)[0]</span><br><span class="line">	*q = (*q)[1:]</span><br><span class="line">	<span class="built_in">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) IsEmpty() bool &#123;</span><br><span class="line">	<span class="built_in">return</span> len(*q) == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/queue"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	q := queue.Queue&#123;1&#125;</span><br><span class="line">	q.Push(2)</span><br><span class="line">	q.Push(3)</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.IsEmpty())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.IsEmpty())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用内嵌来扩展已有类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> myTreeNode struct &#123;</span><br><span class="line">	*tree.Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>GOPATH</li>
<li>GOVENDOR</li>
<li>go mod</li>
</ul>
<p>go mod的使用</p>
<p>引入需要的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>直接运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run zaptest.go</span><br></pre></td></tr></table></figure>


<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u 库名 </span><br><span class="line"></span><br><span class="line">go mod init modtest</span><br><span class="line"></span><br><span class="line">go build ./...</span><br></pre></td></tr></table></figure>

<p>增加依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get</span><br></pre></td></tr></table></figure>

<p>更新依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get [@version]</span><br><span class="line"></span><br><span class="line">go mod tidy  //更新版本之后，使用该命令可以去除多余的文件</span><br></pre></td></tr></table></figure>

<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>每个单独目录只有一个mian函数</p>
<p>build当前目录的所有子文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build ./...</span><br></pre></td></tr></table></figure>

<p>产生结果, 结果放在GOPATH的bin目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install ./...</span><br><span class="line">go env GOPATH</span><br></pre></td></tr></table></figure>

<h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>infra</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package infra</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (Retriver) Get(url string) string &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> string(bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>testing</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package testing</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (Retriver) Get(url string) string &#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">"fake content"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>download</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/downloader/infra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func getRetriver() retriver &#123;</span><br><span class="line">	// <span class="built_in">return</span> testing.Retriver&#123;&#125;//测试</span><br><span class="line">	<span class="built_in">return</span> infra.Retriver&#123;&#125;//真实数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//是infra还是testing的Retriver呢？如何判断呢：通过接口</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> retriver interface &#123;</span><br><span class="line">	Get(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var r retriver = getRetriver()</span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, r.Get(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck typing"></a>duck typing</h2><h2 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h2><p>接口的定义(接口由使用者定义)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/retriever/mock"</span></span><br><span class="line">	<span class="string">"learngo/retriever/real"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver interface &#123;</span><br><span class="line">	Get(url string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func download(r Retriver) string &#123;</span><br><span class="line">	<span class="built_in">return</span> r.Get(<span class="string">"http://www.imooc.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var r Retriver</span><br><span class="line">	r = mock.Retriver&#123;<span class="string">"this is a fake imooc.com"</span>&#125;</span><br><span class="line">	r = real.Retriver&#123;&#125;</span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的实现（不需要实现Retriver接口，只需要实现接口里的方法）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package real</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct &#123;</span><br><span class="line">	UserAgent string</span><br><span class="line">	TimeOut   time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Retriver) Get(url string) string &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> string(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口的值类型"><a href="#接口的值类型" class="headerlink" title="接口的值类型"></a>接口的值类型</h2><p>switch判断类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func inspect(r Retriver) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"类型=%T 值=%v\n"</span>, r, r)</span><br><span class="line">	switch v := r.(<span class="built_in">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> mock.Retriver:</span><br><span class="line">		fmt.Println(<span class="string">"Contents:"</span>, v.Contents)</span><br><span class="line">	<span class="keyword">case</span> *real.Retriver:</span><br><span class="line">		fmt.Println(<span class="string">"UserAgent:"</span>, v.UserAgent)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type assertion</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">type</span> assertion</span><br><span class="line"></span><br><span class="line">	//real</span><br><span class="line">	realRetriver := r.(*real.Retriver)</span><br><span class="line">	fmt.Println(realRetriver.TimeOut)</span><br><span class="line"></span><br><span class="line">	//出错写法</span><br><span class="line">	realRetriver := r.(real.Retriver)</span><br><span class="line">	fmt.Println(realRetriver.TimeOut)</span><br><span class="line"></span><br><span class="line">	//防止出错</span><br><span class="line">	<span class="keyword">if</span> mockRetriver, ok := r.(mock.Retriver); ok &#123;</span><br><span class="line">		fmt.Println(mockRetriver.Contents)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not a mock retriver"</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>表示任何类型:interface{}</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//改为支持任何类型</span><br><span class="line"><span class="built_in">type</span> Queue []interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Push(v interface&#123;&#125;) &#123;</span><br><span class="line">	*q = append(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	head := (*q)[0]</span><br><span class="line">	*q = (*q)[1:]</span><br><span class="line">	<span class="built_in">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) IsEmpty() bool &#123;</span><br><span class="line">	<span class="built_in">return</span> len(*q) == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Retriver interface &#123;</span><br><span class="line">	Get(url string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Poster interface &#123;</span><br><span class="line">	Post(url string, form map[string]string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const url = <span class="string">"http://www.imooc.com"</span></span><br><span class="line"></span><br><span class="line">func download(r Retriver) string &#123;</span><br><span class="line">	<span class="built_in">return</span> r.Get(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func poster(poster Poster) &#123;</span><br><span class="line">	poster.Post(url,</span><br><span class="line">		map[string]string&#123;</span><br><span class="line">			<span class="string">"name"</span>:     <span class="string">"sam"</span>,</span><br><span class="line">			<span class="string">"language"</span>: <span class="string">"golang"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> RetriverPoster interface &#123;</span><br><span class="line">	Retriver</span><br><span class="line">	Poster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func session(s RetriverPoster) string &#123;</span><br><span class="line">	s.Post(url, map[string]string&#123;</span><br><span class="line">		<span class="string">"contents"</span>: <span class="string">"another facked imooc.com"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">return</span> s.Get(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="常用的系统接口"><a href="#常用的系统接口" class="headerlink" title="常用的系统接口"></a>常用的系统接口</h2><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>参数、变量、返回值都可以是函数<br>高阶函数（函数的参数依旧是个函数）<br>函数闭包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//返回一个函数</span><br><span class="line">func adder() func(int) int &#123;</span><br><span class="line">	sum := 0</span><br><span class="line">	<span class="built_in">return</span> func(v int) int &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		<span class="built_in">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	a := adder()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		fmt.Println((a(i)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>斐波那契数列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">	a, b := 0, 1</span><br><span class="line">	<span class="built_in">return</span> func() int &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">		<span class="built_in">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>为函数实现接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> intGen func() int</span><br><span class="line"></span><br><span class="line">func (g intGen) Read(</span><br><span class="line">	p []byte) (n int, err error) &#123;</span><br><span class="line">	next := g()</span><br><span class="line">	<span class="keyword">if</span> next &gt; 10000 &#123;</span><br><span class="line">		<span class="built_in">return</span> 0, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line">	s := fmt.Sprintf(<span class="string">"%d\n"</span>, next)</span><br><span class="line"></span><br><span class="line">	// TODO: incorrect <span class="keyword">if</span> p is too small!</span><br><span class="line">	<span class="built_in">return</span> strings.NewReader(s).Read(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func printFileContents(reader io.Reader) &#123;</span><br><span class="line">	scanner := bufio.NewScanner(reader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> scanner.<span class="function"><span class="title">Scan</span></span>() &#123;</span><br><span class="line">		fmt.Println(scanner.Text())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var f intGen = fib.Fibonacci()</span><br><span class="line">	printFileContents(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>利用函数遍历二叉树</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>确保调用在函数结束时发生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	defer fmt.Println(2)</span><br><span class="line">	defer fmt.Println(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defer是一个栈，先进后出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	defer fmt.Println(2)</span><br><span class="line">	defer fmt.Println(3)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">		defer fmt.Println(i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i == 30 &#123;</span><br><span class="line">			panic(<span class="string">"printed too many"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeFle(filename string) &#123;</span><br><span class="line">	file, err := os.Create(filename)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	defer writer.Flush()</span><br><span class="line"></span><br><span class="line">	f := fib.Fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		fmt.Fprintln(writer, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	writeFle(<span class="string">"fib.txt"</span>)</span><br><span class="line"></span><br><span class="line">	tryDefer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  defer go run defer.go</span><br><span class="line">30</span><br><span class="line">29</span><br><span class="line">28</span><br><span class="line">27</span><br><span class="line">26</span><br><span class="line">25</span><br><span class="line">24</span><br><span class="line">23</span><br><span class="line">22</span><br><span class="line">21</span><br><span class="line">20</span><br><span class="line">19</span><br><span class="line">18</span><br><span class="line">17</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">14</span><br><span class="line">13</span><br><span class="line">12</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">panic: printed too many</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.tryDefer()</span><br><span class="line">        /Users/samtake/Desktop/learngo/hello/errHandling/defer/defer.go:19 +0x2fc</span><br><span class="line">main.main()</span><br><span class="line">        /Users/samtake/Desktop/learngo/hello/errHandling/defer/defer.go:43 +0x3b</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p>何时调用defer</p>
<ul>
<li><p>Open/Close</p>
</li>
<li><p>Lock/Unlock</p>
</li>
<li><p>PrintHeader/PrintFooter</p>
</li>
</ul>
<p>错误处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">		defer fmt.Println(i)</span><br><span class="line">		<span class="keyword">if</span> i == 30 &#123;</span><br><span class="line">			// Uncomment panic to see</span><br><span class="line">			// how it works with defer</span><br><span class="line">			// panic(<span class="string">"printed too many"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeFle(filename string) &#123;</span><br><span class="line">	file, err := os.OpenFile(filename,</span><br><span class="line">		os.O_EXCL|os.O_CREATE|os.O_WRONLY, 0666)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		<span class="keyword">if</span> pathError, ok := err.(*os.PathError); !ok &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%s, %s, %s\n"</span>,</span><br><span class="line">				pathError.Op,</span><br><span class="line">				pathError.Path,</span><br><span class="line">				pathError.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	defer writer.Flush()</span><br><span class="line"></span><br><span class="line">	f := fib.Fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		fmt.Fprintln(writer, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器统一出错处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> appHandler func(writer http.ResponseWriter,</span><br><span class="line">	request *http.Request) error</span><br><span class="line"></span><br><span class="line">func errWrapper(</span><br><span class="line">	handler appHandler) func(</span><br><span class="line">	http.ResponseWriter, *http.Request) &#123;</span><br><span class="line">	<span class="built_in">return</span> func(writer http.ResponseWriter,</span><br><span class="line">		request *http.Request) &#123;</span><br><span class="line">		// panic</span><br><span class="line">		defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			<span class="keyword">if</span> r := recover(); r != nil &#123;</span><br><span class="line">				log.Printf(<span class="string">"Panic: %v"</span>, r)</span><br><span class="line">				http.Error(writer,</span><br><span class="line">					http.StatusText(http.StatusInternalServerError),</span><br><span class="line">					http.StatusInternalServerError)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		err := handler(writer, request)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			log.Printf(<span class="string">"Error occurred "</span>+</span><br><span class="line">				<span class="string">"handling request: %s"</span>,</span><br><span class="line">				err.Error())</span><br><span class="line"></span><br><span class="line">			// user error</span><br><span class="line">			<span class="keyword">if</span> userErr, ok := err.(userError); ok &#123;</span><br><span class="line">				http.Error(writer,</span><br><span class="line">					userErr.Message(),</span><br><span class="line">					http.StatusBadRequest)</span><br><span class="line">				<span class="built_in">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// system error</span><br><span class="line">			code := http.StatusOK</span><br><span class="line">			switch &#123;</span><br><span class="line">			<span class="keyword">case</span> os.IsNotExist(err):</span><br><span class="line">				code = http.StatusNotFound</span><br><span class="line">			<span class="keyword">case</span> os.IsPermission(err):</span><br><span class="line">				code = http.StatusForbidden</span><br><span class="line">			default:</span><br><span class="line">				code = http.StatusInternalServerError</span><br><span class="line">			&#125;</span><br><span class="line">			http.Error(writer,</span><br><span class="line">				http.StatusText(code), code)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> userError interface &#123;</span><br><span class="line">	error</span><br><span class="line">	Message() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>,</span><br><span class="line">		errWrapper(filelisting.HandleFileList))</span><br><span class="line"></span><br><span class="line">	err := http.ListenAndServe(<span class="string">":8888"</span>, nil)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><p>panic<br>停止当前函数执行<br>一直向上返回，执行每一层的defer<br>如果没有遇见recover，程序就退出</p>
<p>recover<br>仅在defer调用中使用<br>获取panic的值<br>如果无法处理，可重新panic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryRecover</span></span>() &#123;</span><br><span class="line">	defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		r := recover()</span><br><span class="line">		<span class="keyword">if</span> r == nil &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Nothing to recover. "</span> +</span><br><span class="line">				<span class="string">"Please try uncomment errors "</span> +</span><br><span class="line">				<span class="string">"below."</span>)</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Error occurred:"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			panic(fmt.Sprintf(</span><br><span class="line">				<span class="string">"I don't know what to do: %v"</span>, r))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>go test 会自动执行路径包下面的“_test.go”文件（包括文件名包含 “_test.go” 的源文件），我们管称这些是测试文件，里面包含着你的测试函数，测试用例等。更多用法可以输入 “go help test” 查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="代码覆盖率和性能测试"><a href="#代码覆盖率和性能测试" class="headerlink" title="代码覆盖率和性能测试"></a>代码覆盖率和性能测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用pprof进行性能调优</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="测试http服务器"><a href="#测试http服务器" class="headerlink" title="测试http服务器"></a>测试http服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成文档和实力代码</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>轻量级“线程”<br>非抢占式多任务处理，由协程主动交出控制权（Printf是个IO操作，内部做了控制权切换）<br>多个协程可能在一个或多个线程上运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"hello form goroutine %d\n"</span>, i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">tryGoroutine</span></span>() &#123;</span><br><span class="line">	var a [10]int</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func(ii int) &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				a[ii]++</span><br><span class="line">				runtime.Gosched()//主动交出控制权</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据访问的冲突</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run -race goroutine.go</span><br></pre></td></tr></table></figure>

<p>查看cpu占用率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p>go语言的调度器</p>
<p>任何函数只需加上go就能送给调度器运行<br>不需要在定义时区分是否是异步函数<br>调度器在合适的点进行切换<br>使用-race来检测数据访问冲突</p>
<p>goroutine 可能的切换点<br>I/O、select<br>channel<br>等待锁<br>函数调用（有时会）<br>runtime.Gosched()<br>以上所列只是参考～真实情况就不一定～</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	// var c chan int //c == nil</span><br><span class="line">	c := make(chan int)</span><br><span class="line"></span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n := &lt;-c</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	c &lt;- 2 //如果main退出了，2是没有输出的</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func worker(c chan int) &#123;</span><br><span class="line">	<span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n := &lt;-c</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	// var c chan int //c == nil</span><br><span class="line">	c := make(chan int)</span><br><span class="line"></span><br><span class="line">	go worker(c)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	c &lt;- 2 //如果main退出了，2是没有输出的</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>channel作为参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func worker(id int, c chan int) &#123;</span><br><span class="line">	<span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var channels [10]chan int</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] = make(chan int)</span><br><span class="line">		go worker(i, channels[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>channel作为返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func creatWorker(id int) chan&lt;- int &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var channels [10]chan&lt;- int</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] = creatWorker(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存channel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">bufferedChannel</span></span>() &#123;</span><br><span class="line">	c := make(chan int, 3) //给个缓存3</span><br><span class="line">	go work(0, c)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>关闭通道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">channelClose</span></span>() &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go work(0, c)</span><br><span class="line">	c &lt;- <span class="string">'a'</span></span><br><span class="line">	c &lt;- <span class="string">'b'</span></span><br><span class="line">	c &lt;- <span class="string">'c'</span></span><br><span class="line">	c &lt;- <span class="string">'d'</span></span><br><span class="line">	close(c)</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭之后，依旧能收到（空串，0）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Worker 0 received a</span><br><span class="line">Worker 0 received b</span><br><span class="line">Worker 0 received c</span><br><span class="line">Worker 0 received d</span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 r</span><br></pre></td></tr></table></figure>

<p>解决关闭之后不再输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, ok := &lt;-c</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="built_in">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> n := range c &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用channel等待goroutine结束（重点）"><a href="#使用channel等待goroutine结束（重点）" class="headerlink" title="使用channel等待goroutine结束（重点）"></a>使用channel等待goroutine结束（重点）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func doWork(id int,</span><br><span class="line">	w worker) &#123;</span><br><span class="line">	<span class="keyword">for</span> n := range w.in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>,</span><br><span class="line">			id, n)</span><br><span class="line">		w.done()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> worker struct &#123;</span><br><span class="line">	<span class="keyword">in</span>   chan int</span><br><span class="line">	<span class="keyword">done</span> func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createWorker(</span><br><span class="line">	id int, wg *sync.WaitGroup) worker &#123;</span><br><span class="line">	w := worker&#123;</span><br><span class="line">		<span class="keyword">in</span>: make(chan int),</span><br><span class="line">		<span class="keyword">done</span>: <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	go doWork(id, w)</span><br><span class="line">	<span class="built_in">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	var workers [10]worker</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		workers[i] = createWorker(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Add(20)</span><br><span class="line">	<span class="keyword">for</span> i, worker := range workers &#123;</span><br><span class="line">		worker.in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, worker := range workers &#123;</span><br><span class="line">		worker.in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	chanDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Worker 7 received h</span><br><span class="line">Worker 5 received f</span><br><span class="line">Worker 0 received a</span><br><span class="line">Worker 1 received b</span><br><span class="line">Worker 1 received B</span><br><span class="line">Worker 4 received e</span><br><span class="line">Worker 9 received j</span><br><span class="line">Worker 8 received i</span><br><span class="line">Worker 2 received c</span><br><span class="line">Worker 0 received A</span><br><span class="line">Worker 6 received g</span><br><span class="line">Worker 3 received d</span><br><span class="line">Worker 9 received J</span><br><span class="line">Worker 6 received G</span><br><span class="line">Worker 7 received H</span><br><span class="line">Worker 2 received C</span><br><span class="line">Worker 4 received E</span><br><span class="line">Worker 8 received I</span><br><span class="line">Worker 3 received D</span><br><span class="line">Worker 5 received F</span><br></pre></td></tr></table></figure>


<p>使用Channel进行书的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用Select进行调度（重点）"><a href="#使用Select进行调度（重点）" class="headerlink" title="使用Select进行调度（重点）"></a>使用Select进行调度（重点）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func generator() chan int &#123;</span><br><span class="line">	out := make(chan int)</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		i := 0</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(</span><br><span class="line">				time.Duration(rand.Intn(1500)) *</span><br><span class="line">					time.Millisecond)</span><br><span class="line">			out &lt;- i</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func worker(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> n := range c &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %d\n"</span>,</span><br><span class="line">			id, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createWorker(id int) chan&lt;- int &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go worker(id, c)</span><br><span class="line">	<span class="built_in">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var c1, c2 = generator(), generator()</span><br><span class="line">	var worker = createWorker(0)</span><br><span class="line"></span><br><span class="line">	var values []int</span><br><span class="line">	tm := time.After(10 * time.Second)</span><br><span class="line">	tick := time.Tick(time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		var activeWorker chan&lt;- int</span><br><span class="line">		var activeValue int</span><br><span class="line">		<span class="keyword">if</span> len(values) &gt; 0 &#123;</span><br><span class="line">			activeWorker = worker</span><br><span class="line">			activeValue = values[0]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		select &#123;</span><br><span class="line">		<span class="keyword">case</span> n := &lt;-c1:</span><br><span class="line">			values = append(values, n)</span><br><span class="line">		<span class="keyword">case</span> n := &lt;-c2:</span><br><span class="line">			values = append(values, n)</span><br><span class="line">		<span class="keyword">case</span> activeWorker &lt;- activeValue:</span><br><span class="line">			values = values[1:]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(800 * time.Millisecond):</span><br><span class="line">			fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-tick:</span><br><span class="line">			fmt.Println(</span><br><span class="line">				<span class="string">"queue len ="</span>, len(values))</span><br><span class="line">		<span class="keyword">case</span> &lt;-tm:</span><br><span class="line">			fmt.Println(<span class="string">"bye"</span>)</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>WaitGroup<br>Mutex<br>Cond</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 迷宫算法</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="http标准库"><a href="#http标准库" class="headerlink" title="http标准库"></a>http标准库</h2><p>使用http客户端发送请求<br>使用http.Client控制请求头部等<br>使用httputil简化工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	request, err := http.NewRequest(</span><br><span class="line">		http.MethodGet,</span><br><span class="line">		<span class="string">"http://www.imooc.com"</span>, nil)</span><br><span class="line">	request.Header.Add(<span class="string">"User-Agent"</span>,</span><br><span class="line">		<span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1"</span>)</span><br><span class="line"></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		CheckRedirect: func(</span><br><span class="line">			req *http.Request,</span><br><span class="line">			via []*http.Request) error &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Redirect:"</span>, req)</span><br><span class="line">			<span class="built_in">return</span> nil</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pprof</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...../debug/pprof/</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof [地址]</span><br></pre></td></tr></table></figure>



<h2 id="其它标准库"><a href="#其它标准库" class="headerlink" title="其它标准库"></a>其它标准库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bufio</span><br><span class="line"><span class="built_in">log</span></span><br><span class="line">encoding/json</span><br><span class="line">regexp</span><br><span class="line">time</span><br><span class="line">strings/math/rand</span><br></pre></td></tr></table></figure>

<p>获取文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">godoc -http :8888</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://docscn.studygolang.com/</span><br></pre></td></tr></table></figure>



<h2 id="gin-amp-增加middleware"><a href="#gin-amp-增加middleware" class="headerlink" title="gin&amp;增加middleware"></a>gin&amp;增加middleware</h2><p>拉取gin和日志库zap</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br><span class="line">go get -u go.uber.org/zap</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/ping</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen tcp :8080: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use 问题解决</span><br><span class="line">命令行 lsof -i:8080 这里8080是我要释放的端口号</span><br><span class="line"></span><br><span class="line">可以看到，该端口被id为51217的进程所占用，这个时候直接在命令行输入</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 51217</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	logger, err := zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Use(func(c *gin.Context) &#123;</span><br><span class="line">		logger.Info(<span class="string">"incoming request"</span>, zap.String(<span class="string">"path"</span>, c.Request.URL.Path))</span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/hello"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"hello"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const keyRequestId = <span class="string">"requestId"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	logger, err := zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Use(func(c *gin.Context) &#123;</span><br><span class="line">		s := time.Now()</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		logger.Info(<span class="string">"incoming request"</span>,</span><br><span class="line">			zap.String(<span class="string">"path"</span>, c.Request.URL.Path),</span><br><span class="line">			zap.Int(<span class="string">"status"</span>, c.Writer.Status()),</span><br><span class="line">			zap.Duration(<span class="string">"elapsed"</span>, time.Now().Sub(s)))</span><br><span class="line">	&#125;, func(c *gin.Context) &#123;</span><br><span class="line">		c.Set(keyRequestId, rand.Int())</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		h := gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> rid, exists := c.Get(keyRequestId); exists &#123;</span><br><span class="line">			h[keyRequestId] = rid</span><br><span class="line">		&#125;</span><br><span class="line">		c.JSON(200, h)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">"/hello"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"hello"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`)</span><br><span class="line">	match := re.FindAllString(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[sam@gmail.com 5555@qq.com 5555@163.com]</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`([a-zA-Z0-9]+)@([a-zA-Z0-9]+)\.([a-zA-Z0-9]+)`)</span><br><span class="line">	match := re.FindAllStringSubmatch(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, m := range match &#123;</span><br><span class="line">		fmt.Println(m)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[sam@gmail.com sam gmail com] [5555@qq.com 5555 qq com] [5555@163.com 5555 163 com]]</span><br><span class="line">[sam@gmail.com sam gmail com]</span><br><span class="line">[5555@qq.com 5555 qq com]</span><br><span class="line">[5555@163.com 5555 163 com]</span><br></pre></td></tr></table></figure>

<h2 id="包管理-包引入"><a href="#包管理-包引入" class="headerlink" title="包管理(包引入)"></a>包管理(包引入)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init [crawler-single-task]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  crawler git:(master) ✗ cat go.mod                     </span><br><span class="line">module crawler-single-task</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        golang.org/x/net v0.0.0-20191207000613-e7e4b65ae663</span><br><span class="line">        golang.org/x/text v0.3.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>以项目当前目录为起点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"crawler-single-task/engine"</span></span><br><span class="line">	<span class="string">"crawler-single-task/zhenai/parser"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="单任务爬虫要点笔记"><a href="#单任务爬虫要点笔记" class="headerlink" title="单任务爬虫要点笔记"></a>单任务爬虫要点笔记</h2><h3 id="转换-UTF-8-与-GBK-编码的文本"><a href="#转换-UTF-8-与-GBK-编码的文本" class="headerlink" title="转换 UTF-8 与 GBK 编码的文本"></a>转换 UTF-8 与 GBK 编码的文本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get golang.org/x/text</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">utf8Reader := transform.NewReader(resp.Body, simplifiedchinese.GBK.NewDecoder())</span><br></pre></td></tr></table></figure>

<h3 id="确定编码库"><a href="#确定编码库" class="headerlink" title="确定编码库"></a>确定编码库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get golang.org/x/net/html</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//确定编码</span><br><span class="line">func determinEncoding(r io.Reader) encoding.Encoding &#123;</span><br><span class="line">	bytes, err := bufio.NewReader(r).Peek(1024)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	e, _, _ := charset.DetermineEncoding(bytes, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//转码</span><br><span class="line">	e := determinEncoding(resp.Body)</span><br><span class="line">	utf8Reader := transform.NewReader(resp.Body, e.NewDecoder())</span><br></pre></td></tr></table></figure>

<h3 id="获取城市名和链接的方式"><a href="#获取城市名和链接的方式" class="headerlink" title="获取城市名和链接的方式"></a>获取城市名和链接的方式</h3><p>使用css选择器<code>$(&#39;#cityList&gt;dd&gt;a&#39;)</code></p>
<p>使用xpath</p>
<p>使用正则表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`)</span><br><span class="line">	match := re.FindAllString(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>第三方库httprouter</title>
    <url>/2020/02/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93httprouter/</url>
    <content><![CDATA[<p><a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>是一个高可用的http路由请求库。路由器通过请求方法和路径来匹配传入的请求。如果为该路径和方法注册了句柄，路由器会将请求委托给该函数。对于方法GET、POST、PUT、PATCH、DELETE和OPTIONS，存在注册句柄的快捷功能，对于所有其他方法路由器。可以使用手柄。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/julienschmidt/httprouter"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">"Welcome!\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Hello(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"hello, %s!\n"</span>, ps.ByName(<span class="string">"name"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    router := httprouter.New()</span><br><span class="line">    router.GET(<span class="string">"/"</span>, Index)</span><br><span class="line">    router.GET(<span class="string">"/hello/:name"</span>, Hello)</span><br><span class="line"></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, router))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang流媒体网站笔记</title>
    <url>/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/architecture.png" alt></p>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/api.png" alt></p>
<p>httprouter的使用</p>
<p>restlet测试插件 </p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="3-6"><a href="#3-6" class="headerlink" title="3-6"></a>3-6</h3><p>总体思路：<br>handleer-&gt;validation{1.request,2.user}-&gt;business login -&gt;response</p>
<ol>
<li>data model</li>
<li>error handler</li>
</ol>
<p>这个错误接口以后都可以这样写了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package defs</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Err struct &#123;</span><br><span class="line">	Error string `json:<span class="string">"error"</span>`</span><br><span class="line">	ErrorCode string `json:<span class="string">"error_code"</span>`  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ErrResponse struct &#123;</span><br><span class="line">	HttpSC int</span><br><span class="line">	Error Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	ErrorRequestBodyParseFailed = ErrResponse&#123;HttpSC: 400, Error: Err&#123;Error: <span class="string">"Request body is not correct"</span>, ErrorCode: <span class="string">"001"</span>&#125;&#125;</span><br><span class="line">	ErrorNotAuthUser = ErrResponse&#123;HttpSC: 401, Error: Err&#123;Error: <span class="string">"User authentication failed."</span>, ErrorCode: <span class="string">"002"</span>&#125;&#125;</span><br><span class="line">	ErrorDBError = ErrResponse&#123;HttpSC: 500, Error: Err&#123;Error: <span class="string">"DB ops failed"</span>, ErrorCode: <span class="string">"003"</span>&#125;&#125;</span><br><span class="line">	ErrorInternalFaults = ErrResponse&#123;HttpSC: 500, Error: Err&#123;Error: <span class="string">"Internal service error"</span>, ErrorCode: <span class="string">"004"</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="3-7"><a href="#3-7" class="headerlink" title="3-7"></a>3-7</h3><p>好好理解这里的数据库为什么这样设计</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table comments (</span><br><span class="line">	id varchar(64) not null,</span><br><span class="line">	video_id varchar(64),</span><br><span class="line">	author_id int(10),</span><br><span class="line">	content text,</span><br><span class="line">	time datetime default current_timestamp, primary key(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table sessions (</span><br><span class="line">	session_id tinytext not null,</span><br><span class="line">	TTL tinytext,</span><br><span class="line">	login_name text</span><br><span class="line">);</span><br><span class="line">alter table sessions add primary key (session_id(64));</span><br><span class="line"></span><br><span class="line">create table users (</span><br><span class="line">	id int unsigned not null auto_increment,</span><br><span class="line">	login_name varchar(64),</span><br><span class="line">	<span class="built_in">pwd</span> text not null,</span><br><span class="line">	unique key (login_name),</span><br><span class="line">	primary key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table video_del_rec (</span><br><span class="line">	video_id varchar(64) not null,</span><br><span class="line">	primary key (video_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table video_info (</span><br><span class="line">	id varchar(64) not null,</span><br><span class="line">	author_id int(10),</span><br><span class="line">	name text,</span><br><span class="line">	display_ctime text,</span><br><span class="line">	create_time datetime default current_timestamp,</span><br><span class="line">	primary key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p><code>第三范式(Third Normal Form,3rd NF)</code>就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。</p>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/sql-design.png" alt></p>
<h3 id="3-8"><a href="#3-8" class="headerlink" title="3-8"></a>3-8</h3><p>数据库连接还是参考自己写的这个吧<a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">demo</a>吧。</p>
<h3 id="3-10"><a href="#3-10" class="headerlink" title="3-10"></a>3-10</h3><p>api_test.go</p>
<p>参考<a href="https://samtake.github.io/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Golang练习笔记</a>23测试讲的更详细。</p>
<h3 id="3-12"><a href="#3-12" class="headerlink" title="3-12"></a>3-12</h3><p>实现和验证video<br><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/3-12.png" alt></p>
<h3 id="3-13"><a href="#3-13" class="headerlink" title="3-13"></a>3-13</h3><p>Comments</p>
<p> <img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/3-13-comments.png" alt><br>评论是需要列表出现的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func ListComments(vid string, from, to int) ([]*defs.Comment, error) &#123;</span><br><span class="line">	stmtOut, err := dbConn.Prepare(`SELECT comments.id, users.login_name, comments.content FROM comments </span><br><span class="line">		INNER JOIN users ON comments.author_id = users.id </span><br><span class="line">		WHERE comments.video_id = ? AND comments.time &gt; FROM_UNIXTIME(?) AND comments.time &lt;= FROM_UNIXTIME(?)</span><br><span class="line">		ORDER BY comments.time DESC`)</span><br><span class="line"></span><br><span class="line">	var res []*defs.Comment</span><br><span class="line">	</span><br><span class="line">	rows, err := stmtOut.Query(vid, from, to)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Printf(<span class="string">"%s"</span>, err)</span><br><span class="line">		<span class="built_in">return</span> res, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rows.<span class="function"><span class="title">Next</span></span>() &#123;</span><br><span class="line">		var id, name, content string</span><br><span class="line">		<span class="keyword">if</span> err := rows.Scan(&amp;id, &amp;name, &amp;content); err != nil &#123;</span><br><span class="line">			<span class="built_in">return</span> res, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c := &amp;defs.Comment&#123;Id: id, VideoId: vid, Author: name, Content: content&#125;</span><br><span class="line">		res = append(res, c)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer stmtOut.Close()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> res, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-15"><a href="#3-15" class="headerlink" title="3-15"></a>3-15</h3><p><code>session</code>会话，</p>
<p>session和cookie的区别？</p>
<p>session负责的流程图：<br><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/3-15-session.png" alt></p>
<h3 id="3-17"><a href="#3-17" class="headerlink" title="3-17"></a>3-17</h3><p>middleware</p>
<p>duck typing内容参考<a href="https://samtake.github.io/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Golang练习笔记</a>15。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> middleWareHandler struct &#123;</span><br><span class="line">	r *httprouter.Router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMiddleWareHandler(r *httprouter.Router) http.Handler &#123;</span><br><span class="line">	m := middleWareHandler&#123;&#125;</span><br><span class="line">	m.r = r</span><br><span class="line">	<span class="built_in">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m middleWareHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	//check session</span><br><span class="line">	validateUserSession(r)</span><br><span class="line"></span><br><span class="line">	m.r.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterHandlers() *httprouter.Router &#123;</span><br><span class="line">	router := httprouter.New()</span><br><span class="line">    router.POST(<span class="string">"/user"</span>, CreateUser)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//response</span><br><span class="line"><span class="built_in">type</span> SignedUp struct &#123;</span><br><span class="line">	Success bool `json:<span class="string">"success"</span>`</span><br><span class="line">	SessionId string `json:<span class="string">"session_id"</span>`</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#添了后缀，在使用时，会返回统一的json格式,如下：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"success"</span>:XXXXX,</span><br><span class="line">    <span class="string">"session_id"</span>:XXXX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4-1"></a>4-1</h3><p>Streaming（视频播放）：</p>
<ul>
<li>静态视频，非RTMP（直播的那些都是RTMP）</li>
<li>独立的服务，可独立部署</li>
<li>统一的api格式</li>
</ul>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4-3"></a>4-3</h3><p><code>流控</code><br><code>token bucket</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#共享通道 instead of shared memory</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ConnLimiter struct &#123;</span><br><span class="line">	concurrentConn int</span><br><span class="line">	bucket chan int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewConnLimiter(cc int) *ConnLimiter &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;ConnLimiter &#123;</span><br><span class="line">		concurrentConn: cc,</span><br><span class="line">		bucket: make(chan int, cc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cl *ConnLimiter) GetConn() bool &#123;</span><br><span class="line">	<span class="keyword">if</span> len(cl.bucket) &gt;= cl.concurrentConn &#123;</span><br><span class="line">		log.Printf(<span class="string">"Reached the rate limitation."</span>)</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cl.bucket &lt;- 1</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cl *ConnLimiter) <span class="function"><span class="title">ReleaseConn</span></span>() &#123;</span><br><span class="line">	c :=&lt;- cl.bucket</span><br><span class="line">	log.Printf(<span class="string">"New connction coming: %d"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5"><a href="#4-5" class="headerlink" title="4-5"></a>4-5</h3><p>在http middleware中嵌入流控</p>
<h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5-1"></a>5-1</h3><p><code>scheduler</code>任务调度器，某些不能马上处理的任务放到scheduler，让它定期或者延时触发。</p>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/5-1-scheduler.png" alt></p>
<h3 id="5-3"><a href="#5-3" class="headerlink" title="5-3"></a>5-3</h3><p>runner的生产消费者模型实现</p>
<h3 id="5-5"><a href="#5-5" class="headerlink" title="5-5"></a>5-5</h3><p>task</p>
<p>api-&gt;videoid-&gt;mysql<br>dispatcher-&gt;mysql-&gt;videoid-&gt;datachannel<br>executor-&gt;datachannel-&gt;videoid-&gt;delete video</p>
<h3 id="5-6"><a href="#5-6" class="headerlink" title="5-6"></a>5-6</h3><p>timer</p>
<p>setup-&gt;strat{runner task}</p>
<h3 id="5-7"><a href="#5-7" class="headerlink" title="5-7"></a>5-7</h3><p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/5-7-api.png" alt></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6-1"></a>6-1</h3><p>Go的模版引擎</p>
<ul>
<li>模版引擎是将html解析和元素预置替换生成最终页面的工具</li>
<li>Go的模版有两种text/template和html/template </li>
<li>Go的模版采用动态生成的模式</li>
</ul>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/6-1-html-template.png" alt></p>
<h3 id="6-2"><a href="#6-2" class="headerlink" title="6-2"></a>6-2</h3><p>前端代码架构<br><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/6-2-web-document.png" alt></p>
<p>client.go就是起了proxy转发作用，避免跨域作用。</p>
<h3 id="6-3"><a href="#6-3" class="headerlink" title="6-3"></a>6-3</h3><p>静态页面渲染</p>
<h3 id="6-4"><a href="#6-4" class="headerlink" title="6-4"></a>6-4</h3><p>sh build.sh</p>
<h3 id="6-6-api透传！！！"><a href="#6-6-api透传！！！" class="headerlink" title="6-6 api透传！！！"></a>6-6 api透传！！！</h3><h3 id="6-7-proxy转发"><a href="#6-7-proxy转发" class="headerlink" title="6-7 proxy转发"></a>6-7 proxy转发</h3><p><code>net/url</code>  </p>
<p><code>net/http/httputil</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func proxyVideoHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">	u, _ := url.Parse(<span class="string">"http://"</span> + config.GetLbAddr() + <span class="string">":9000/"</span>)</span><br><span class="line">	proxy := httputil.NewSingleHostReverseProxy(u)</span><br><span class="line">	proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func proxyUploadHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">	u, _ := url.Parse(<span class="string">"http://"</span> + config.GetLbAddr() + <span class="string">":9000/"</span>)</span><br><span class="line">	proxy := httputil.NewSingleHostReverseProxy(u)</span><br><span class="line">	proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-11"><a href="#6-11" class="headerlink" title="6-11"></a>6-11</h3><p>js</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="7-4"><a href="#7-4" class="headerlink" title="7-4"></a>7-4</h3><p>公共配置，即各模块的config文件。</p>
<h3 id="7-5-vendor"><a href="#7-5-vendor" class="headerlink" title="7-5  vendor"></a>7-5  vendor</h3><h3 id="7-6-SLB讲解与配置"><a href="#7-6-SLB讲解与配置" class="headerlink" title="7-6 SLB讲解与配置"></a>7-6 SLB讲解与配置</h3><p>阿里云负载均衡配置。</p>
<h3 id="7-7"><a href="#7-7" class="headerlink" title="7-7"></a>7-7</h3><p>session容错</p>
<h3 id="7-8-ECS配置"><a href="#7-8-ECS配置" class="headerlink" title="7-8 ECS配置"></a>7-8 ECS配置</h3><h3 id="7-10-部署脚本"><a href="#7-10-部署脚本" class="headerlink" title="7-10 部署脚本"></a>7-10 部署脚本</h3><p>在bin文件夹添加conf.json文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"lb_addr"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">	<span class="string">"oss_addr"</span>: <span class="string">"oss.aliyun.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>buildprod.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build web and other services</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/api</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/api</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/scheduler</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/scheduler</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/streamserver</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/streamserver</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/web</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/web</span><br></pre></td></tr></table></figure>


<p><code>deploy.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">cp -R ./templates ./bin/</span><br><span class="line"></span><br><span class="line">mkdir ./bin/videos</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"></span><br><span class="line">nohup ./api &amp;</span><br><span class="line">nohup ./scheduler &amp;</span><br><span class="line">nohup ./streamserver &amp;</span><br><span class="line">nohup ./web &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deploy finished"</span></span><br></pre></td></tr></table></figure>


<h3 id="7-11-部署"><a href="#7-11-部署" class="headerlink" title="7-11 部署"></a>7-11 部署</h3><p>sh  buildprod.sh 编译完成后提交二进制文件。或者提交代码到服务器上直接编译</p>
<p>检查对应server是否启动<code>ps aux | grep &lt;api?stream?scheduler?web&gt;</code></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Traefik</title>
    <url>/2020/02/19/Traefik/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>相对nginx，基于容器的微服务反向代理利器<a href="https://github.com/containous/traefik" target="_blank" rel="noopener">Traefik</a>支持动态的配置反向代理.</p>
<p><img src="/2020/02/19/Traefik/traefik-architecture.png" alt></p>
<p>如上图左侧公网域名可以通过Traefik监听API动态地转发到右侧的内网服务实例（例如backoffice1服务）。或者说是动态的路由转发。</p>
<p><code>frontend</code>用于控制访问的路由规则，支持单个规则及正则匹配。<br><code>backend</code>用于匹配一组服务实例，通过轮询方式来选择转发的目标。</p>
<h3 id="基于Docker-compose与Traefik1-x的容器化部署"><a href="#基于Docker-compose与Traefik1-x的容器化部署" class="headerlink" title="基于Docker-compose与Traefik1.x的容器化部署"></a>基于Docker-compose与Traefik1.x的容器化部署</h3><p>具体参考service_dc和traefik_dc<br><img src="/2020/02/19/Traefik/Traefik-setting.png" alt></p>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p>|<br>暂<br>|<br>无<br>|</p>
]]></content>
      <categories>
        <category>Traefik</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Traefik</tag>
      </tags>
  </entry>
  <entry>
    <title>go-micro</title>
    <url>/2020/02/19/go-micro/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>项目地址：<a href="https://github.com/micro/go-micro" target="_blank" rel="noopener">go-micro</a></p>
<p>go-micro提供的接口功能</p>
<p><code>服务发现</code>支持服务注册与发现，底层支持etcd、consul、k8s<br><code>负载均衡</code>rpc服务间的请求调度均衡策略<br><code>同步通信</code>基于RPC通信，支持单向、双向流通道模式<br><code>一步通信</code>提供pub、sub通信模型的接口<br><code>高级接口</code>比如服务发现，提供调用的接口是一致的</p>
<p><img src="/2020/02/19/go-micro/go-micro.png" alt></p>
<p><code>broker</code>异步通信<br><code>codec</code>消息编码，可以动态编码<br><code>registry</code>服务注册与发现<br><code>selector</code>负载均衡<br><code>transport</code> 基于RPC的通信模块接口</p>
<h3 id="账号系统微服务"><a href="#账号系统微服务" class="headerlink" title="账号系统微服务"></a>账号系统微服务</h3><p>新建一个文件<code>XXX.proto</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">package go.micro.service.user;</span><br><span class="line"></span><br><span class="line">service UserService &#123;</span><br><span class="line">    // 用户注册</span><br><span class="line">    rpc Signup(ReqSignup) returns (RespSignup) &#123;&#125;</span><br><span class="line">    // 用户登录</span><br><span class="line">    rpc Signin(ReqSignin) returns (RespSignin) &#123;&#125;</span><br><span class="line">    // 获取用户信息</span><br><span class="line">    rpc UserInfo(ReqUserInfo) returns (RespUserInfo) &#123;&#125;</span><br><span class="line">    // 获取用户文件</span><br><span class="line">    rpc UserFiles(ReqUserFile) returns (RespUserFile) &#123;&#125;</span><br><span class="line">   // 获取用户文件</span><br><span class="line">    rpc UserFileRename(ReqUserFileRename) returns (RespUserFileRename) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqSignup &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    string password = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespSignup &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string message = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqSignin &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    string password = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespSignin &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string token = 2;</span><br><span class="line">    string message = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqUserInfo &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespUserInfo &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string message =2;</span><br><span class="line">    string username =3;</span><br><span class="line">    string email = 4;</span><br><span class="line">    string phone = 5;</span><br><span class="line">    string signupAt = 6;</span><br><span class="line">    string lastActiveAt = 7;</span><br><span class="line">    int32 status = 8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqUserFile &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    int32 <span class="built_in">limit</span> = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespUserFile &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string message =2;</span><br><span class="line">    bytes fileData = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqUserFileRename &#123;</span><br><span class="line">  string username = 1;</span><br><span class="line">  string filehash = 2;</span><br><span class="line">  string newFileName = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespUserFileRename &#123;</span><br><span class="line">  int32 code = 1;</span><br><span class="line">  string message =2;</span><br><span class="line">  bytes fileData = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protoc --proto_path=service/account/proto --go_out=service/account/proto --micro_out=service/account/proto service/account/proto/user.proto</span><br></pre></td></tr></table></figure>

<p>这时候会生成两个文件<br><code>XXX.micro.go</code>以及<code>XXX.pb.go</code></p>
<p>handler调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package handler</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"filestore-server/common"</span></span><br><span class="line">	<span class="string">"filestore-server/config"</span></span><br><span class="line">	cfg <span class="string">"filestore-server/config"</span></span><br><span class="line">	proto <span class="string">"filestore-server/service/account/proto"</span></span><br><span class="line">	dbcli <span class="string">"filestore-server/service/dbproxy/client"</span></span><br><span class="line">	<span class="string">"filestore-server/util"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// User : 用于实现UserServiceHandler接口的对象</span><br><span class="line"><span class="built_in">type</span> User struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// GenToken : 生成token</span><br><span class="line">func GenToken(username string) string &#123;</span><br><span class="line">	// 40位字符:md5(username+timestamp+token_salt)+timestamp[:8]</span><br><span class="line">	ts := fmt.Sprintf(<span class="string">"%x"</span>, time.Now().Unix())</span><br><span class="line">	tokenPrefix := util.MD5([]byte(username + ts + <span class="string">"_tokensalt"</span>))</span><br><span class="line">	<span class="built_in">return</span> tokenPrefix + ts[:8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Signup : 处理用户注册请求</span><br><span class="line">func (u *User) Signup(ctx context.Context, req *proto.ReqSignup, res *proto.RespSignup) error &#123;</span><br><span class="line">	username := req.Username</span><br><span class="line">	passwd := req.Password</span><br><span class="line"></span><br><span class="line">	// 参数简单校验</span><br><span class="line">	<span class="keyword">if</span> len(username) &lt; 3 || len(passwd) &lt; 5 &#123;</span><br><span class="line">		res.Code = common.StatusParamInvalid</span><br><span class="line">		res.Message = <span class="string">"注册参数无效"</span></span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 对密码进行加盐及取Sha1值加密</span><br><span class="line">	encPasswd := util.Sha1([]byte(passwd + cfg.PasswordSalt))</span><br><span class="line">	// 将用户信息注册到用户表中</span><br><span class="line">	dbResp, err := dbcli.UserSignup(username, encPasswd)</span><br><span class="line">	<span class="keyword">if</span> err == nil &amp;&amp; dbResp.Suc &#123;</span><br><span class="line">		res.Code = common.StatusOK</span><br><span class="line">		res.Message = <span class="string">"注册成功"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		res.Code = common.StatusRegisterFailed</span><br><span class="line">		res.Message = <span class="string">"注册失败"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Signin : 处理用户登录请求</span><br><span class="line">func (u *User) Signin(ctx context.Context, req *proto.ReqSignin, res *proto.RespSignin) error &#123;</span><br><span class="line">	username := req.Username</span><br><span class="line">	password := req.Password</span><br><span class="line"></span><br><span class="line">	encPasswd := util.Sha1([]byte(password + config.PasswordSalt))</span><br><span class="line"></span><br><span class="line">	// 1. 校验用户名及密码</span><br><span class="line">	dbResp, err := dbcli.UserSignin(username, encPasswd)</span><br><span class="line">	<span class="keyword">if</span> err != nil || !dbResp.Suc &#123;</span><br><span class="line">		res.Code = common.StatusLoginFailed</span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 2. 生成访问凭证(token)</span><br><span class="line">	token := GenToken(username)</span><br><span class="line">	upRes, err := dbcli.UpdateToken(username, token)</span><br><span class="line">	<span class="keyword">if</span> err != nil || !upRes.Suc &#123;</span><br><span class="line">		res.Code = common.StatusServerError</span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 3. 登录成功, 返回token</span><br><span class="line">	res.Code = common.StatusOK</span><br><span class="line">	res.Token = token</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserInfo ： 查询用户信息</span><br><span class="line">func (u *User) UserInfo(ctx context.Context, req *proto.ReqUserInfo, res *proto.RespUserInfo) error &#123;</span><br><span class="line">	// 查询用户信息</span><br><span class="line">	dbResp, err := dbcli.GetUserInfo(req.Username)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		res.Code = common.StatusServerError</span><br><span class="line">		res.Message = <span class="string">"服务错误"</span></span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	// 查不到对应的用户信息</span><br><span class="line">	<span class="keyword">if</span> !dbResp.Suc &#123;</span><br><span class="line">		res.Code = common.StatusUserNotExists</span><br><span class="line">		res.Message = <span class="string">"用户不存在"</span></span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	user := dbcli.ToTableUser(dbResp.Data)</span><br><span class="line"></span><br><span class="line">	// 3. 组装并且响应用户数据</span><br><span class="line">	res.Code = common.StatusOK</span><br><span class="line">	res.Username = user.Username</span><br><span class="line">	res.SignupAt = user.SignupAt</span><br><span class="line">	res.LastActiveAt = user.LastActiveAt</span><br><span class="line">	res.Status = int32(user.Status)</span><br><span class="line">	// TODO: 需增加接口支持完善用户信息(email/phone等)</span><br><span class="line">	res.Email = user.Email</span><br><span class="line">	res.Phone = user.Phone</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个main.go作为单独的微服务启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/micro/go-micro"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"filestore-server/service/account/handler"</span></span><br><span class="line">	proto <span class="string">"filestore-server/service/account/proto"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    //创建一个service</span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		// service := k8s.NewService(</span><br><span class="line">		micro.Name(<span class="string">"go.micro.service.user"</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	// 初始化service, 解析命令行参数等</span><br><span class="line">	service.Init()</span><br><span class="line"></span><br><span class="line">	// 初始化dbproxy client</span><br><span class="line">	dbproxy.Init(service)</span><br><span class="line"></span><br><span class="line">	proto.RegisterUserServiceHandler(service.Server(), new(handler.User))</span><br><span class="line">	<span class="keyword">if</span> err := service.Run(); err != nil &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>go run service/account/main.go --registry=consul</code>指定注册中心为consul</p>
<p>打开浏览器，访问consul的web界面:<br><a href="localhost:8500/ui/dcl/services" target="_blank" rel="noopener">localhost:8500/ui/dcl/services</a></p>
<h3 id="网关微服务"><a href="#网关微服务" class="headerlink" title="网关微服务"></a>网关微服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package handler</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"filestore-server/common"</span></span><br><span class="line">	<span class="string">"filestore-server/util"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	micro <span class="string">"github.com/micro/go-micro"</span></span><br><span class="line"></span><br><span class="line">	cmn <span class="string">"filestore-server/common"</span></span><br><span class="line">	userProto <span class="string">"filestore-server/service/account/proto"</span></span><br><span class="line">	dlProto <span class="string">"filestore-server/service/download/proto"</span></span><br><span class="line">	upProto <span class="string">"filestore-server/service/upload/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	userCli userProto.UserService</span><br><span class="line">	upCli   upProto.UploadService</span><br><span class="line">	dlCli   dlProto.DownloadService</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	service := micro.NewService()</span><br><span class="line">	// 初始化， 解析命令行参数等</span><br><span class="line">	service.Init()</span><br><span class="line"></span><br><span class="line">	// 初始化一个account服务的客户端</span><br><span class="line">	userCli = userProto.NewUserService(<span class="string">"go.micro.service.user"</span>, service.Client())</span><br><span class="line">	// 初始化一个upload服务的客户端</span><br><span class="line">	upCli = upProto.NewUploadService(<span class="string">"go.micro.service.upload"</span>, service.Client())</span><br><span class="line">	// 初始化一个download服务的客户端</span><br><span class="line">	dlCli = dlProto.NewDownloadService(<span class="string">"go.micro.service.download"</span>, service.Client())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SignupHandler : 响应注册页面</span><br><span class="line">func SignupHandler(c *gin.Context) &#123;</span><br><span class="line">	c.Redirect(http.StatusFound, <span class="string">"/static/view/signup.html"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DoSignupHandler : 处理注册post请求</span><br><span class="line">func DoSignupHandler(c *gin.Context) &#123;</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line">	passwd := c.Request.FormValue(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">	resp, err := userCli.Signup(context.TODO(), &amp;userProto.ReqSignup&#123;</span><br><span class="line">		Username: username,</span><br><span class="line">		Password: passwd,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		c.Status(http.StatusInternalServerError)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">"code"</span>: resp.Code,</span><br><span class="line">		<span class="string">"msg"</span>:  resp.Message,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SigninHandler : 响应登录页面</span><br><span class="line">func SigninHandler(c *gin.Context) &#123;</span><br><span class="line">	c.Redirect(http.StatusFound, <span class="string">"/static/view/signin.html"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DoSigninHandler : 处理登录post请求</span><br><span class="line">func DoSigninHandler(c *gin.Context) &#123;</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line">	password := c.Request.FormValue(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">	rpcResp, err := userCli.Signin(context.TODO(), &amp;userProto.ReqSignin&#123;</span><br><span class="line">		Username: username,</span><br><span class="line">		Password: password,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		c.Status(http.StatusInternalServerError)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rpcResp.Code != cmn.StatusOK &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"msg"</span>:  <span class="string">"登录失败"</span>,</span><br><span class="line">			<span class="string">"code"</span>: rpcResp.Code,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 动态获取上传入口地址</span><br><span class="line">	upEntryResp, err := upCli.UploadEntry(context.TODO(), &amp;upProto.ReqEntry&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> upEntryResp.Code != cmn.StatusOK &#123;</span><br><span class="line">		log.Println(upEntryResp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 动态获取下载入口地址</span><br><span class="line">	dlEntryResp, err := dlCli.DownloadEntry(context.TODO(), &amp;dlProto.ReqEntry&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> dlEntryResp.Code != cmn.StatusOK &#123;</span><br><span class="line">		log.Println(dlEntryResp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 登录成功，返回用户信息</span><br><span class="line">	cliResp := util.RespMsg&#123;</span><br><span class="line">		Code: int(common.StatusOK),</span><br><span class="line">		Msg:  <span class="string">"登录成功"</span>,</span><br><span class="line">		Data: struct &#123;</span><br><span class="line">			Location      string</span><br><span class="line">			Username      string</span><br><span class="line">			Token         string</span><br><span class="line">			UploadEntry   string</span><br><span class="line">			DownloadEntry string</span><br><span class="line">		&#125;&#123;</span><br><span class="line">			Location:      <span class="string">"/static/view/home.html"</span>,</span><br><span class="line">			Username:      username,</span><br><span class="line">			Token:         rpcResp.Token,</span><br><span class="line">			UploadEntry:   upEntryResp.Entry,</span><br><span class="line">			DownloadEntry: dlEntryResp.Entry,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	c.Data(http.StatusOK, <span class="string">"application/json"</span>, cliResp.JSONBytes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserInfoHandler ： 查询用户信息</span><br><span class="line">func UserInfoHandler(c *gin.Context) &#123;</span><br><span class="line">	// 1. 解析请求参数</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line"></span><br><span class="line">	resp, err := userCli.UserInfo(context.TODO(), &amp;userProto.ReqUserInfo&#123;</span><br><span class="line">		Username: username,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		c.Status(http.StatusInternalServerError)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 3. 组装并且响应用户数据</span><br><span class="line">	cliResp := util.RespMsg&#123;</span><br><span class="line">		Code: 0,</span><br><span class="line">		Msg:  <span class="string">"OK"</span>,</span><br><span class="line">		Data: gin.H&#123;</span><br><span class="line">			<span class="string">"Username"</span>: username,</span><br><span class="line">			<span class="string">"SignupAt"</span>: resp.SignupAt,</span><br><span class="line">			// TODO: 完善其他字段信息</span><br><span class="line">			<span class="string">"LastActive"</span>: resp.LastActiveAt,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	c.Data(http.StatusOK, <span class="string">"application/json"</span>, cliResp.JSONBytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package route</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"filestore-server/service/apigw/handler"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Router : 网关api路由</span><br><span class="line">func Router() *gin.Engine &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.Static(<span class="string">"/static/"</span>, <span class="string">"./static"</span>)</span><br><span class="line"></span><br><span class="line">	// 注册</span><br><span class="line">	router.GET(<span class="string">"/user/signup"</span>, handler.SignupHandler)</span><br><span class="line">	router.POST(<span class="string">"/user/signup"</span>, handler.DoSignupHandler)</span><br><span class="line">	// 登录</span><br><span class="line">	router.GET(<span class="string">"/user/signin"</span>, handler.SigninHandler)</span><br><span class="line">	router.POST(<span class="string">"/user/signin"</span>, handler.DoSigninHandler)</span><br><span class="line">	// 用户查询</span><br><span class="line">	router.POST(<span class="string">"/user/info"</span>, handler.UserInfoHandler)</span><br><span class="line"></span><br><span class="line">	// 用户文件查询</span><br><span class="line">	router.POST(<span class="string">"/file/query"</span>, handler.FileQueryHandler)</span><br><span class="line">	// 用户文件修改(重命名)</span><br><span class="line">	router.POST(<span class="string">"/file/update"</span>, handler.FileMetaUpdateHandler)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.go</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"filestore-server/service/apigw/route"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := route.Router()</span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行<code>go run service/apigw/main.go --registry=consul</code>指定注册中心为consul</p>
<h3 id="文件上传微服务"><a href="#文件上传微服务" class="headerlink" title="文件上传微服务"></a>文件上传微服务</h3><p>文件上传需要用到RPC微服务间通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package rpc</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	cfg <span class="string">"filestore-server/service/upload/config"</span></span><br><span class="line">	upProto <span class="string">"filestore-server/service/upload/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Upload : upload结构体</span><br><span class="line"><span class="built_in">type</span> Upload struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// UploadEntry : 获取上传入口</span><br><span class="line">func (u *Upload) UploadEntry(</span><br><span class="line">	ctx context.Context,</span><br><span class="line">	req *upProto.ReqEntry,</span><br><span class="line">	res *upProto.RespEntry) error &#123;</span><br><span class="line"></span><br><span class="line">	res.Entry = cfg.UploadEntry</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	micro <span class="string">"github.com/micro/go-micro"</span></span><br><span class="line"></span><br><span class="line">	cfg <span class="string">"filestore-server/service/upload/config"</span></span><br><span class="line">	upProto <span class="string">"filestore-server/service/upload/proto"</span></span><br><span class="line">	<span class="string">"filestore-server/service/upload/route"</span></span><br><span class="line">	upRpc <span class="string">"filestore-server/service/upload/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">startRpcService</span></span>() &#123;</span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">"go.micro.service.upload"</span>), // 服务名称</span><br><span class="line">		micro.RegisterTTL(time.Second*10),     // TTL指定从上一次心跳间隔起，超过这个时间服务会被服务发现移除</span><br><span class="line">		micro.RegisterInterval(time.Second*5), // 让服务在指定时间内重新注册，保持TTL获取的注册时间有效</span><br><span class="line">	)</span><br><span class="line">	service.Init()</span><br><span class="line"></span><br><span class="line">	upProto.RegisterUploadServiceHandler(service.Server(), new(upRpc.Upload))</span><br><span class="line">	<span class="keyword">if</span> err := service.Run(); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">startApiService</span></span>() &#123;</span><br><span class="line">	router := route.Router()</span><br><span class="line">	router.Run(cfg.UploadServiceHost)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	// api 服务</span><br><span class="line">	go startApiService()</span><br><span class="line"></span><br><span class="line">	// rpc 服务</span><br><span class="line">	startRpcService()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="通过shell脚本启动整个项目的微服务-service-start-all-sh-根据实际情况修改所需要的文件目录"><a href="#通过shell脚本启动整个项目的微服务-service-start-all-sh-根据实际情况修改所需要的文件目录" class="headerlink" title="通过shell脚本启动整个项目的微服务./service/start-all.sh(根据实际情况修改所需要的文件目录)"></a>通过shell脚本启动整个项目的微服务<code>./service/start-all.sh</code>(根据实际情况修改所需要的文件目录)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查service进程</span></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    sleep 1</span><br><span class="line">    res=`ps aux | grep -v grep | grep <span class="string">"service/bin"</span> | grep <span class="variable">$1</span>`</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$res</span> != <span class="string">''</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"\033[32m 已启动 \033[0m"</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"\033[31m 启动失败 \033[0m"</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译service可执行文件</span></span><br><span class="line"><span class="function"><span class="title">build_service</span></span>() &#123;</span><br><span class="line">    go build -o service/bin/<span class="variable">$1</span> service/<span class="variable">$1</span>/main.go</span><br><span class="line">    resbin=`ls service/bin/ | grep <span class="variable">$1</span>`</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\033[32m 编译完成: \033[0m service/bin/<span class="variable">$resbin</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动service</span></span><br><span class="line"><span class="function"><span class="title">run_service</span></span>() &#123;</span><br><span class="line">    nohup ./service/bin/<span class="variable">$1</span> --registry=consul &gt;&gt; <span class="variable">$logpath</span>/<span class="variable">$1</span>.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line">    sleep 1</span><br><span class="line">    check_process <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建运行日志目录</span></span><br><span class="line">logpath=/Users/samtake/Documents/GitHub/www/data/<span class="built_in">log</span>/filestore-server <span class="comment">#/data/log/filestore-server</span></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$logpath</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到工程根目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/filestore-server</span><br><span class="line"><span class="comment">#cd /data/go/work/src/filestore-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微服务可以用supervisor做进程管理工具；</span></span><br><span class="line"><span class="comment"># 或者也可以通过docker/k8s进行部署</span></span><br><span class="line"></span><br><span class="line">services=<span class="string">"</span></span><br><span class="line"><span class="string">dbproxy</span></span><br><span class="line"><span class="string">upload</span></span><br><span class="line"><span class="string">download</span></span><br><span class="line"><span class="string">transfer</span></span><br><span class="line"><span class="string">account</span></span><br><span class="line"><span class="string">apigw</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行编译service</span></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> <span class="variable">$services</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    build_service <span class="variable">$service</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行启动service</span></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> <span class="variable">$services</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    run_service <span class="variable">$service</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'微服务启动完毕.'</span></span><br></pre></td></tr></table></figure>



<h3 id="go-micro学习资料"><a href="#go-micro学习资料" class="headerlink" title="go-micro学习资料"></a><code>go-micro</code>学习资料</h3><p>Go-Micro 基础篇 【1】Hello World:<a href="https://www.bilibili.com/video/av75269275?from=search&seid=13701687009895043479" target="_blank" rel="noopener">视频</a> &amp; <a href="https://github.com/micro-in-cn/learning-videos/blob/master/docs/hello-world/doc.md" target="_blank" rel="noopener">文档</a></p>
<p>#72 Go-Micro 编写微服务实战: <a href="https://www.bilibili.com/video/av79892065?from=search&seid=13701687009895043479" target="_blank" rel="noopener">视频地址</a></p>
<p><a href="https://github.com/micro-in-cn" target="_blank" rel="noopener">Micro 中国站</a></p>
<p><a href="https://www.bilibili.com/video/BV18E411o7c5" target="_blank" rel="noopener">#62 Go-Micro 微服务框架介绍（一） by 舒先 【 Go 夜读 】</a></p>
<p><a href="https://www.bilibili.com/video/BV1fJ411t7gg" target="_blank" rel="noopener">#72 Go-Micro 编写微服务实战 【 Go 夜读 】</a></p>
<p><a href="https://www.bilibili.com/video/BV1VE41157LP" target="_blank" rel="noopener">#79 Go-Micro 运行时工具集 【 Go 夜读 】</a></p>
]]></content>
      <categories>
        <category>微服务</category>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云OSS</title>
    <url>/2020/02/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    <content><![CDATA[<p><a href="https://help.aliyun.com/document_detail/31947.html?spm=a2c4g.11174283.6.1505.42967da2nUG4r7" target="_blank" rel="noopener">对象存储OSS</a></p>
<p><a href="https://help.aliyun.com/document_detail/87712.html?spm=a2c4g.11186623.6.890.7b7f3bdb5LHLCm" target="_blank" rel="noopener">SDK go 版本</a></p>
]]></content>
      <categories>
        <category>OSS</category>
      </categories>
      <tags>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang操作MySQL</title>
    <url>/2020/02/16/Golang%E6%93%8D%E4%BD%9CMySQL/</url>
    <content><![CDATA[<p>记录一个报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  goRedisDemo git:(master) ✗ go run main.go</span><br><span class="line"><span class="built_in">test</span> mySQL </span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x20 pc=0x10c1141]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">sync.(*Mutex).Lock(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/sync/mutex.go:74</span><br><span class="line">database/sql.(*DB).conn(0x0, 0x130f9e0, 0xc000018080, 0x1036801, 0xc000000180, 0x300000002, 0xc000000180)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1132 +0x41</span><br><span class="line">database/sql.(*DB).prepare(0x0, 0x130f9e0, 0xc000018080, 0x12c9f84, 0x69, 0x102da01, 0x203000, 0xc0000b3d78, 0xc0000b3d68)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1431 +0x58</span><br><span class="line">database/sql.(*DB).PrepareContext(0x0, 0x130f9e0, 0xc000018080, 0x12c9f84, 0x69, 0x30, 0x30, 0x128eaa0)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1404 +0x99</span><br><span class="line">database/sql.(*DB).Prepare(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1421</span><br><span class="line">goRedisDemo/db.OnFileUploadFinished(0x12bbb58, 0x8, 0x12bbb60, 0x8, 0x0, 0x0, 0x0, 0x0)</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/db/file.go:15 +0x77</span><br><span class="line">goRedisDemo/handler.UploadHandlerDB()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/handler/testDB.go:10 +0x76</span><br><span class="line">main.main()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/main.go:14 +0x7a</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br><span class="line">➜  goRedisDemo git:(master) ✗ go get database/sql</span><br><span class="line">➜  goRedisDemo git:(master) ✗ go get github.com/go-sql-driver/mysql</span><br><span class="line">➜  goRedisDemo git:(master) ✗ go run main.go                       </span><br><span class="line"><span class="built_in">test</span> mySQL </span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x20 pc=0x10c1141]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">sync.(*Mutex).Lock(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/sync/mutex.go:74</span><br><span class="line">database/sql.(*DB).conn(0x0, 0x130f9e0, 0xc0000b0008, 0x1036801, 0xc000000180, 0x300000002, 0xc000000180)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1132 +0x41</span><br><span class="line">database/sql.(*DB).prepare(0x0, 0x130f9e0, 0xc0000b0008, 0x12c9f84, 0x69, 0x102da01, 0x203000, 0xc0000dfd78, 0xc0000dfd68)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1431 +0x58</span><br><span class="line">database/sql.(*DB).PrepareContext(0x0, 0x130f9e0, 0xc0000b0008, 0x12c9f84, 0x69, 0x30, 0x30, 0x128eaa0)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1404 +0x99</span><br><span class="line">database/sql.(*DB).Prepare(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1421</span><br><span class="line">goRedisDemo/db.OnFileUploadFinished(0x12bbb58, 0x8, 0x12bbb60, 0x8, 0x0, 0x0, 0x0, 0x0)</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/db/file.go:22 +0x77</span><br><span class="line">goRedisDemo/handler.UploadHandlerDB()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/handler/testDB.go:10 +0x76</span><br><span class="line">main.main()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/main.go:14 +0x7a</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.51cto.com/zhixinhu/1844734" target="_blank" rel="noopener">查了一下，原来这是Db变量定义的问题，:=只在当前方法内有效。</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile</title>
    <url>/2020/02/15/Dockerfile/</url>
    <content><![CDATA[<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h3 id="主要指令"><a href="#主要指令" class="headerlink" title="主要指令"></a>主要指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>定制的镜像都是基于 FROM 的镜像，例如nginx</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定下面的shell语句指定运行在哪个路径下</td>
</tr>
<tr>
<td>COPY</td>
<td>将宿主机下的目录文件复制到镜像中去</td>
</tr>
<tr>
<td>RUN</td>
<td>执行后面跟着的命令行命令</td>
</tr>
<tr>
<td>CMD</td>
<td>指定整个镜像运行起来后执行的脚本 (一般都是阻塞式的脚本)</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY src/  /app</span><br><span class="line">RUN <span class="built_in">echo</span> 321 &gt;&gt; 1.txt</span><br><span class="line">CMD tail -f 1.txt</span><br></pre></td></tr></table></figure>

<h3 id="COPY-vs-ADD"><a href="#COPY-vs-ADD" class="headerlink" title="COPY vs ADD"></a>COPY vs ADD</h3><p>两者功能差不多，但是ADD的源文件除了是本地文件资源，还可以是一个url</p>
<h3 id="CMD-vs-ENTRYPOINT"><a href="#CMD-vs-ENTRYPOINT" class="headerlink" title="CMD vs ENTRYPOINT"></a>CMD vs ENTRYPOINT</h3><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>
<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
<p>在 Dockerfile 文件的存放目录下，通过<code>docker build -t &lt;镜像名&gt;:&lt;版本号&gt;</code>命令来执行。</p>
<h4 id="当两者混用时"><a href="#当两者混用时" class="headerlink" title="当两者混用时"></a>当两者混用时</h4><ul>
<li>entrypoint非json，则以entrypoint为准。</li>
<li>如果entrypoint和cmd都是json，则以entrypoint+cmd拼接成的shell为准。</li>
</ul>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>expose仅仅只是声明端口。</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>标识（没实际作用）</p>
<h3 id="onbuild"><a href="#onbuild" class="headerlink" title="onbuild"></a>onbuild</h3><p><code>onbuild env C = 10</code></p>
<p>在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build </p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener">Dockerfile</a><br><a href="https://www.bilibili.com/video/av85895204?from=search&seid=4835159816508980526" target="_blank" rel="noopener">Dockerfile用法全解析</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Compose</title>
    <url>/2020/02/15/Docker-Compose/</url>
    <content><![CDATA[<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Mac 用户不需要单独安装 Compose，因为Docker 桌面版已经包含</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blogs docker-compose --version</span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br></pre></td></tr></table></figure>

<p>Compose 使用的三个步骤：</p>
<p>1.通过Dockerfile定义容器环境，打包成镜像</p>
<p>2.通过docker-compose.yml定义各应用服务</p>
<p>3.通过docker-compose up命令来启动所有容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">   - <span class="string">"5000:5000"</span></span><br><span class="line">    volumes:</span><br><span class="line">   - .:/code</span><br><span class="line">    - logvolume01:/var/<span class="built_in">log</span></span><br><span class="line">    links:</span><br><span class="line">   - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">Docker Compose</a><br><a href="https://www.bilibili.com/video/av61131351?from=search&seid=5421358312704070453" target="_blank" rel="noopener">实战~如何组织一个多容器项目docker-compose</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2020/02/14/RPC/</url>
    <content><![CDATA[<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><img src="/2020/02/14/RPC/RPC.png" alt></p>
<h3 id="RPC与Restful接口的调用"><a href="#RPC与Restful接口的调用" class="headerlink" title="RPC与Restful接口的调用"></a>RPC与Restful接口的调用</h3><p>不关心调用方式，通过网络传输<br>RPC相对高效，http接口相对灵活 </p>
<p>restful接口更适合终端与服务端之间的交互，rpc更适合微服务的应用间通讯</p>
<h3 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h3><p>ProtoBuf是一种跨语言和跨平台的数据序列化协议；<br>与XML/JSON相比，序列化效率更快、体积更小、更安全；<br>与XML/JSON相比，可读性差、灵活性较低；<br>自带编译器，定义proto源文件，可编译成多种语言的代码；</p>
<h3 id="gRPC框架"><a href="#gRPC框架" class="headerlink" title="gRPC框架"></a>gRPC框架</h3><p><img src="/2020/02/14/RPC/gRPC.jpeg" alt></p>
<h3 id="框架go-micro"><a href="#框架go-micro" class="headerlink" title="框架go-micro"></a>框架go-micro</h3><p>专注于微服务的一种RPC框架；<br>提供分布式系统相关的接口集合；</p>
<p>服务发现：支持服务注册与发现</p>
<p>负载均衡：rpc服务间的请求调度均衡策略</p>
<p>同步通信：基于RPC通信，支持单项、双向流通信模式</p>
<p>异步通信：提供pub\sub通信模型的接口</p>
<p>高级接口：比如服务发现，提供调用的接口是一致的</p>
<p><img src="/2020/02/14/RPC/goMicro.png" alt></p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin基本了解</title>
    <url>/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>学习资料:<br><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin项目地址</a><br><a href="https://gin-gonic.com/zh-cn/" target="_blank" rel="noopener">gin中文文档</a><br><a href="https://www.imooc.com/learn/1175" target="_blank" rel="noopener">Gin入门实战</a><br><a href="https://github.com/samtake/gin-demo" target="_blank" rel="noopener">文中demo</a></p>
<h2 id="Gin运行流程"><a href="#Gin运行流程" class="headerlink" title="Gin运行流程"></a>Gin运行流程</h2><p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/gin.png" alt></p>
<p><code>engine</code>:实现了ServeHTTP接口的handler<br><code>methodTree</code>:根据http请求方法分别维护的路由树<br><code>routerGroup</code>:将路由表分组，方便中间件统一处理<br><code>Context</code>:Gin的上下文，在handler之间传递参数</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>Router ：路由规则定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	hdl <span class="string">"filestore-server/handler"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Router ：路由规则定义</span><br><span class="line">func Router() *gin.Engine &#123;</span><br><span class="line">	// gin framework</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	// 静态资源处理</span><br><span class="line">	router.Static(<span class="string">"/static/"</span>, <span class="string">"./static"</span>)</span><br><span class="line"></span><br><span class="line">	// 定义接口</span><br><span class="line">	router.GET(<span class="string">"/user/signup"</span>, hdl.SignupHandler)</span><br><span class="line">    router.POST(<span class="string">"/user/signup"</span>, hdl.DoSignupHandler)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>handler</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// SignupHandler : 处理用户注册请求</span><br><span class="line">func SignupHandler(c *gin.Context) &#123;</span><br><span class="line">	c.Redirect(http.StatusFound, <span class="string">"http://"</span>+c.Request.Host+<span class="string">"/static/view/signup.html"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// DoSignupHandler : 处理用户注册请求</span><br><span class="line">func DoSignupHandler(c *gin.Context) &#123;</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line">	passwd := c.Request.FormValue(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> len(username) &lt; 3 || len(passwd) &lt; 5 &#123;</span><br><span class="line">		c.JSON(http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">"msg"</span>: <span class="string">"Invalid parameter"</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 对密码进行加盐及取Sha1值加密</span><br><span class="line">	encPasswd := util.Sha1([]byte(passwd + pwdSalt))</span><br><span class="line">	// 将用户信息注册到用户表中</span><br><span class="line">	suc := dblayer.UserSignup(username, encPasswd)</span><br><span class="line">	<span class="keyword">if</span> suc &#123;</span><br><span class="line">		c.JSON(http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">"code"</span>:    0,</span><br><span class="line">				<span class="string">"msg"</span>:     <span class="string">"注册成功"</span>,</span><br><span class="line">				<span class="string">"data"</span>:    nil,</span><br><span class="line">				<span class="string">"forward"</span>: <span class="string">"/user/signin"</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">"code"</span>: 0,</span><br><span class="line">				<span class="string">"msg"</span>:  <span class="string">"注册失败"</span>,</span><br><span class="line">				<span class="string">"data"</span>: nil,</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终main.go可简洁为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	// gin framework</span><br><span class="line">	router := route.Router()</span><br><span class="line"></span><br><span class="line">	// 启动服务并监听端口</span><br><span class="line">	err := router.Run(config.UploadServiceHost)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Failed to start server, err:%s\n"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line">	r.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"first"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"first ........."</span>)</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	authorized := r.Group(<span class="string">"/try"</span>)</span><br><span class="line"></span><br><span class="line">	authorized.POST(<span class="string">"/second"</span>, second)</span><br><span class="line">	authorized.POST(<span class="string">"/third"</span>, third)</span><br><span class="line"></span><br><span class="line">	// 嵌套路由组</span><br><span class="line">	testing := authorized.Group(<span class="string">"testing"</span>)</span><br><span class="line">	testing.GET(<span class="string">"/forth"</span>, fourth)</span><br><span class="line"></span><br><span class="line">	// 监听并在 0.0.0.0:8080 上启动服务</span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func second(c *gin.Context) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"second ........."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func third(c *gin.Context) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"third ........."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fourth(c *gin.Context) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"fourth ........."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  gin-demo git:(master) ✗ lsof -i tcp:8080    </span><br><span class="line">COMMAND     PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">QQ          327 samtake   29u  IPv4 0xfdcbb6b79716f31f      0t0  TCP huangloshansmbp:50202-&gt;157.255.13.190:http-alt (ESTABLISHED)</span><br><span class="line">QQ          327 samtake   48u  IPv4 0xfdcbb6b79716f31f      0t0  TCP huangloshansmbp:50202-&gt;157.255.13.190:http-alt (ESTABLISHED)</span><br><span class="line">Google      420 samtake   26u  IPv4 0xfdcbb6b793e58fb7      0t0  TCP localhost:51492-&gt;localhost:http-alt (ESTABLISHED)</span><br><span class="line">Postman   66875 samtake   67u  IPv4 0xfdcbb6b778668ca7      0t0  TCP localhost:51499-&gt;localhost:http-alt (ESTABLISHED)</span><br><span class="line">main      67553 samtake    3u  IPv6 0xfdcbb6b793ea9b8f      0t0  TCP *:http-alt (LISTEN)</span><br><span class="line">main      67553 samtake    7u  IPv6 0xfdcbb6b793eac3cf      0t0  TCP localhost:http-alt-&gt;localhost:51492 (ESTABLISHED)</span><br><span class="line">main      67553 samtake    8u  IPv6 0xfdcbb6b7912a55cf      0t0  TCP localhost:http-alt-&gt;localhost:51499 (ESTABLISHED)</span><br><span class="line">➜  gin-demo git:(master) ✗ <span class="built_in">kill</span> -9  67553      </span><br><span class="line">➜  gin-demo git:(master) ✗ go run start/main.go</span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">"debug"</span> mode. Switch to <span class="string">"release"</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /first                    --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] POST   /try/second               --&gt; main.second (3 handlers)</span><br><span class="line">[GIN-debug] POST   /try/third                --&gt; main.third (3 handlers)</span><br><span class="line">[GIN-debug] GET    /try/testing/forth        --&gt; main.fourth (3 handlers)</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br><span class="line">first .........</span><br><span class="line">[GIN] 2020/02/25 - 11:51:19 | 200 |     176.613µs |       127.0.0.1 | GET      /first</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/gin-first.png" alt></p>
<h2 id="1-请求路由"><a href="#1-请求路由" class="headerlink" title="1.请求路由"></a>1.请求路由</h2><h3 id="多种请求"><a href="#多种请求" class="headerlink" title="多种请求"></a>多种请求</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"get"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"get"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">"post"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"post"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.DELETE(<span class="string">"delete"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"delete"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Any(<span class="string">"/any"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"any"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>给我们创建的any请求几乎覆盖了所有种类的请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GIN-debug] GET    /get                      --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] POST   /post                     --&gt; main.main.func2 (3 handlers)</span><br><span class="line">[GIN-debug] DELETE /delete                   --&gt; main.main.func3 (3 handlers)</span><br><span class="line">[GIN-debug] GET    /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] POST   /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] PUT    /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] PATCH  /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] HEAD   /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] OPTIONS /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] DELETE /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] CONNECT /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] TRACE  /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure>

<h3 id="静态文件夹"><a href="#静态文件夹" class="headerlink" title="静态文件夹"></a>静态文件夹</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	// 静态文件夹绑定+路由，有两种写法：</span><br><span class="line">	r.Static(<span class="string">"/assets"</span>, <span class="string">"./assets"</span>)</span><br><span class="line">	r.StaticFS(<span class="string">"/static"</span>, http.Dir(<span class="string">"static"</span>))</span><br><span class="line"></span><br><span class="line">	//又或者路由+资源</span><br><span class="line">	r.StaticFile(<span class="string">"/favicon.ico"</span>, <span class="string">"/favicon.ico"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>go build -o router_static &amp;&amp; ./router_static</code>这需要在routerstatic文件夹下运行，不然找不到资源文件，最后访问<code>http://localhost:8080/assets/a.html</code>以及<code>http://localhost:8080/static/b.html</code>测试即可。</p>
<h3 id="参数作为url"><a href="#参数作为url" class="headerlink" title="参数作为url"></a>参数作为url</h3><p>Get请求<code>http://localhost:8080/Sam/520</code>即可得到相应参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"520"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Sam"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-获取请求参数"><a href="#2-获取请求参数" class="headerlink" title="2.获取请求参数"></a>2.获取请求参数</h2><ul>
<li>获取get请求参数</li>
<li>获取post请求参数</li>
<li>获取body值</li>
<li>获取参数绑定结构体</li>
</ul>
<h3 id="泛绑定"><a href="#泛绑定" class="headerlink" title="泛绑定"></a>泛绑定</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/user/*action"</span>, func(c *gin.Context) &#123; //设置获取name和id的参数</span><br><span class="line">		c.String(200, <span class="string">"泛绑定～"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有user前缀的请求都能请求到：<code>http://localhost:8080/user/&lt;XXXX&gt;</code></p>
<h3 id="获取get参数"><a href="#获取get参数" class="headerlink" title="获取get参数"></a>获取get参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/testGetParam"</span>, func(c *gin.Context) &#123; //设置获取name和id的参数</span><br><span class="line">		param1 := c.Query(<span class="string">"parm1"</span>)</span><br><span class="line">		param2 := c.Query(<span class="string">"parm2"</span>)</span><br><span class="line"></span><br><span class="line">		c.String(http.StatusOK, <span class="string">"%s, %s"</span>, param1, param2)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET <span class="string">'http://127.0.0.1:8080/testGetParam?parm1=11111'</span> </span><br><span class="line">11111, %  </span><br><span class="line">➜  ~ curl -X GET <span class="string">'http://127.0.0.1:8080/testGetParam?parm1=11111&amp;parm2=2222'</span></span><br><span class="line">11111, 2222%</span><br></pre></td></tr></table></figure>



<h3 id="获取body内容"><a href="#获取body内容" class="headerlink" title="获取body内容"></a>获取body内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.POST(<span class="string">"/parmBody"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		bodyBytes, err := ioutil.ReadAll(c.Request.Body)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			c.String(http.StatusBadRequest, err.Error())</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">		c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes)) //重新回写到缓存才能拿到parm1 parm2</span><br><span class="line">		parm1 := c.PostForm(<span class="string">"parm1"</span>)</span><br><span class="line">		parm2 := c.PostForm(<span class="string">"parm2"</span>)</span><br><span class="line">		c.String(http.StatusOK, <span class="string">"%s %s %s"</span>, parm1, parm2, string(bodyBytes))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X POST <span class="string">'http://127.0.0.1:8080/parmBody'</span> -d <span class="string">'parm1=value1&amp;parm2=value2'</span> </span><br><span class="line">value1 value2 parm1=value1&amp;parm2=value2%                                                                                                                               </span><br><span class="line">➜  ~ curl -X POST <span class="string">'http://127.0.0.1:8080/parmBody'</span> -d <span class="string">'&#123;"parm1":"value1","parm2":"value2"&#125;'</span></span><br><span class="line">  &#123;<span class="string">"parm1"</span>:<span class="string">"value1"</span>,<span class="string">"parm2"</span>:<span class="string">"value2"</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取bind参数"><a href="#获取bind参数" class="headerlink" title="获取bind参数"></a>获取bind参数</h3><p>同时响应post和get，同时访问到同一个回调方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct &#123;</span><br><span class="line">	Name     string    `form:<span class="string">"name"</span>` //设置tag `form`可以由参数转变成结构体</span><br><span class="line">	Address  string    `form:<span class="string">"address"</span>`</span><br><span class="line">	Birthday time.Time `form:<span class="string">"birthday"</span> time_format:<span class="string">"2006-01-03"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, testHandler)</span><br><span class="line">	r.POST(<span class="string">"/test"</span>, testHandler)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testHandler(c *gin.Context) &#123;</span><br><span class="line">	var person Person</span><br><span class="line">	//根据请求content-type来作不同的binding操作</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBind(&amp;person); err == nil &#123;</span><br><span class="line">		c.String(200, <span class="string">"%v"</span>, person)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.String(200, <span class="string">"person bind error"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET  <span class="string">'http://127.0.0.1:8080/test?name=samtake&amp;adress=gd'</span></span><br><span class="line">&#123;samtake  0001-01-01 00:00:00 +0000 UTC&#125;</span><br><span class="line">➜  ~ curl -X GET  <span class="string">'http://127.0.0.1:8080/test?name=samtake&amp;address=gd'</span></span><br><span class="line">&#123;samtake gd 0001-01-01 00:00:00 +0000 UTC&#125;%  </span><br><span class="line">➜  ~ curl -X POST  <span class="string">'http://127.0.0.1:8080/test?name=samtake&amp;address=gd&amp;birthday=2008-09-09'</span></span><br><span class="line">&#123;samtake gd 2008-09-01 09:00:00 +0800 CST&#125;%   </span><br><span class="line">➜  ~ curl -X POST  <span class="string">'http://127.0.0.1:8080/test'</span>  -d <span class="string">'name=samtake&amp;address=gd&amp;birthday=2008-09-09'</span></span><br><span class="line">&#123;samtake gd 2008-09-01 09:00:00 +0800 CST&#125;%   </span><br><span class="line">➜  ~ curl -H <span class="string">"Content-Type:application/json"</span>  -X POST <span class="string">"http://127.0.0.1:8080/test"</span>  -d <span class="string">'&#123;"name":"wang"&#125;'</span></span><br><span class="line">&#123;wang  0001-01-01 00:00:00 +0000 UTC&#125;%</span><br></pre></td></tr></table></figure>


<p>这里有个坑：如果时间格式写成像<code>time_format:&quot;2006-01-03&quot;</code>这种会报错，解析不了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">person <span class="built_in">bind</span> error%!(EXTRA *time.ParseError=parsing time <span class="string">"2008-00-08"</span> as <span class="string">"2011-01-03"</span>: cannot parse <span class="string">"-00-08"</span> as <span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>


<h2 id="验证请求参数"><a href="#验证请求参数" class="headerlink" title="验证请求参数"></a>验证请求参数</h2><ul>
<li>结构体验证</li>
<li>自定义验证</li>
<li>支持多语言错误信息</li>
</ul>
<h3 id="结构体验证"><a href="#结构体验证" class="headerlink" title="结构体验证"></a>结构体验证</h3><p><a href="https://godoc.org/gopkg.in/go-playground/validator.v9" target="_blank" rel="noopener">validate规则</a><br>binding条件满足</p>
<p>坑的记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct &#123;</span><br><span class="line">	Age     int    `form:<span class="string">"age"</span>  binding:<span class="string">"required,gt=10"</span>`</span><br><span class="line">	Name    string `form:<span class="string">"name"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">	Address string `form:<span class="string">"address"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/validate-form.png" alt></p>
<p>正确的完整源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct &#123;</span><br><span class="line">	Age     int    `form:<span class="string">"Age"</span>  binding:<span class="string">"required,gt=10"</span>`</span><br><span class="line">	Name    string `form:<span class="string">"Name"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">	Address string `form:<span class="string">"Address"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, testHandler)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testHandler(c *gin.Context) &#123;</span><br><span class="line">	var person Person</span><br><span class="line">	//根据请求content-type来作不同的binding操作</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBind(&amp;person); err != nil &#123;</span><br><span class="line">		c.String(500, <span class="string">"%v"</span>, err)</span><br><span class="line">		c.Abort()</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.String(200, <span class="string">"%v"</span>, person)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET  <span class="string">"http://127.0.0.1:8080/test?age=19&amp;name=samtake&amp;address=gd"</span></span><br><span class="line">Key: <span class="string">'Person.Age'</span> Error:Field validation <span class="keyword">for</span> <span class="string">'Age'</span> failed on the <span class="string">'required'</span> tag</span><br><span class="line">Key: <span class="string">'Person.Name'</span> Error:Field validation <span class="keyword">for</span> <span class="string">'Name'</span> failed on the <span class="string">'required'</span> tag</span><br><span class="line">Key: <span class="string">'Person.Address'</span> Error:Field validation <span class="keyword">for</span> <span class="string">'Address'</span> failed on the <span class="string">'required'</span> tag% </span><br><span class="line">➜  ~ curl -X GET  <span class="string">"http://127.0.0.1:8080/test?Age=19&amp;Name=samtake&amp;Address=gd"</span></span><br><span class="line">&#123;19 samtake gd&#125;%</span><br></pre></td></tr></table></figure>

<h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">	&quot;github.com/gin-gonic/gin/binding&quot;</span><br><span class="line">	&quot;gopkg.in/go-playground/validator.v9&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Booking struct &#123;</span><br><span class="line">	CheckIn  time.Time `form:&quot;check_in&quot;  binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-01&quot;`</span><br><span class="line">	CheckOut time.Time `form:&quot;check_out&quot;  binding:&quot;required,gtfield=checkIn&quot; time_format:&quot;2006-01-01&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func customFunc(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool &#123;</span><br><span class="line">	if date, ok := field.Interface().(time.Time); ok &#123;</span><br><span class="line">		today := time.Now()</span><br><span class="line">		if date.Unix() &gt; today.Unix() &#123;</span><br><span class="line">			return true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">		v.RegisterValidation(&quot;bookabledate&quot;, customFunc)</span><br><span class="line">	&#125;</span><br><span class="line">	r.GET(&quot;/bookable&quot;, testHandler)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testHandler(c *gin.Context) &#123;</span><br><span class="line">	var b Booking</span><br><span class="line">	if err := c.ShouldBind(&amp;b); err != nil &#123;</span><br><span class="line">		c.JSON(500, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(200, gin.H&#123;&quot;message&quot;: &quot;ok!&quot;, &quot;booking&quot;: b&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个报错，我自己也还没弄明白，然而我看了下源码，上面的使用方法是正确的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">validCustom/validCustom.go:30:24: cannot use customFunc (<span class="built_in">type</span> func(*validator.Validate, reflect.Value, reflect.Value, reflect.Value, reflect.Typ</span><br><span class="line">e, reflect.Kind, string) bool) as <span class="built_in">type</span> validator.Func <span class="keyword">in</span> argument to v.RegisterValidation</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// RegisterValidation adds a validation with the given tag</span><br><span class="line">//</span><br><span class="line">// NOTES:</span><br><span class="line">// - <span class="keyword">if</span> the key already exists, the previous validation <span class="keyword">function</span> will be replaced.</span><br><span class="line">// - this method is not thread-safe it is intended that these all be registered prior to any validation</span><br><span class="line">func (v *Validate) RegisterValidation(tag string, fn Func) error &#123;</span><br><span class="line">	<span class="built_in">return</span> v.RegisterValidationCtx(tag, wrapFunc(fn))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持多语言错误信息"><a href="#支持多语言错误信息" class="headerlink" title="支持多语言错误信息"></a>支持多语言错误信息</h3><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul>
<li>使用Gin中间件</li>
<li>自定义<code>ip白名单</code>中间件</li>
</ul>
<h3 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h3><p><code>Logger</code>日志<br><code>Recovery</code>捕获panic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	f, _ := os.Create(<span class="string">"gin.log"</span>)</span><br><span class="line">	gin.DefaultWriter = io.MultiWriter(f)</span><br><span class="line">	gin.DefaultErrorWriter = io.MultiWriter(f)</span><br><span class="line"></span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(gin.Logger(),gin.Recovery())</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		name := c.DefaultQuery(<span class="string">"name"</span>, <span class="string">"default_name"</span>)</span><br><span class="line">		c.String(200, <span class="string">"%s"</span>, name)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p><code>r.User(IPAuthMiddleware())</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func IPAuthMiddleware() gin.HandlerFunc &#123;</span><br><span class="line">	<span class="built_in">return</span> func(c *gin.Context) &#123;</span><br><span class="line">		ipList := []string&#123;</span><br><span class="line">			<span class="string">"127.0.0.1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		flag := <span class="literal">false</span></span><br><span class="line">		clientIP := c.ClientIP()</span><br><span class="line">		<span class="keyword">for</span> _, host := range ipList &#123;</span><br><span class="line">			<span class="keyword">if</span> clientIP == host &#123;</span><br><span class="line">				flag = <span class="literal">true</span></span><br><span class="line">				<span class="built_in">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !flag &#123;</span><br><span class="line">			c.String(401, <span class="string">"%s,not in iplist"</span>, clientIP)</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(IPAuthMiddleware())</span><br><span class="line">	r.Use(gin.Logger(), gin.Recovery())</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"%s"</span>, <span class="string">"hello test"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Gin延展"><a href="#Gin延展" class="headerlink" title="Gin延展"></a>Gin延展</h2><ul>
<li>服务器优雅关停</li>
<li>模版渲染</li>
<li>自动证书配置</li>
</ul>
<h3 id="服务器关停"><a href="#服务器关停" class="headerlink" title="服务器关停"></a>服务器关停</h3><p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/gin-server-stop.png" alt></p>
<h3 id="模版渲染"><a href="#模版渲染" class="headerlink" title="模版渲染"></a>模版渲染</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLGlob(<span class="string">"template/*"</span>)</span><br><span class="line">	r.GET(<span class="string">"/index"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(200, <span class="string">"index.html"</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"index.html"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET  <span class="string">"http://127.0.0.1:8080/index"</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">        index.html</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">&lt;/html&gt;%                                                                        </span><br><span class="line">➜  ~</span><br></pre></td></tr></table></figure>

<h3 id="自动证书配置"><a href="#自动证书配置" class="headerlink" title="自动证书配置"></a>自动证书配置</h3><h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><p>项目地址：<br><a href="https://github.com/e421083458/gin_scaffold" target="_blank" rel="noopener">gin_scaffold</a><br><a href="https://github.com/e421083458/golang_common" target="_blank" rel="noopener">golang_common</a><br><a href="https://github.com/e421083458/vue-admin" target="_blank" rel="noopener">vue-admin</a></p>
<h3 id="轻量级Golang类库"><a href="#轻量级Golang类库" class="headerlink" title="轻量级Golang类库"></a>轻量级Golang类库</h3><p>GORM:<a href="https://gorm.io/zh_CN/" target="_blank" rel="noopener">https://gorm.io/zh_CN/</a><br>redigo:<a href="https://godoc.org/github.com/gomodule/redigo/redis" target="_blank" rel="noopener">https://godoc.org/github.com/gomodule/redigo/redis</a></p>
<p>├── README.md<br>├── conf   配置文件夹<br>│   └── dev<br>│       ├── base.toml<br>│       ├── mysql_map.toml<br>│       └── redis_map.toml<br>├── controller 控制器<br>│   └── demo.go<br>├── dao DB数据访问层<br>│   └── demo.go<br>├── dto  Bind结构体层<br>│   └── demo.go<br>├── gin_scaffold.inf.log  info日志<br>├── gin_scaffold.wf.log warning日志<br>├── go.mod go module管理文件<br>├── go.sum<br>├── main.go<br>├── middleware 中间件层<br>│   ├── panic.go<br>│   ├── response.go<br>│   ├── token_auth.go<br>│   └── translation.go<br>├── public  公共文件<br>│   ├── log.go<br>│   ├── mysql.go<br>│   └── validate.go<br>├── router  路由层<br>│   ├── httpserver.go<br>│   └── route.go<br>└── tmpl</p>
<h3 id="输出格式统一封装"><a href="#输出格式统一封装" class="headerlink" title="输出格式统一封装"></a>输出格式统一封装</h3><h3 id="自定义中间件日志打印"><a href="#自定义中间件日志打印" class="headerlink" title="自定义中间件日志打印"></a>自定义中间件日志打印</h3><h3 id="请求数据绑定结构体与校验"><a href="#请求数据绑定结构体与校验" class="headerlink" title="请求数据绑定结构体与校验"></a>请求数据绑定结构体与校验</h3>]]></content>
      <categories>
        <category>Gin</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Gin</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Docker安装RabbitMQ</title>
    <url>/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h3 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /Users/samtake/Documents/GitHub/www/rabbitmq目录可自定义，主要用于目录挂载</span></span><br><span class="line">➜  ~ mkdir -p /Users/samtake/Documents/GitHub/www/rabbitmq</span><br><span class="line">➜  ~ docker run -d --hostname rabbit-node1 --name rabbit-node1 -p 5672:5672 -p15672:15672 -v /Users/samtake/Documents/GitHub/www/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span><br><span class="line">Unable to find image <span class="string">'rabbitmq:management'</span> locally</span><br><span class="line">management: Pulling from library/rabbitmq</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>报错提示,手动添加一下docker分享目录即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The path /www/rabbitmq</span><br><span class="line">is not shared from OS X and is not known to Docker.</span><br><span class="line">You can configure shared paths from Docker -&gt; Preferences... -&gt; File Sharing.</span><br><span class="line">See https://docs.docker.com/docker-for-mac/osxfs/<span class="comment">#namespaces for more info.</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ docker ps | grep rabbit</span><br><span class="line">75d0ec6821fc        rabbitmq:management   <span class="string">"docker-entrypoint.s…"</span>   About a minute ago   Up About a minute   4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp   rabbit-node1</span><br></pre></td></tr></table></figure>


<p>浏览器打开登录rabbitmq, 入口:<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a><br>默认用户名: guest 密码: guest</p>
<h3 id="RabbitMQ的UI界面使用测试"><a href="#RabbitMQ的UI界面使用测试" class="headerlink" title="RabbitMQ的UI界面使用测试"></a>RabbitMQ的UI界面使用测试</h3><h3 id="RabbitMQ的工作原理和转发模式"><a href="#RabbitMQ的工作原理和转发模式" class="headerlink" title="RabbitMQ的工作原理和转发模式"></a>RabbitMQ的工作原理和转发模式</h3><p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/RabbitMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt></p>
<p>名词解析：<br><code>exchange</code>:消息交换机，决定消息按什么规则，路由到哪个队列。<br><code>queue</code>:消息载体，每个消息都会被投到一个或多个队列。<br><code>binding</code>:绑定，把exchange和queue按照路由规则绑定起来。<br><code>routing key</code>:路由关键字，exchange根据这关键字来投递消息。<br><code>channel</code>:消息通道，客户端的每个连接建立多个channnel。<br><code>producer</code>:消息生产者，用于投递消息的程序。<br><code>consumer</code>:消息消费者，用于接收消息的程序。</p>
<p>exchange的工作模式<br><code>fanout</code>:类似广播，转发到所有绑定交换机的queue。<br><code>direct</code>:类似单播，routing key 和bingding key完美匹配。<br><code>topic</code>:类似组播，转发到符合通配符的queue。<br><code>headers</code>:请求头与消息匹配，才能接收消息。</p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/fanout.png" alt></p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/direct.png" alt></p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/topic.jpeg" alt></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>1.配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">	// AsyncTransferEnable : 是否开启文件异步转移(默认同步)</span><br><span class="line">	AsyncTransferEnable = <span class="literal">true</span></span><br><span class="line">	// RabbitURL : rabbitmq服务的入口url</span><br><span class="line">	RabbitURL = <span class="string">"amqp://guest:guest@127.0.0.1:5672/"</span></span><br><span class="line">	// TransExchangeName : 用于文件transfer的交换机</span><br><span class="line">	TransExchangeName = <span class="string">"uploadserver.trans"</span></span><br><span class="line">	// TransOSSQueueName : oss转移队列名</span><br><span class="line">	TransOSSQueueName = <span class="string">"uploadserver.trans.oss"</span></span><br><span class="line">	// TransOSSErrQueueName : oss转移失败后写入另一个队列的队列名</span><br><span class="line">	TransOSSErrQueueName = <span class="string">"uploadserver.trans.oss.err"</span></span><br><span class="line">	// TransOSSRoutingKey : routingkey</span><br><span class="line">	TransOSSRoutingKey = <span class="string">"oss"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>2.生产者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	// 是否开启异步转移功能，开启时才初始化rabbitMQ连接</span><br><span class="line">	<span class="keyword">if</span> !config.AsyncTransferEnable &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="function"><span class="title">initChannel</span></span>() &#123;</span><br><span class="line">		channel.NotifyClose(notifyClose)</span><br><span class="line">	&#125;</span><br><span class="line">	// 断线自动重连</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> msg := &lt;-notifyClose:</span><br><span class="line">				conn = nil</span><br><span class="line">				channel = nil</span><br><span class="line">				log.Printf(<span class="string">"onNotifyChannelClosed: %+v\n"</span>, msg)</span><br><span class="line">				initChannel()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initChannel() bool &#123;</span><br><span class="line">	//1.判断channel是否已经创建</span><br><span class="line">	<span class="keyword">if</span> channel != nil &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.获得rabbitMQ的一个连接</span><br><span class="line">	conn, err := amqp.Dial(config.RabbitURL)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//3.打开一个channel，用于消息的发布与接收等</span><br><span class="line">	channel, err = conn.Channel()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Publish : 发布消息</span><br><span class="line">func Publish(exchange, routingKey string, msg []byte) bool &#123;</span><br><span class="line">	//1.判断channel是否正常</span><br><span class="line">	<span class="keyword">if</span> !<span class="function"><span class="title">initChannel</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.执行消息发布</span><br><span class="line">	err := channel.Publish(</span><br><span class="line">		exchange,</span><br><span class="line">		routingKey,</span><br><span class="line">		<span class="literal">false</span>, // 如果没有对应的queue, 就会丢弃这条消息</span><br><span class="line">		<span class="literal">false</span>, //</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ContentType: <span class="string">"text/plain"</span>, //明文编码</span><br><span class="line">			Body:        msg,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.消费者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">done</span> chan bool</span><br><span class="line"></span><br><span class="line">// StartConsume : 开始监听队列，获取消息</span><br><span class="line">func StartConsume(qName, cName string, callback func(msg []byte) bool) &#123;</span><br><span class="line">	//1.通过channel.Consume获得消息信道</span><br><span class="line">	msgs, err := channel.Consume(</span><br><span class="line">		qName,</span><br><span class="line">		cName,</span><br><span class="line">		<span class="literal">true</span>,  //自动应答</span><br><span class="line">		<span class="literal">false</span>, // 非唯一的消费者</span><br><span class="line">		<span class="literal">false</span>, // rabbitMQ只能设置为<span class="literal">false</span></span><br><span class="line">		<span class="literal">false</span>, // noWait, <span class="literal">false</span>表示会阻塞直到有消息过来</span><br><span class="line">		nil)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">done</span> = make(chan bool)</span><br><span class="line"></span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		// 2.循环读取channel的数据</span><br><span class="line">		<span class="keyword">for</span> d := range msgs &#123;</span><br><span class="line">			//3.调用callback方法来处理新的消息</span><br><span class="line">			processErr := callback(d.Body)</span><br><span class="line">			<span class="keyword">if</span> processErr &#123;</span><br><span class="line">				// TODO: 将任务写入另一个队列，用于异常情况的重试</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 接收<span class="keyword">done</span>的信号, 没有信息过来则会一直阻塞，避免该函数退出</span><br><span class="line">	&lt;-<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">	// 关闭通道</span><br><span class="line">	channel.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// StopConsume : 停止监听队列</span><br><span class="line">func <span class="function"><span class="title">StopConsume</span></span>() &#123;</span><br><span class="line">	<span class="keyword">done</span> &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">demo</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2020/02/12/Redis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="Docker-安装-Redis"><a href="#Docker-安装-Redis" class="headerlink" title="Docker 安装 Redis"></a>Docker 安装 Redis</h3><p><code>docker pull redis:latest</code><br>取最新版的 Redis 镜像</p>
<p><code>docker images</code><br>查看是否已安装了 redis</p>
<p>运行 redis 容器<br><code>docker run -itd --name redis-test -p 6379:6379 redis</code><br>或者运行redis并设置密码<br><code>docker run -d --name myredis -p 6379:6379 redis --requirepass &quot;mypassword&quot;</code></p>
<p>其中-p 6379:6379：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。</p>
<p><code>docker ps</code> 查看容器的运行信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Desktop docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                               NAMES</span><br><span class="line">d1f67d1e5fda        redis               <span class="string">"docker-entrypoint.s…"</span>   About a minute ago   Up About a minute   0.0.0.0:6379-&gt;6379/tcp              redis-test</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   8 hours ago          Up 8 hours          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br></pre></td></tr></table></figure>


<p>最后，通过过 redis-cli 连接测试使用 redis 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Desktop docker <span class="built_in">exec</span> -it redis-test /bin/bash</span><br><span class="line">root@d1f67d1e5fda:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> <span class="built_in">test</span> 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作；</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素；读取单个或者多个元素；进行修剪，只保留一个范围内的元素；</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素；</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、删除单个键值对；获取所有键值对；检查某个健是否存在；</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键的排名；</td>
</tr>
</tbody></table>
<h4 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取存储在给定健中的值</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定健中的值</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定健中的值（这个命令可以用于所有类型）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name longshan</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"longshan"</span></span><br><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h4 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>rpush</td>
<td>获取存储在给定键中的值</td>
</tr>
<tr>
<td>lrange</td>
<td>设置存储在给定键中的值</td>
</tr>
<tr>
<td>lindex</td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）</td>
</tr>
<tr>
<td>lpop</td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0-1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'lrange'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"item1"</span></span><br><span class="line">2) <span class="string">"item2"</span></span><br><span class="line">3) <span class="string">"item3"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'lrange'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 1</span><br><span class="line"><span class="string">"item2"</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line"><span class="string">"item1"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"item2"</span></span><br><span class="line">2) <span class="string">"item3"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><p>命令    | 行为<br>-|-|-<br>sadd    | 添加一个或多个元素到集合里<br>smembers |    获取集合里面的所有元素<br>sismember |    确定一个给定的值是一个集合的成员<br>srem    | 从集合里删除一个或多个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smember <span class="built_in">set</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `smember`, with args beginning with: `<span class="built_in">set</span>`, </span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"item3"</span></span><br><span class="line">2) <span class="string">"item1"</span></span><br><span class="line">3) <span class="string">"item2"</span></span><br><span class="line">127.0.0.1:6379&gt; sismember <span class="built_in">set</span> item5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smenbers <span class="built_in">set</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `smenbers`, with args beginning with: `<span class="built_in">set</span>`, </span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"item3"</span></span><br><span class="line">2) <span class="string">"item1"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h4 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h4><p>命令    | 行为<br>-|-|-<br>hset    | 设置 hash 里面一个字段的值<br>hget    | 获取 hash 中域的值<br>hgetall    | 从 hash 中读取全部的域和值<br>hdel    | 删除一个或多个域</p>
<h4 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h4><p>命令    | 行为<br>-|-|-<br>ZADD    | 添加到有序 set 的一个或多个成员，或更新的分数，如果它已经存在<br>ZRANGE    | 根据指定的 index 返回，返回 sorted set 的成员列表<br>ZRANGEBYSCORE    | 返回有序集合中指定分数区间内的成员，分数由低到高排序。<br>ZREM    | 从排序的集合中删除一个或多个成员</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>缓存 - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</p>
</li>
<li><p>计数器 - Redis 这种内存数据库能支持计数器频繁的读写操作。</p>
</li>
<li><p>应用限流 - 限制一个网站访问流量。</p>
</li>
<li><p>消息队列 - 使用 List 数据类型，它是双向链表。</p>
</li>
<li><p>查找表 - 使用 HASH 数据类型。</p>
</li>
<li><p>交集运算 - 使用 SET 类型，例如求两个用户的共同好友。</p>
</li>
<li><p>排行榜 - 使用 ZSET 数据类型。</p>
</li>
<li><p>分布式 Session - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</p>
</li>
<li><p>分布式锁 - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
</li>
</ul>
<h3 id="通过go语言使用Redis"><a href="#通过go语言使用Redis" class="headerlink" title="通过go语言使用Redis"></a>通过go语言使用Redis</h3><p>1.设置一下Redis密码然后测试连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  egoshop docker rm -f cd93e4361dff                                                 </span><br><span class="line">cd93e4361dff</span><br><span class="line"></span><br><span class="line">➜  egoshop docker run -d --name myredis -p 6379:6379 redis --requirepass <span class="string">"mypassword"</span></span><br><span class="line">f21ed92618bc5a48a95a05fcf73d1fb911b3020616dfd4950b4827dc9559814e</span><br><span class="line">➜  egoshop docker ps                                                                 </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">f21ed92618bc        redis               <span class="string">"docker-entrypoint.s…"</span>   3 seconds ago       Up 1 second         0.0.0.0:6379-&gt;6379/tcp              myredis</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   10 hours ago        Up 10 hours         0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br><span class="line">➜  egoshop docker <span class="built_in">exec</span> -it myredis /bin/bash</span><br><span class="line">root@f21ed92618bc:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; auth <span class="string">"mypassword"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>2.创建连接池</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func newRedisPool() *redis.Pool &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;redis.Pool&#123;</span><br><span class="line">		MaxIdle:     50,</span><br><span class="line">		MaxActive:   30,</span><br><span class="line">		IdleTimeout: 300 * time.Second,</span><br><span class="line">		Dial: func() (redis.Conn, error) &#123;</span><br><span class="line">			// 1. 打开连接</span><br><span class="line">			c, err := redis.Dial(<span class="string">"tcp"</span>, redisHost)</span><br><span class="line">			<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">				<span class="built_in">return</span> nil, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 2. 访问认证</span><br><span class="line">			<span class="keyword">if</span> _, err = c.Do(<span class="string">"AUTH"</span>, redisPass); err != nil &#123;</span><br><span class="line">				c.Close()</span><br><span class="line">				<span class="built_in">return</span> nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">return</span> c, nil</span><br><span class="line">		&#125;,</span><br><span class="line">		TestOnBorrow: func(conn redis.Conn, t time.Time) error &#123;</span><br><span class="line">			<span class="keyword">if</span> time.Since(t) &lt; time.Minute &#123;</span><br><span class="line">				<span class="built_in">return</span> nil</span><br><span class="line">			&#125;</span><br><span class="line">			_, err := conn.Do(<span class="string">"PING"</span>)</span><br><span class="line">			<span class="built_in">return</span> err</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	pool = newRedisPool()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RedisPool() *redis.Pool &#123;</span><br><span class="line">	<span class="built_in">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">UploadHandler</span></span>() &#123;</span><br><span class="line">	// 获得redis的一个连接</span><br><span class="line">	rConn := rPool.RedisPool().Get()</span><br><span class="line">	defer rConn.Close()</span><br><span class="line"></span><br><span class="line">	// 将初信息写入到redis缓存</span><br><span class="line">	rConn.Do(<span class="string">"sadd"</span>, <span class="string">"set"</span>, <span class="string">"uploadHandler"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.查看是否有添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"upload1"</span></span><br><span class="line">2) <span class="string">"uploadHandler"</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">具体demo源码</a></p>
<p>参考资料<br><a href="https://www.runoob.com/redis/redis-intro.html" target="_blank" rel="noopener">Redis 简介</a><br><a href="https://www.runoob.com/docker/docker-install-redis.html" target="_blank" rel="noopener">Docker 安装 Redis</a><br><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1581497616&ver=2153&signature=wJL6PdenqSUgK7dgiXas*bbrDcJzwBzrYoKKYFFfsxW*dYcRnVHqpFKbcYqLDd-bp7DY50iIvxGq8jNMAbQXau-uLB0hPqUJc4erX3MDhbuOrvvtCbw7KY3147aW3KBr&new=1" target="_blank" rel="noopener">Redis 入门指南</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat使用资料</title>
    <url>/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>实操一下</p>
<p>通过docker来启动一个mysql容器应用<br><code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</code></p>
<h3 id="通过docker-exec-it-容器id-bash-来操作mysql"><a href="#通过docker-exec-it-容器id-bash-来操作mysql" class="headerlink" title="通过docker exec -it 容器id bash 来操作mysql"></a>通过docker exec -it 容器id bash 来操作mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blogs docker ps                      </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   41 minutes ago      Up 41 minutes       0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br><span class="line">➜  blogs docker <span class="built_in">exec</span> -it  0eee2c1708be bash            </span><br><span class="line">root@0eee2c1708be:/<span class="comment"># mysql -uroot -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 765627</span><br><span class="line">Server version: 5.7.29 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; status;</span><br><span class="line">--------------</span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.29, <span class="keyword">for</span> Linux (x86_64) using  EditLine wrapper</span><br><span class="line"></span><br><span class="line">Connection id:		765627</span><br><span class="line">Current database:	</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not <span class="keyword">in</span> use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		<span class="string">''</span></span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.7.29 MySQL Community Server (GPL)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	latin1</span><br><span class="line">Db     characterset:	latin1</span><br><span class="line">Client characterset:	latin1</span><br><span class="line">Conn.  characterset:	latin1</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			1 hour 2 min 0 sec</span><br><span class="line"></span><br><span class="line">Threads: 2  Questions: 6  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.001</span><br><span class="line">--------------</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>


<h3 id="在navicat中使用sql语句创建表"><a href="#在navicat中使用sql语句创建表" class="headerlink" title="在navicat中使用sql语句创建表"></a>在navicat中使用sql语句创建表</h3><p>1.进行命令行操作</p>
<p><img src="/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/navicate-console.jpeg" alt></p>
<p>2.输入mysql<br><img src="/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/navicate-soule-mysql.png" alt></p>
<p>3.右键refresh一下即可见到刚才新建的表tbl_user<br><img src="/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/tbl_user.png" alt></p>
<h3 id="通过navicat连接MySQL"><a href="#通过navicat连接MySQL" class="headerlink" title="通过navicat连接MySQL"></a>通过navicat连接MySQL</h3><p>创建数据库时，一般字符集选择utf8，排序规则选择utf8_general_ci </p>
<p><a href="https://zhuanlan.zhihu.com/p/44348694" target="_blank" rel="noopener">在Navicat中如何新建数据库和表并做查询</a><br><a href="https://www.navicat.com.cn/manual/online_manual/cn/navicat/win_manual/index.html#/about_0" target="_blank" rel="noopener">Navicat使用手册</a> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中通过Docker安装配置MySQL主从节点</title>
    <url>/2020/02/09/Ubuntu%E4%B8%AD%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="1-拉取MySQL5-7镜像到本地"><a href="#1-拉取MySQL5-7镜像到本地" class="headerlink" title="1.拉取MySQL5.7镜像到本地"></a>1.拉取MySQL5.7镜像到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你只需要跑一个mysql实例，不做主从，那么执行以下命令即可，不用再做后面的参考步骤: docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 </span></span><br><span class="line"><span class="comment"># 然后用shell或客户端软件通过配置( 用户名:root 密码:132456 IP:你的本机ip 端口:3306)来登录即可</span></span><br></pre></td></tr></table></figure>

<h3 id="2-准备MySQL的配置文件"><a href="#2-准备MySQL的配置文件" class="headerlink" title="2.准备MySQL的配置文件"></a>2.准备MySQL的配置文件</h3><p>MySQL5.7安装之后的默认配置文件在/etc/mysql/my.cnf，而自定义的配置文件一般放在/etc/mysql/config.d这个路径下。<br>在本地host主机上自定义的某个目录下（如/data/mysql/conf/），先创建两个文件master.conf和slave.conf，分别用于配置主从两个节点。</p>
<ul>
<li>/data/mysql/conf/master.conf<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysqld] </span><br><span class="line">log_bin = <span class="built_in">log</span> <span class="comment">#开启二进制日志，用于从节点的历史复制回放 </span></span><br><span class="line">collation-server = utf8_unicode_ci </span><br><span class="line">init-connect=<span class="string">'SET NAMES utf8'</span> </span><br><span class="line">character-set-server = utf8 </span><br><span class="line">server_id = 1 <span class="comment">#需保证主库和从库的server_id不同， 假设主库设为1 </span></span><br><span class="line">replicate-do-db=fileserver <span class="comment">#需要复制的数据库名，需复制多个数据库的话则重复设置这个选项</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>/data/mysql/conf/slave.conf<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysqld] </span><br><span class="line">log_bin = <span class="built_in">log</span> <span class="comment">#开启二进制日志，用于从节点的历史复制回放 </span></span><br><span class="line">collation-server = utf8_unicode_ci </span><br><span class="line">init-connect=<span class="string">'SET NAMES utf8'</span> </span><br><span class="line">character-set-server = utf8 </span><br><span class="line">server_id = 2 <span class="comment">#需保证主库和从库的server_id不同， 假设从库设为2 </span></span><br><span class="line">replicate-do-db=fileserver <span class="comment">#需要复制的数据库名，需复制多个数据库的话则重复设置这个选项</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-Docker分别运行MySQL主-从两个容器"><a href="#3-Docker分别运行MySQL主-从两个容器" class="headerlink" title="3. Docker分别运行MySQL主/从两个容器"></a>3. Docker分别运行MySQL主/从两个容器</h3><p>将mysql主节点运行起来 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/mysql/datam </span><br><span class="line">docker run -d --name mysql-master -p 13306:3306 -v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /data/mysql/datam:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>
<p>运行参数说明:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">–name mysql-master: 容器的名称设为mysql-master </span><br><span class="line">-p 13306:3306: 将host的13306端口映射到容器的3306端口 </span><br><span class="line">-v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf ： master.conf配置文件挂载 </span><br><span class="line">-v /data/mysql/datam:/var/lib/mysql ： mysql容器内数据挂载到host的/data/mysql/datam， 用于持久化 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 : mysql的root登录密码为123456</span><br></pre></td></tr></table></figure>

<p> 将mysql从节点运行起来<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/mysql/datas </span><br><span class="line">docker run -d --name mysql-slave -p 13307:3306 -v /data/mysql/conf/slave.conf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /data/mysql/datas:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure></p>
<p> 运行参数说明: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">–name mysql-slave: 容器的名称设为mysql-slave </span><br><span class="line">-p 13307:3306: 将host的13307端口映射到容器的3306端口 </span><br><span class="line">-v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf ： master.conf配置文件挂载</span><br><span class="line">-v /data/mysql/datam:/var/lib/mysql ： mysql容器内数据挂载到host的/data/mysql/datam， 用于持久化 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 : mysql的root登录密码为123456</span><br></pre></td></tr></table></figure>

<h3 id="4-登录MySQL主节点配置同步信息"><a href="#4-登录MySQL主节点配置同步信息" class="headerlink" title="4.登录MySQL主节点配置同步信息"></a>4.登录MySQL主节点配置同步信息</h3><p>宿主机安装mysql客户端 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y mysql-client</span><br></pre></td></tr></table></figure>

<p>登录mysql </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.1.xx 是你本机的内网ip </span></span><br><span class="line">mysql -u root -h 192.168.1.xx -P13306 -p123456</span><br></pre></td></tr></table></figure>

<p>在mysql client中执行 (创建用于访问主节点来同步数据的帐号) </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create user slave identified by <span class="string">'slave'</span>; </span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'slave'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'slave'</span>; </span><br><span class="line">mysql&gt; flush privileges; </span><br><span class="line">mysql&gt; create database fileserver default character <span class="built_in">set</span> utf8mb4;</span><br></pre></td></tr></table></figure>
<p>再获取status, 得到类似如下的输出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status\G; </span><br><span class="line">*************************** 1. row *************************** </span><br><span class="line">File: log.000025 </span><br><span class="line">Position: 155 Binlog_Do_DB: </span><br><span class="line">Binlog_Ignore_DB: </span><br><span class="line">Executed_Gtid_Set: 1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>


<h3 id="5-登录MySQL从节点配置同步信息"><a href="#5-登录MySQL从节点配置同步信息" class="headerlink" title="5.登录MySQL从节点配置同步信息"></a>5.登录MySQL从节点配置同步信息</h3><ul>
<li><p>查看mysql master的容器独立ip地址 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> mysql-master </span><br><span class="line"><span class="comment"># 比如输出得到: 172.17.0.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另开一个tab登录mysql </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.1.xx 是你本机的内网ip </span></span><br><span class="line">mysql -u root -h 192.168.1.xx -P13307 -p123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>在mysql client中操作: </p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave; </span><br><span class="line">mysql&gt; create database fileserver default character <span class="built_in">set</span> utf8mb4; </span><br><span class="line"><span class="comment">#注意其中的日志文件和数值要和上面show master status的值对应 </span></span><br><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST=<span class="string">'前两个步骤中获得的mysql master ip'</span>,MASTER_PORT=3306,MASTER_USER=<span class="string">'slave'</span>,MASTER_PASSWORD=<span class="string">'slave'</span>,MASTER_LOG_FILE=<span class="string">'log.000025'</span>,MASTER_LOG_POS=155; </span><br><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure>

<p>再获取status, 正常应该得到类似如下的输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status \G; </span><br><span class="line">// ... </span><br><span class="line">Slave_IO_Running: Yes </span><br><span class="line">Slave_SQL_Running: Yes </span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>



<p>到这时说明主从配置已经完成，可以尝试在主mysql的fileserver数据库里建表操作下，然后在从节点上检查数据是否已经同步过来。</p>
<h3 id="几个指令"><a href="#几个指令" class="headerlink" title="几个指令"></a>几个指令</h3><p><code>sudo netstat -antup -antup | grep docker</code> 查看docker占用端口<br><code>ifconfig</code> 查看本机ip</p>
<h3 id="通过docker-compose方式实现"><a href="#通过docker-compose方式实现" class="headerlink" title="通过docker compose方式实现"></a>通过docker compose方式实现</h3><p><a href="https://github.com/mayinghan/mysql-master-slave-service" target="_blank" rel="noopener">https://github.com/mayinghan/mysql-master-slave-service</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Docker启动MySQL容器</title>
    <url>/2019/12/20/%E9%80%9A%E8%BF%87docker%E5%90%AF%E5%8A%A8mysql%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>拉取mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<p>在后台启动mysql容器(–name指定了容器的名称，方便之后进入容器的命令行，MYSQL_ROOT_PASSWORD=hls123指定了mysql的root密码，-d表示在后台运行)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --name=mysql -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>

<p>进入容器bash并进入mysql命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br></pre></td></tr></table></figure>
<p>验证容器状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>



<p>创建mysql容器 1master+1个slave</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=mysql-master -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>

<p>–name 为容器指定名称，这里是mysql-master</p>
<p>-p 将容器的指定端口映射到主机的指定端口，这里是将容器的3306端口映射到主机的3306端口</p>
<p>-e 设置环境变量，这里是指定root账号的密码为hls123</p>
<p>-d 后台运行容器，并返回容器ID</p>
<p>docker run –name=mysql-master -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql:[版本号]<br>mysql:版本号 指定运行的mysql版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=mysql-slave1 -it -p 3307:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习</title>
    <url>/2019/12/11/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>安装<br>1.通过<a href="官网">wwww.docker.com</a>下载桌面版docker<br>2.<a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">配置Docker镜像站</a><br>3.执行<code>docker run hello-world</code>，看输出完美运行～</p>
<p>基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>常用操作</p>
<p>拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//下载官方nginx镜像源，等同于docker pull docker.io/nginx</span><br><span class="line">//也等同于docker pull docker.io/nginx.io/nginx:latest</span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//下载国内镜像源的ubuntu镜像，并制定版本</span><br><span class="line">docker pull registry.docker-cn.com/library/ubuntu:18.04</span><br></pre></td></tr></table></figure>

<p>推送镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//推送镜像到docker hub,需要先注册账号</span><br><span class="line">docker push &lt;你的用户名&gt;/&lt;你打包时定义的镜像名&gt;:&lt;标签，版本号&gt;</span><br><span class="line"></span><br><span class="line">//推送镜像到私有镜像库，需要提前搭建好仓库服务（比如用harbor来搭建）</span><br><span class="line">docker push &lt;私有镜像库域名，如a.b.com&gt;/&lt;项目名称&gt;/镜像名:&lt;标签&gt;</span><br></pre></td></tr></table></figure>

<p>打包镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//提前准备好一个Dockerfile，在Dockerfile相同路径下执行：</span><br><span class="line">docker build -t &lt;指定一个完整的镜像名，比如testdemo:v1.0&gt;</span><br><span class="line">//即可打包出一个本地镜像，然后再通过docker push 就可以推送到远端镜像仓库</span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d //-d 表示通过daemon方式来启动</span><br><span class="line">-p 13306:3306 //端口映射，将host主机的13306端口和docker容器的3306端口映射起来</span><br><span class="line">-v /etc/mysql:/var/mysql //目录挂载，将容器内的/var/mysql目录挂载到host主机的/etc/mysql目录，可以实现容器内这个目录下的数据持久化，mysql为镜像名（指定加载哪个镜像）</span><br></pre></td></tr></table></figure>

<p>重启或停止或删除容器应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps  //列出目前正在运行的容器列表</span><br><span class="line">docker ps -a //列出所有的容器列表</span><br><span class="line">docker start &lt;容器id&gt;  //通过容器id来重启某个容器，批量操作的话，直接在参数后面再跟对应容器id即可</span><br><span class="line">docker stop &lt;容器id&gt;  //通过容器id来关闭某个容器，批量操作的话，直接在参数后面再跟对应容器id即可</span><br><span class="line">docker rm &lt;容器id&gt;  //通过容器id来删除掉某个已经停止的容器</span><br><span class="line">docker rm -f &lt;容器id&gt;  //通过容器id来删除掉某个正在运行的容器</span><br><span class="line">docker container rm  [trusting_newton]</span><br></pre></td></tr></table></figure>

<p>删除本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmo &lt;镜像id&gt;</span><br><span class="line">docker rmi -f &lt;镜像id&gt; //强制删除</span><br></pre></td></tr></table></figure>

<p>查看容器日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f &lt;容器id&gt;</span><br><span class="line">docker inspect &lt;容器id&gt; //从返回结果中找到LogPath,运行的历史日志会在这个文件里找到</span><br></pre></td></tr></table></figure>

<p>进入容器内</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt;  /bin/bash  //进入容器内并进入它的shell终端</span><br><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt; &lt;shell命令&gt;  //在容器内执行shell命令</span><br><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt; ls -l        //查看容器内系统跟目录下所有文件或文件夹</span><br><span class="line"><span class="comment"># 进入容器后，可以直接通过exit命令推出容器</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器Linux下安装Docker社区版-Centos7为例"><a href="#服务器Linux下安装Docker社区版-Centos7为例" class="headerlink" title="服务器Linux下安装Docker社区版(Centos7为例)"></a>服务器Linux下安装Docker社区版(Centos7为例)</h3><ul>
<li>yum源使用阿里云的源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"><span class="comment"># 下载阿里云的yum源</span></span><br><span class="line">wget http<span class="string">"mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="string">mv CentOS-Base.repo CentOS-Base.repo.back</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mv Centos-7.repo CentOS-Base.repo</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重置yum源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo http://mirros.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装docker</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看阿里云上docker 源信息</span></span><br><span class="line">yum list docker-ce</span><br><span class="line"><span class="comment">#安装docker最新社区版</span></span><br><span class="line">yum -y install docker-ce</span><br><span class="line"><span class="comment">#查看docker信息</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment">#查看docker详细状态信息</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>








<p>参考资料<br><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">Docker — 从入门到实践</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2019/12/11/ElasticSearch/</url>
    <content><![CDATA[<p>ElasticSearch：全文搜索引擎，它可以快速存储，搜索和分析海量数据，用户包括：维基百科、Stack Overflow、GitHub</p>
<p>特点：不需要简表，配置字段等；只需要存json的文档；</p>
<p>通过docker安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span> docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span><br></pre></td></tr></table></figure>

<p>安装成功之后访问<code>http://localhost:9200/</code>即可见到对应信息</p>
<p>链接参考<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html" target="_blank" rel="noopener">docker安装ElasticSearch</a></p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang云存储实战</title>
    <url>/2019/12/10/Golang%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="3mysql"><a href="#3mysql" class="headerlink" title="3mysql"></a>3mysql</h3><p>数据库分表<br>水平分表：假设分成256张文件表，按文件Sha1值后两位来切分，则以：tb_${FILE_SHA1}[:-2]的规则到对应表进行存取。</p>
<p>// OnFileUploadFinished : 文件上传完成，保存meta （插入）<br>// GetFileMeta : 从mysql获取文件元信息（查询）<br>// UpdateFileLocation : 更新文件的存储地址(如文件被转移了)  （更新）<br>涉及源码：db(file.go   mysql(conn.go))</p>
<p>使用MySQL小结：<br>通过sql.DB来管理数据连接对象<br>通过sql.Open来创建协程安全的sql.DB<br>优先使用Prepared Statement</p>
<h3 id="4-1用户系统用户表设计-注册和登录"><a href="#4-1用户系统用户表设计-注册和登录" class="headerlink" title="4-1用户系统用户表设计(注册和登录)"></a>4-1用户系统用户表设计(注册和登录)</h3><p>由于原有情况下,唯一索引用在了字段phone上. 而当前插入表的sql语句中, user_name才是应该要保持唯一的, 因此相对于视频所演示的建表语句进行了更新, 具体如下: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tbl_user` ( </span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT, </span><br><span class="line">    `user_name` varchar(64) NOT NULL DEFAULT <span class="string">''</span> COMMENT <span class="string">'用户名'</span>, </span><br><span class="line">    `user_pwd` varchar(256) NOT NULL DEFAULT <span class="string">''</span> COMMENT <span class="string">'用户encoded密码'</span>, </span><br><span class="line">    `email` varchar(64) DEFAULT <span class="string">''</span> COMMENT <span class="string">'邮箱'</span>, </span><br><span class="line">    `phone` varchar(128) DEFAULT <span class="string">''</span> COMMENT <span class="string">'手机号'</span>, </span><br><span class="line">    `email_validated` tinyint(1) DEFAULT 0 COMMENT <span class="string">'邮箱是否已验证'</span>, </span><br><span class="line">    `phone_validated` tinyint(1) DEFAULT 0 COMMENT <span class="string">'手机号是否已验证'</span>, </span><br><span class="line">    `signup_at` datetime DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'注册日期'</span>, </span><br><span class="line">    `last_active` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">'最后活跃时间戳'</span>, </span><br><span class="line">    `profile` text COMMENT <span class="string">'用户属性'</span>, </span><br><span class="line">    `status` int(11) NOT NULL DEFAULT <span class="string">'0'</span> COMMENT <span class="string">'账户状态(启用/禁用/锁定/标记删除等)'</span>, </span><br><span class="line">    PRIMARY KEY (`id`), </span><br><span class="line">    UNIQUE KEY `idx_username` (`user_name`), </span><br><span class="line">    KEY `idx_status` (`status`) </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>

<p>登录<br>// 1. 校验用户名及密码<br>// 2. 生成访问凭证(token)<br>// 3. 登录成功后重定向到首页<br>涉及源码：<br>db(user.go )<br>handle(user.go)</p>
<p>访问鉴权（验证token的拦截器）<br>handler(auth.go)</p>
<h3 id="5-hash算法对比以及秒传原理"><a href="#5-hash算法对比以及秒传原理" class="headerlink" title="5.hash算法对比以及秒传原理"></a>5.hash算法对比以及秒传原理</h3><h3 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6.Redis"></a>6.Redis</h3><p>分块上传与断点续传<br>分块上传：文件切成多块，独立上传，上传完成后合并（初始化上传-&gt;上传分块（并行）-&gt;通知上传完成）<br>断点续传：传输暂停或一场终端后，可基于原来进度重传</p>
<p>小文件不建议分块上传<br>可以并行上传分块，并且可以无序传输<br>分块上传能极大提高传输效率<br>减少传输失败后重试的流量和时间</p>
<p>初始化分块信息<br>上传分块<br>通知分块上传完成<br>取消上传分块<br>查看分块上传的整体状态</p>
<p>涉及源码：<br>cache(redis(conn.go))</p>
<p>handler(mpupload.go)</p>
<h3 id="7-Ceph"><a href="#7-Ceph" class="headerlink" title="7.Ceph"></a>7.Ceph</h3><p>Ceph:redhat开源出来的分布式存储系统</p>
<h3 id="8-阿里云对象存储OSS"><a href="#8-阿里云对象存储OSS" class="headerlink" title="8.阿里云对象存储OSS"></a>8.阿里云对象存储OSS</h3><h4 id="8-3-OSS术语"><a href="#8-3-OSS术语" class="headerlink" title="8-3 OSS术语"></a>8-3 OSS术语</h4><p><img src="/2019/12/10/Golang%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/oss01.png" alt="oss01.png"></p>
<h4 id="8-4-OSS网页具体操作"><a href="#8-4-OSS网页具体操作" class="headerlink" title="8-4 OSS网页具体操作"></a>8-4 OSS网页具体操作</h4><h3 id="9-RabbitMQ"><a href="#9-RabbitMQ" class="headerlink" title="9.RabbitMQ"></a>9.RabbitMQ</h3><p>RabbitMQ:一种开源的消息代理</p>
<h3 id="10-微服务"><a href="#10-微服务" class="headerlink" title="10.微服务"></a>10.微服务</h3><p><img src="/2019/12/10/Golang%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" alt="微服务架构图"></p>
<h4 id="基于gin改造用户service"><a href="#基于gin改造用户service" class="headerlink" title="基于gin改造用户service"></a>基于gin改造用户service</h4><h4 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h4><h3 id="源码说明"><a href="#源码说明" class="headerlink" title="源码说明:"></a>源码说明:</h3><ul>
<li>master分支: 通过原生net/http实现各接口功能</li>
<li>gin分支: 通过Gin框架来改造(微服务化章节之后主要基于Gin框架来进行演示)</li>
<li>pkg分支: 通过go-bindata等工具实现静态资源打包的一个示例</li>
<li>第九章(RabbitMQ异步存储)章节的代码，可以下载标签为<code>v0.3</code>的版本</li>
<li>第八章(OSS)及之前章节的代码，可以下载标签为<code>v0.2</code>的版本</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>Go入门: <a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="noopener">语言之旅</a></li>
<li>MySQL: <a href="https://chhy2009.github.io/document/mysql-reference-manual.pdf" target="_blank" rel="noopener">偶然翻到的一位大牛翻译的使用手册</a></li>
<li>Redis: <a href="http://redisdoc.com/" target="_blank" rel="noopener">命令手册</a></li>
<li>Ceph: <a href="http://ceph.org.cn/" target="_blank" rel="noopener">中文社区</a> <a href="http://docs.ceph.org.cn/" target="_blank" rel="noopener">中文文档</a></li>
<li>RabbitMQ: <a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">英文官方</a> <a href="http://rabbitmq.mr-ping.com/" target="_blank" rel="noopener">一个中文版文档</a></li>
<li>阿里云OSS: <a href="https://help.aliyun.com/product/31815.html?spm=a2c4g.750001.3.1.47287b13LQI3Ah" target="_blank" rel="noopener">文档首页</a></li>
<li>gRPC: <a href="http://doc.oschina.net/grpc?t=56831" target="_blank" rel="noopener">官方文档中文版</a></li>
<li>k8s: <a href="https://www.kubernetes.org.cn/docs" target="_blank" rel="noopener">中文社区</a></li>
<li>我的手记博客 <a href="http://www.imooc.com/u/6198190" target="_blank" rel="noopener">http://www.imooc.com/u/6198190</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>AFN表单形式提交图片</title>
    <url>/2019/11/15/AFN%E8%A1%A8%E5%8D%95%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BA%A4%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>PromiseKit</title>
    <url>/2019/11/05/PromiseKit/</url>
    <content><![CDATA[<h1 id="then-and-done"><a href="#then-and-done" class="headerlink" title="then and done"></a><code>then</code> and <code>done</code></h1><p>典型使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这段代码使用了<code>completion handlers</code>，它将如下所示:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> creds = creds &#123;</span><br><span class="line">        fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> image = image &#123;</span><br><span class="line">                <span class="keyword">self</span>.imageView = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>then</code> 只是构造<code>completion handlers</code>的另一种方式, 但也远不止如此。在我们理解的最初阶段，它主要有助于可读性。上面的<code>promise链</code>很容易浏览和理解:一个异步操作一行一行地通向另一个。鉴于Swift的当前状态，它尽可能接近程序代码。</p>
<p><code>done</code> 和 <code>then</code> ，但是你不能返回一个<code>promise</code>. 这通常是链条中<code>success</code>部分的终点. 上面, 您可以看到我们在 <code>done</code> 时收到了最终的图像，并使用它来设置用户界面。</p>
<p>两种实现方法的比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Creds</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Compared with:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(completion: <span class="params">(Creds?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">                        <span class="comment">// ^^ ugh. Optionals. Double optionals.</span></span><br></pre></td></tr></table></figure>

<p>区别在于，对于<code>Promise</code>，您的函数返回<code>Promise</code>，而不是接受和运行回调。链中的每个<code>handler</code>都会返回一个<code>Promise</code>。<code>Promise</code>对象定义了<code>then</code>方法，该方法在链的执行之前等待<code>Promise</code>的完成。锁链按程序解决，一次一个<code>Promise</code>。</p>
<p><code>Promise</code> 代表异步任务的返回值。它有一个表示它包装的对象类型的类型。例如，在上面的例子中，<code>login</code>是一个返回<code>Promise</code>的函数，该<code>Promise</code>将代表Creds实例。</p>
<blockquote>
<p><em>Note</em>: <code>done</code> is new to PromiseKit 5. We previously defined a variant of <code>then</code> that<br>did not require you to return a promise. Unfortunately, this convention often confused<br>Swift and led to odd and hard-to-debug error messages. It also made using PromiseKit<br>more painful. The introduction of <code>done</code> lets you type out promise chains that<br>compile without additional qualification to help the compiler figure out type information.</p>
</blockquote>
<hr>
<p>您可能会注意到，与completion模式不同，promise链似乎<br>忽略errors。事实并非如此！事实上，它有相反的效果:promise<br>链使得errors处理更容易访问，也使得errors更难忽略。</p>
<h1 id="catch"><a href="#catch" class="headerlink" title="catch"></a><code>catch</code></h1><p>有了promise，errors就会沿着promise链级联，确保你的应用程序<br>健壮，代码清晰:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// any errors in the whole chain land here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Swift emits a warning if you forget to <code>catch</code> a chain. But we’ll<br>talk about that in more detail later.</p>
</blockquote>
<p>每个promise都是一个对象，代表一个单独的异步任务。<br>如果任务失败， promise就会变成rejected。 Chains that contain rejected<br>包含rejected的promise链跳过所有后续的promise。相反，执行下一个捕获。<br>(严格来说，所有后续的捕获处理程序都会被执行。)</p>
<p><code>completion handler</code>与<code>promise</code>的比较</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>guard</code>和<code>error handler</code>的使用有所帮助，但是promise链<br>可读性不言自明。</p>
<h1 id="ensure"><a href="#ensure" class="headerlink" title="ensure"></a><code>ensure</code></h1><p>我们已经学会了合成异步性。接下来，让我们扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> login()</span><br><span class="line">&#125;.then &#123;</span><br><span class="line">    fetch(avatar: $<span class="number">0</span>.user)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView = $<span class="number">0</span></span><br><span class="line">&#125;.ensure &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管你的链条的结果是什么——失败还是成功 <code>ensure</code><br>handler 总是被调用.</p>
<p><code>ensure</code>模式与其等价的完成处理程序进行比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">        <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对某人来说，修改这个代码并忘记取消设置是非常容易的<br>导致错误的活动指示器。有了promises，这种类型的错误是<br>几乎不可能:Swift编译器拒绝你在没有<br>使用promises。您几乎不需要审查拉动式请求。</p>
<blockquote>
<p><em>Note</em>: PromiseKit has perhaps capriciously switched between the names <code>always</code><br>and <code>ensure</code> for this function several times in the past. Sorry about this. We suck.</p>
</blockquote>
<p>You can also use <code>finally</code> as an <code>ensure</code> that terminates the promise chain and does not return a value:<br>您也可以使用<code>finally</code>作为结束的promise链且不返回值的<code>ensure</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spinner(visible: true)</span><br><span class="line"></span><br><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.catch &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.finally &#123;</span><br><span class="line">    self.spinner(visible: false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h1><p>对多个异步操作的completion handlers反应是缓慢的，意味着连续执行:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operation1 &#123; result1 <span class="keyword">in</span></span><br><span class="line">    operation2 &#123; result2 <span class="keyword">in</span></span><br><span class="line">        finish(result1, result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速(<em>parallel</em>)路径代码使代码不太清晰</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result1: …!</span><br><span class="line"><span class="keyword">var</span> result2: …!</span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">group.enter()</span><br><span class="line">group.enter()</span><br><span class="line">operation1 &#123;</span><br><span class="line">    result1 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">operation2 &#123;</span><br><span class="line">    result2 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    finish(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用Promises就更清晰了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    when(fulfilled: operation1(), operation2())</span><br><span class="line">&#125;.done &#123; result1, result2 <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>when</code> promise代表：等待它们解决并返回包含结果的promise。</p>
<p>与任何promise链一样，如果任何组件promise失败，该链将调用下一个<code>catch</code>。</p>
<h1 id="PromiseKit-Extensions"><a href="#PromiseKit-Extensions" class="headerlink" title="PromiseKit Extensions"></a>PromiseKit Extensions</h1><p>当我们使用PromiseKit, 我们是想想通过promise来实现<br>异步行为。因此，只要有可能，我们会对苹果的APIs进行扩展，重新构建<br>promise方面的应用编程接口。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">CLLocationManager</span>.promise()</span><br><span class="line">&#125;.then &#123; location <span class="keyword">in</span></span><br><span class="line">    <span class="type">CLGeocoder</span>.reverseGeocode(location)</span><br><span class="line">&#125;.done &#123; placemarks <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.placemark.text = <span class="string">"\(placemarks.first)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用这些扩展，您需要指定子代码:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">"PromiseKit"</span></span><br><span class="line">pod <span class="string">"PromiseKit/CoreLocation"</span></span><br><span class="line">pod <span class="string">"PromiseKit/MapKit"</span></span><br></pre></td></tr></table></figure>

<p>All of these extensions are available at the <a href="https://github.com/PromiseKit" target="_blank" rel="noopener">PromiseKit organization</a>.<br>Go there to see what’s available and to read the source code and documentation. Every file and function<br>has been copiously documented.</p>
<blockquote>
<p>We also provide extensions for common libraries such as <a href="https://github.com/PromiseKit/Alamofire-" target="_blank" rel="noopener">Alamofire</a>.</p>
</blockquote>
<h1 id="Making-Promises"><a href="#Making-Promises" class="headerlink" title="Making Promises"></a>Making Promises</h1><p>The standard extensions will take you a long way, but sometimes you’ll still need to start chains<br>of your own. Maybe you’re using a third party API that doesn’t provide promises, or perhaps you wrote<br>your own asynchronous system. Either way, it’s easy to add promises. If you look at the code of the<br>standard extensions, you’ll see that it uses the same approach  described below.</p>
<p>标准的扩展会让你走很长一段路，但是有时候你仍然需要启动链<br>你自己的。也许你使用的是不提供promises的第三方应用编程接口，或者你写道<br>你自己的异步系统。不管怎样，添加promises都很容易。如果你看看<br>标准扩展，您会看到它使用了下面描述的相同方法。</p>
<p>Let’s say we have the following method:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(completion: <span class="params">(String?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>

<p>How do we convert this to a promise? Well, it’s easy:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; fetch(completion: $<span class="number">0</span>.resolve) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You may find the expanded version more readable:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result, error <span class="keyword">in</span></span><br><span class="line">            seal.resolve(result, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>seal</code> object that the <code>Promise</code> initializer provides to you defines<br>many methods for handling garden-variety completion handlers. It even<br>covers a variety of rarer situations, thus making it easy for you to add<br>promises to an existing codebase.</p>
<blockquote>
<p><em>Note</em>: We tried to make it so that you could just do <code>Promise(fetch)</code>, but we<br>were not able to make this simpler pattern work universally without requiring<br>extra disambiguation for the Swift compiler. Sorry; we tried.</p>
</blockquote>
<blockquote>
<p><em>Note</em>: In PMK 4, this initializer provided two parameters to your closure:<br><code>fulfill</code> and <code>reject</code>. PMK 5 and 6 give you an object that has both <code>fulfill</code> and<br><code>reject</code> methods, but also many variants of the method <code>resolve</code>. You can<br>typically just pass completion handler parameters to <code>resolve</code> and let Swift figure<br>out which variant to apply to your particular case (as shown in the example above).</p>
</blockquote>
<blockquote>
<p><em>Note</em> <code>Guarantees</code> (below) have a slightly different initializer (since they<br>cannot error) so the parameter to the initializer closure is just a closure. Not<br>a <code>Resolver</code> object. Thus do <code>seal(value)</code> rather than <code>seal.fulfill(value)</code>. This<br>is because there is no variations in what guarantees can be sealed with, they can<br><em>only</em> fulfill.</p>
</blockquote>
<h1 id="Guarantee-lt-T-gt"><a href="#Guarantee-lt-T-gt" class="headerlink" title="Guarantee&lt;T&gt;"></a><code>Guarantee&lt;T&gt;</code></h1><p>Since PromiseKit 5, we have provided <code>Guarantee</code> as a supplementary class to<br><code>Promise</code>. We do this to complement Swift’s strong error handling system.</p>
<p>Guarantees <em>never</em> fail, so they cannot be rejected. A good example is <code>after</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    after(seconds: 0.1)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    // there is no way to add a `catch` because after cannot fail.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift warns you if you don’t terminate a regular <code>Promise</code> chain (i.e., not<br>a <code>Guarantee</code> chain). You’re expected to silence this warning by supplying<br>either a <code>catch</code> or a <code>return</code>. (In the latter case, you will then have to <code>catch</code><br>at the point where you receive that promise.)</p>
<p>Use <code>Guarantee</code>s wherever possible so that your code has error handling where<br>it’s required and no error handling where it’s not required.</p>
<p>In general, you should be able to use <code>Guarantee</code>s and <code>Promise</code>s interchangeably,<br>We have gone to great lengths to try and ensure this, so please open a ticket<br>if you find an issue.</p>
<hr>
<p>If you are creating your own guarantees the syntax is simpler than that of promises;</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result <span class="keyword">in</span></span><br><span class="line">            seal(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which could be reduced to:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span>(resolver: fetch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map-compactMap-etc"><a href="#map-compactMap-etc" class="headerlink" title="map, compactMap, etc."></a><code>map</code>, <code>compactMap</code>, etc.</h1><p><code>then</code> provides you with the result of the previous promise and requires you to return<br>another promise.</p>
<p><code>map</code> provides you with the result of the previous promise and requires you to return<br>an object or value type.</p>
<p><code>compactMap</code> provides you with the result of the previous promise and requires you<br>to return an <code>Optional</code>. If you return <code>nil</code>, the chain fails with<br><code>PMKError.compactMap</code>.</p>
<blockquote>
<p><em>Rationale</em>: Before PromiseKit 4, <code>then</code> handled all these cases, and it was<br>painful. We hoped the pain would disappear with new Swift versions. However,<br>it has become clear that the various pain points are here to stay. In fact, we<br>as library authors are expected to disambiguate at the naming level of our API.<br>Therefore, we have split the three main kinds of <code>then</code> into <code>then</code>, <code>map</code> and<br><code>done</code>. After using these new functions, we realized this is much nicer in practice,<br>so we added <code>compactMap</code> as well (modeled on <code>Optional.compactMap</code>).</p>
</blockquote>
<p><code>compactMap</code> facilitates quick composition of promise chains. For example:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">URLSession</span>.shared.dataTask(.promise, with: rq)</span><br><span class="line">&#125;.compactMap &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject($<span class="number">0</span>.data) <span class="keyword">as</span>? [<span class="type">String</span>]</span><br><span class="line">&#125;.done &#123; arrayOfStrings <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// Foundation.JSONError if JSON was badly formed</span></span><br><span class="line">    <span class="comment">// PMKError.compactMap if JSON was of different type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>Tip</em>: We also provide most of the functional methods you would expect for sequences,<br>e.g., <code>map</code>, <code>thenMap</code>, <code>compactMapValues</code>, <code>firstValue</code>, etc.</p>
</blockquote>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h1><p>We provide <code>get</code> as a <code>done</code> that returns the value fed to <code>get</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.<span class="keyword">get</span> &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.done &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// same foo!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="tap"><a href="#tap" class="headerlink" title="tap"></a><code>tap</code></h1><p>We provide <code>tap</code> for debugging. It’s the same as <code>get</code> but provides the<br><code>Result&lt;T&gt;</code> of the <code>Promise</code> so you can inspect the value of the chain at this<br>point without causing any side effects:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.tap &#123;</span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Supplement"><a href="#Supplement" class="headerlink" title="Supplement"></a>Supplement</h1><h2 id="firstly"><a href="#firstly" class="headerlink" title="firstly"></a><code>firstly</code></h2><p>We’ve used <code>firstly</code> several times on this page, but what is it, really? In fact,<br>it is just <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener">syntactic sugar</a>.<br>You don’t really need it, but it </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>PromiseKit</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/11/04/Vue/</url>
    <content><![CDATA[<p><a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">Vue官网</a></p>
<h1 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h1><p>在教程安装里给出了多种引入方式，具体<a href="[教程安装]（https://cn.vuejs.org/v2/guide/installation.html）">点击这里</a></p>
<h2 id="直接-lt-script-gt-引入"><a href="#直接-lt-script-gt-引入" class="headerlink" title="直接&lt;/script&gt;引入"></a>直接<code>&lt;/script&gt;</code>引入</h2><p>在编辑器上输入html回车，这时候就会自动补全以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span> dir=<span class="string">"ltr"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>引入 Vue</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在页面输出hello Vue,用浏览器打开文件并检验效果<code>&lt;div&gt;hello Vue&lt;/div&gt;</code></p>
<p>可以之后我们改造源文件让它与Vue产生关联：new 一个Vue实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,  //挂载到指定节点上</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">'Hello Vue!'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>所挂载的节点需要添加一个id<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></p>
<p>最终源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125; &#123;&#123;message + message&#125;&#125;</span><br><span class="line">        &lt;div :id=<span class="string">"message"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=<span class="string">"item in list"</span>&gt;</span><br><span class="line">                &lt;span v-if=<span class="string">"!item.del"</span>&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span v-else style=<span class="string">"text-decoration: line-through"</span>&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;button v-show=<span class="string">"!item.del"</span>&gt;删除&lt;/button&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: <span class="string">'hello world'</span>,</span><br><span class="line">                list: [&#123;</span><br><span class="line">                    title: <span class="string">'课程1'</span>,</span><br><span class="line">                    del: <span class="literal">false</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    title: <span class="string">'课程2'</span>,</span><br><span class="line">                    del: <span class="literal">true</span></span><br><span class="line">                &#125;],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>此时用浏览器打开即可见到显示Hello Vue!</p>
<p>参考官方demo <a href="https://scrimba.com/p/pXKqta/cQ3QVcr" target="_blank" rel="noopener">链接</a></p>
<h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><p>添加显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">"addMethod"</span>&gt;</span><br><span class="line">      &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span> value=<span class="string">""</span> v-model=<span class="string">"info"</span>&gt;</span><br><span class="line">      &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">"button"</span> @click=<span class="string">"handleClick"</span>&gt;add&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>v-model是Vue里面的双向绑定，</li>
<li>v-for是循环遍历</li>
<li>@click=”handleClick” 绑定方法</li>
<li>console.log(this.info) 打印信息，如何查看打印输出：浏览器-右键-检查-Console</li>
<li>handleClick方法生命在methods对象里面</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span> dir=<span class="string">"ltr"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &lt;div class=<span class="string">"addMethod"</span>&gt;</span><br><span class="line">      &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span> value=<span class="string">""</span> v-model=<span class="string">"info"</span>&gt;</span><br><span class="line">      &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">"button"</span> @click=<span class="string">"handleClick"</span>&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=<span class="string">"item in list"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,  //挂载到指定节点上</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">'Hello Vue!'</span>,</span><br><span class="line">        info: <span class="string">''</span>,</span><br><span class="line">        list:[],</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">handleClick</span></span>()&#123;</span><br><span class="line">          //console</span><br><span class="line">          this.list.push(this.info)</span><br><span class="line">          this.info = <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用自定义组件"><a href="#使用自定义组件" class="headerlink" title="使用自定义组件"></a>使用自定义组件</h2><p>定义名为 todo-item 的新组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>,&#123;</span><br><span class="line">      props:[<span class="string">'item'</span>],</span><br><span class="line">      template: <span class="string">'&lt;li class="item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建一个 todo-item 组件的实例，并传递属性值 <code>v-bind:item=&quot;item&quot;</code>或者简写成<code>:item=&quot;item&quot;</code><br><code>&lt;todo-item v-for=&quot;item in list&quot; :item=&quot;item&quot;&gt;&lt;/todo-item&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span> dir=<span class="string">"ltr"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style media=<span class="string">"screen"</span>&gt;</span><br><span class="line">      .item &#123;</span><br><span class="line">        color:red;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &lt;div class=<span class="string">"addMethod"</span>&gt;</span><br><span class="line">      &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span> value=<span class="string">""</span> v-model=<span class="string">"info"</span>&gt;</span><br><span class="line">      &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">"button"</span> @click=<span class="string">"handleClick"</span>&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;todo-item v-for=<span class="string">"item in list"</span> :item=<span class="string">"item"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/todo-item&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    Vue.component(<span class="string">'todo-item'</span>,&#123;</span><br><span class="line">      props:[<span class="string">'item'</span>],</span><br><span class="line">      template: <span class="string">'&lt;li class="item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,  //挂载到指定节点上</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">'Hello Vue!'</span>,</span><br><span class="line">        info: <span class="string">''</span>,</span><br><span class="line">        list:[],</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">handleClick</span></span>()&#123;</span><br><span class="line">          console.log(this.info)</span><br><span class="line">          this.list.push(this.info)//往list数组添加数据</span><br><span class="line">          this.info = <span class="string">''</span>//每次点击add的同时，清空输入框</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>以上操作有几个缺点</p>
<ul>
<li>全局定义：强制要求每个<code>component</code>中的命名不得重复</li>
<li>字符串模版：缺乏语法高亮，在html有多行的时候，需要用\</li>
<li>不支持CSS：意味着当html和JavaScript组件化时，CSS明显被遗漏</li>
<li>没有构建步骤：限制只能用html和ES5 JavaScript,而不能使用预处理器，如Pug(formerly Jade)和Babel，即每次都需要手动在浏览器上刷新，没有自动热更新。</li>
</ul>
<h2 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h2><p>安装Vue<code>bash npm install vue</code></p>
<p>安装命令行工具 (CLI)<a href="https://cli.vuejs.org/zh/guide/installation.html" target="_blank" rel="noopener">Vue CLI</a></p>
<p><code>npm install -g @vue/cli</code></p>
<p>出现安装问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm WARN deprecated joi@14.3.1: This module has moved and is now available at @hapi/joi. Please update your dependencies as this version is no longer maintained an may contain bugs and security issues.</span><br><span class="line">npm WARN deprecated topo@3.0.3: This module has moved and is now available at @hapi/topo. Please update your dependencies as this version is no longer maintained an may contain bugs and security issues.</span><br><span class="line">npm WARN deprecated hoek@6.1.3: This module has moved and is now available at @hapi/hoek. Please update your dependencies as this version is no longer maintained an may contain bugs and security issues.</span><br><span class="line">npm WARN deprecated cross-spawn-async@2.2.5: cross-spawn no longer requires a build toolchain, use it instead</span><br><span class="line">npm ERR! Unexpected end of JSON input <span class="keyword">while</span> parsing near <span class="string">'...TGOVzYcDOP1jLScCp0ACN'</span></span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /Users/sam/.npm/_logs/2019-04-29T01_23_19_163Z-debug.log</span><br></pre></td></tr></table></figure>

<p>清楚一下缓存<code>npm cache clean --force</code></p>
<p>运行<code>vue --version</code>出现版本信息则说明安装成功</p>
<p>创建新项目<code>vue create my-app</code></p>
<p>使用默认安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue CLI v3.7.0</span><br><span class="line">? Please pick a preset: (Use arrow keys)</span><br><span class="line">❯ default (babel, eslint)</span><br><span class="line">  Manually select features</span><br></pre></td></tr></table></figure>


<p>启动项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; my-app@0.1.0 serve /Users/sam/Documents/studyUp/my-app</span><br><span class="line">&gt; vue-cli-service serve</span><br><span class="line"></span><br><span class="line"> INFO  Starting development server...</span><br><span class="line"> 98% after emitting CopyPlugin                                                .</span><br><span class="line"> DONE  Compiled successfully <span class="keyword">in</span> 6412ms                               上午9:53:14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  App running at:</span><br><span class="line">  - Local:   http://localhost:8080/</span><br><span class="line">  - Network: http://192.168.43.116:8080/</span><br><span class="line"></span><br><span class="line">  Note that the development build is not optimized.</span><br><span class="line">  To create a production build, run npm run build.</span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">打开localhost:8080即可见到效果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 目录介绍</span></span><br><span class="line"></span><br><span class="line">![image.png](https://upload-images.jianshu.io/upload_images/3850802-8fcdd44c56b23d35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line"></span><br><span class="line">1 	node_modules 整个项目的依赖</span><br><span class="line"></span><br><span class="line">2	pubic ico 图标</span><br><span class="line"></span><br><span class="line">3	pubic index.html 整个项目的载体&lt;div id=<span class="string">"app"</span>&gt;&lt;/div&gt;  跟上面👆直接`&lt;/script&gt;`引入的div一样</span><br><span class="line"></span><br><span class="line">4	src 整个项目的源代码</span><br><span class="line"></span><br><span class="line">5	Main.js  项目入口文件</span><br><span class="line"></span><br><span class="line">6	babel.config.js  babel配置</span><br><span class="line"></span><br><span class="line">7	package.json 依赖包版本</span><br><span class="line"></span><br><span class="line">8	说明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将上面的直接&lt;/script&gt;引入的demo改成单文件形式👇三个模块独立</span><br><span class="line"></span><br><span class="line">- 模版 template</span><br><span class="line">- 逻辑 script</span><br><span class="line">- 样式 style</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;样式作用域只在该文件内有效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在App.vue文件的模版中替换`div`内容,新建主件TodoItem.vue,在App.vue引入并使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: [<span class="string">'item'</span>],</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.item &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &lt;div class=<span class="string">"addMethod"</span>&gt;</span><br><span class="line">      &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span> value=<span class="string">""</span> v-model=<span class="string">"info"</span>&gt;</span><br><span class="line">      &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">"button"</span> @click=<span class="string">"handleClick"</span>&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;todo-item v-for=<span class="string">"item in list"</span> :key=<span class="string">"item"</span> :item=<span class="string">"item"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/todo-item&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import TodoItem from <span class="string">'./components/TodoItem.vue'</span> //引入TodoItem</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        message: <span class="string">'hello vue'</span>,</span><br><span class="line">        info: <span class="string">''</span>,</span><br><span class="line">        list: [],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">        this.list.push(this.info)</span><br><span class="line">        this.info = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line">    TodoItem,       //注册TodoItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;todo-item v-for=<span class="string">"item in list"</span> :key=<span class="string">"item"</span> :item=<span class="string">"item"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/todo-item&gt;</span><br></pre></td></tr></table></figure>

<p>上面👆是通过属性来传递item，下面👇改成插槽的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">"font-size:20px"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>


<p>此时解析由<code>&lt;li class=&quot;item&quot;&gt;&lt;/li&gt;</code>改成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;li class=<span class="string">"item"</span>&gt;</span><br><span class="line">  &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>或者给插槽一个名字(具名插槽)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;todo-item v-for=<span class="string">"item in list"</span> :key=<span class="string">"item"</span>&gt;</span><br><span class="line">	&lt;template id=<span class="string">""</span> v-slot:item &gt;</span><br><span class="line">   		&lt;span style=<span class="string">"font-size:20px"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line">&lt;/todo-item&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"item"</span>&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>


<p>作用域插槽(使用场景：由子控件传递值给父控件，供父控件使用修改显示，选中由红变蓝)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;todo-item v-for=<span class="string">"item in list"</span> :key=<span class="string">"item"</span>&gt;</span><br><span class="line">   &lt;template id=<span class="string">""</span> v-slot:item=<span class="string">"itemProps"</span>&gt; 获取checked的值</span><br><span class="line">      &lt;span :style=<span class="string">"&#123;fontSize:'20px', color: itemProps.checked ? 'red' : 'blue' &#125;"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line">&lt;/todo-item&gt;</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> v-model=<span class="string">"checked"</span>&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"item"</span>  v-bind=<span class="string">"&#123;&#123;checked&#125;&#125;"</span>&gt;&lt;/slot&gt; //将checked 传递出去</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>


<p>动手复制代码跑来看看效果吧 👇👇👇👇👇👇👇👇👇</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;</span><br><span class="line">    &lt;input  <span class="built_in">type</span>=<span class="string">"checkbox"</span> v-model=<span class="string">"checked"</span>&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"item"</span>  v-bind=<span class="string">"&#123;checked&#125;"</span>&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: [<span class="string">'item'</span>],</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      checked:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.item &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &lt;div class=<span class="string">"addMethod"</span>&gt;</span><br><span class="line">      &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span> value=<span class="string">""</span> v-model=<span class="string">"info"</span>&gt;</span><br><span class="line">      &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> name=<span class="string">"button"</span> @click=<span class="string">"handleClick"</span>&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;todo-item v-for=<span class="string">"item in list"</span> :key=<span class="string">"item"</span>&gt;</span><br><span class="line">        &lt;template id=<span class="string">""</span> v-slot:item=<span class="string">"itemProps"</span>&gt;</span><br><span class="line">          &lt;span :style=<span class="string">"&#123;fontSize:'20px', color: itemProps.checked ? 'red' : 'blue' &#125;"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/todo-item&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import TodoItem from <span class="string">'./components/TodoItem.vue'</span> //引入TodoItem</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        message: <span class="string">'hello vue'</span>,</span><br><span class="line">        info: <span class="string">''</span>,</span><br><span class="line">        list: [],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">        this.list.push(this.info)</span><br><span class="line">        this.info = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line">    TodoItem,       //注册TodoItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">条件渲染官方文档地址</a><br><code>v-if</code><br><code>v-else</code><br><code>v-show</code><br><code>v-for</code></p>
<h1 id="组件基础-amp-组件注册"><a href="#组件基础-amp-组件注册" class="headerlink" title="组件基础&amp;组件注册"></a>组件基础&amp;组件注册</h1><p><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件基础</a></p>
<p><a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">组件注册</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125; &#123;&#123;message + message&#125;&#125;</span><br><span class="line">        &lt;div :id=<span class="string">"message"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;!-- &lt;ul&gt;</span><br><span class="line">            &lt;todo-item v-for=<span class="string">"item in list"</span> :title=<span class="string">"item.title"</span> :del=<span class="string">"item.del"</span>&gt;&lt;/todo-item&gt;</span><br><span class="line">        &lt;/ul&gt; --&gt;</span><br><span class="line">        &lt;todo-list&gt;&lt;/todo-list&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                title: String,</span><br><span class="line">                del: &#123;</span><br><span class="line">                    <span class="built_in">type</span>: Boolean,</span><br><span class="line">                    default: <span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            template: `</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;span v-if=<span class="string">"!del"</span>&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span v-else style=<span class="string">"text-decoration: line-through"</span>&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;button v-show=<span class="string">"!del"</span>&gt;删除&lt;/button&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          `,</span><br><span class="line">            data: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        Vue.component(<span class="string">'todo-list'</span>, &#123;</span><br><span class="line">            template: `</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;todo-item v-for=<span class="string">"item in list"</span> :title=<span class="string">"item.title"</span> :del=<span class="string">"item.del"</span>&gt;&lt;/todo-item&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          `,</span><br><span class="line">            data: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> &#123;</span><br><span class="line">                    list: [&#123;</span><br><span class="line">                        title: <span class="string">'课程1'</span>,</span><br><span class="line">                        del: <span class="literal">false</span></span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        title: <span class="string">'课程2'</span>,</span><br><span class="line">                        del: <span class="literal">true</span></span><br><span class="line">                    &#125;],</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: <span class="string">'hello world'</span>,</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<p>在Vue中,组件:小型的，一个个独立，可以复用的UI模块。它有三大概念：属性、事件、插槽</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">Prop</a></p>
<ul>
<li>自定义属性props<ul>
<li>组件props中声明的属性</li>
</ul>
</li>
<li>原生属性attrs<ul>
<li>没有生命的属性，默认自动挂载到组件根元素上</li>
<li>设置inheritAttrs 为false可以关闭自动挂载    </li>
</ul>
</li>
<li>特殊属性 class、style<ul>
<li>挂载到组件根元素上</li>
<li>支持字符串、对象、数组等多种语法</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    name: &#123;&#123; name &#125;&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    <span class="built_in">type</span>: &#123;&#123; <span class="built_in">type</span> &#125;&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    list: &#123;&#123; list &#125;&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    isVisible: &#123;&#123; isVisible &#125;&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"handleClick"</span>&gt;change <span class="built_in">type</span>&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">"PropsDemo"</span>,</span><br><span class="line">  // inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  // props: [<span class="string">'name'</span>, <span class="string">'type'</span>, <span class="string">'list'</span>, <span class="string">'isVisible'</span>],</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    <span class="built_in">type</span>: &#123;</span><br><span class="line">      validator: <span class="keyword">function</span>(value) &#123;</span><br><span class="line">        // 这个值必须匹配下列字符串中的一个</span><br><span class="line">        <span class="built_in">return</span> [<span class="string">"success"</span>, <span class="string">"warning"</span>, <span class="string">"danger"</span>].includes(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    list: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Array,</span><br><span class="line">      // 对象或数组默认值必须从一个工厂函数获取</span><br><span class="line">      default: () =&gt; []</span><br><span class="line">    &#125;,</span><br><span class="line">    isVisible: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Boolean,</span><br><span class="line">      default: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Function,</span><br><span class="line">      default: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">      // 不要这么做、不要这么做、不要这么做</span><br><span class="line">      // this.type = <span class="string">"warning"</span>;</span><br><span class="line">      // 可以，还可以更好</span><br><span class="line">      this.onChange(this.type === <span class="string">"success"</span> ? <span class="string">"warning"</span> : <span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>




<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">事件处理</a></p>
<ul>
<li><p>普通时间</p>
<ul>
<li>@click,@input,@change,@xxx等事件</li>
<li>通过this.$emit(‘xxx’,…)触发    </li>
</ul>
</li>
<li><p>修饰符事件</p>
<ul>
<li>@input.trim,@click.stop,@submit.prevent 等</li>
<li>一般用于原生html元素，自定义组件需要自行开发支持</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    name: &#123;&#123; name || <span class="string">"--"</span> &#125;&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;input :value=<span class="string">"name"</span> @change=<span class="string">"handleChange"</span> /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;div @click=<span class="string">"handleDivClick"</span>&gt;</span><br><span class="line">      &lt;button @click=<span class="string">"handleClick"</span>&gt;重置成功&lt;/button&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">      &lt;button @click.stop=<span class="string">"handleClick"</span>&gt;重置失败&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">"EventDemo"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange(e) &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">"change"</span>, e.target.value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">handleDivClick</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">"change"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick(e) &#123;</span><br><span class="line">      // 都会失败</span><br><span class="line">      //e.stopPropagation();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125; &#123;&#123;message + message&#125;&#125;</span><br><span class="line">        &lt;div :id=<span class="string">"message"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;!-- &lt;ul&gt;</span><br><span class="line">            &lt;todo-item v-for=<span class="string">"item in list"</span> :title=<span class="string">"item.title"</span> :del=<span class="string">"item.del"</span>&gt;&lt;/todo-item&gt;</span><br><span class="line">        &lt;/ul&gt; --&gt;</span><br><span class="line">        &lt;todo-list&gt;&lt;/todo-list&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                title: String,</span><br><span class="line">                del: &#123;</span><br><span class="line">                    <span class="built_in">type</span>: Boolean,</span><br><span class="line">                    default: <span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            template: `</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;span v-if=<span class="string">"!del"</span>&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span v-else style=<span class="string">"text-decoration: line-through"</span>&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;button v-show=<span class="string">"!del"</span> @click=<span class="string">"handleClick"</span>&gt;删除&lt;/button&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          `,</span><br><span class="line">            data: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                handleClick(e) &#123;</span><br><span class="line">                    console.log(<span class="string">'点击删除按钮'</span>)</span><br><span class="line">                    this.<span class="variable">$emit</span>(<span class="string">'delete'</span>, this.title)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        Vue.component(<span class="string">'todo-list'</span>, &#123;</span><br><span class="line">            template: `</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;todo-item @delete=<span class="string">"handleDelete"</span> v-for=<span class="string">"item in list"</span> :title=<span class="string">"item.title"</span> :del=<span class="string">"item.del"</span>&gt;&lt;/todo-item&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          `,</span><br><span class="line">            data: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> &#123;</span><br><span class="line">                    list: [&#123;</span><br><span class="line">                        title: <span class="string">'课程1'</span>,</span><br><span class="line">                        del: <span class="literal">false</span></span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        title: <span class="string">'课程2'</span>,</span><br><span class="line">                        del: <span class="literal">true</span></span><br><span class="line">                    &#125;],</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                handleDelete(val) &#123;</span><br><span class="line">                    console.log(<span class="string">'handleDelete'</span>, val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: <span class="string">'hello world'</span>,</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>




<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p><a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">插槽</a></p>
<ul>
<li>普通插槽<ul>
<li><code>&lt;template slot=&quot;xxx&quot;&gt;...&lt;/template&gt;</code></li>
<li><code>&lt;template v-slot:xxx&gt;...&lt;/template&gt;</code></li>
</ul>
</li>
</ul>
<ul>
<li>作用域插槽    <ul>
<li><code>&lt;template slot=&quot;xxx&quot; slot-scope=&quot;props&quot;&gt;...&lt;/template&gt;</code></li>
<li><code>&lt;template v-slot:xxx=&quot;props&quot;&gt;...&lt;/template&gt;</code></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot /&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"title"</span> /&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"item"</span> v-bind=<span class="string">"&#123; value: 'vue' &#125;"</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">"SlotDemo"</span></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">我们可以理解为万物皆“属性”，即它们都是父组件传递给子组件，然后子组件根据传递的内容来执行对应的行为。请看demo</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; name &#125;&#125;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"handleChange"</span>&gt;change name&lt;/button&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;!-- &#123;&#123; slotDefault &#125;&#125; --&gt;</span><br><span class="line">    &lt;VNodes :vnodes=<span class="string">"slotDefault"</span> /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;VNodes :vnodes=<span class="string">"slotTitle"</span> /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;VNodes :vnodes=<span class="string">"slotScopeItem(&#123; value: 'vue' &#125;)"</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">"BigProps"</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    VNodes: &#123;</span><br><span class="line">      functional: <span class="literal">true</span>,</span><br><span class="line">      render: (h, ctx) =&gt; ctx.props.vnodes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    onChange: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Function,</span><br><span class="line">      default: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    slotDefault: Array,</span><br><span class="line">    slotTitle: Array,</span><br><span class="line">    slotScopeItem: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Function,</span><br><span class="line">      default: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleChange</span></span>() &#123;</span><br><span class="line">      this.onChange(<span class="string">"Hello vue!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125; &#123;&#123;message + message&#125;&#125;</span><br><span class="line">        &lt;div :id=<span class="string">"message"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;!-- &lt;ul&gt;</span><br><span class="line">            &lt;todo-item v-for=<span class="string">"item in list"</span> :title=<span class="string">"item.title"</span> :del=<span class="string">"item.del"</span>&gt;&lt;/todo-item&gt;</span><br><span class="line">        &lt;/ul&gt; --&gt;</span><br><span class="line">        &lt;todo-list&gt;</span><br><span class="line">            &lt;todo-item @delete=<span class="string">"handleDelete"</span> v-for=<span class="string">"item in list"</span> :title=<span class="string">"item.title"</span> :del=<span class="string">"item.del"</span>&gt;</span><br><span class="line">                &lt;template v-slot:pre-icon=<span class="string">"&#123;value&#125;"</span>&gt;</span><br><span class="line">                    &lt;span&gt;前置图标 &#123;&#123;value&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/todo-item&gt;</span><br><span class="line">        &lt;/todo-list&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                title: String,</span><br><span class="line">                del: &#123;</span><br><span class="line">                    <span class="built_in">type</span>: Boolean,</span><br><span class="line">                    default: <span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            template: `</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;slot name=<span class="string">"pre-icon"</span> :value=<span class="string">"value"</span>&gt;&lt;/slot&gt;</span><br><span class="line">                &lt;span v-if=<span class="string">"!del"</span>&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span v-else style=<span class="string">"text-decoration: line-through"</span>&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;slot name=<span class="string">"suf-icon"</span>&gt;😄&lt;/slot&gt;</span><br><span class="line">                &lt;button v-show=<span class="string">"!del"</span> @click=<span class="string">"handleClick"</span>&gt;删除&lt;/button&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          `,</span><br><span class="line">            data: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> &#123;</span><br><span class="line">                    value: Math.random()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                handleClick(e) &#123;</span><br><span class="line">                    console.log(<span class="string">'点击删除按钮'</span>)</span><br><span class="line">                    this.<span class="variable">$emit</span>(<span class="string">'delete'</span>, this.title)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        Vue.component(<span class="string">'todo-list'</span>, &#123;</span><br><span class="line">            template: `</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          `,</span><br><span class="line">            data: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: <span class="string">'hello world'</span>,</span><br><span class="line">                list: [&#123;</span><br><span class="line">                    title: <span class="string">'课程1'</span>,</span><br><span class="line">                    del: <span class="literal">false</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    title: <span class="string">'课程2'</span>,</span><br><span class="line">                    del: <span class="literal">true</span></span><br><span class="line">                &#125;],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                handleDelete(val) &#123;</span><br><span class="line">                    console.log(<span class="string">'handleDelete'</span>, val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<h1 id="理解单文件组件"><a href="#理解单文件组件" class="headerlink" title="理解单文件组件"></a>理解单文件组件</h1><p>意思是通过<a href="https://cli.vuejs.org/" target="_blank" rel="noopener">Vue CLI</a>构建整个项目，而不是单个html文件。</p>
<h1 id="双向绑定和单向数据流不冲突"><a href="#双向绑定和单向数据流不冲突" class="headerlink" title="双向绑定和单向数据流不冲突"></a>双向绑定和单向数据流不冲突</h1><h2 id="v-model创建双向绑定"><a href="#v-model创建双向绑定" class="headerlink" title="v-model创建双向绑定"></a>v-model创建双向绑定</h2><p>双向绑定：数据更新时，视图同步更新；反过来视图更新时，数据也会更新。可以通过<code>v-model</code>来创建双向绑定。</p>
<p><a href="https://cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model" target="_blank" rel="noopener">v-model</a></p>
<p>文档在<a href="https://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="noopener">表单输入绑定</a>有说明：</p>
<blockquote>
<p>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
</blockquote>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">自定义组件的 v-model</a></p>
<h2 id="sync修饰符-创建双向绑定"><a href="#sync修饰符-创建双向绑定" class="headerlink" title=".sync修饰符 创建双向绑定"></a>.sync修饰符 创建双向绑定</h2><p><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">.sync 修饰符</a></p>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81" target="_blank" rel="noopener">单向数据流</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Vue是单向数据流，不是双向绑定</li>
<li>Vue的双向绑定不过是语法糖</li>
<li>Object.defineProperty是用来做响应式更新的，和双向绑定没关系</li>
<li>v-model来实现双向绑定的实质是：属性的传递和事件的回调来做一个数据更新。所以说它仅仅是语法糖而已。</li>
</ul>
<h1 id="如何触发组件的更新"><a href="#如何触发组件的更新" class="headerlink" title="如何触发组件的更新"></a>如何触发组件的更新</h1><p>数据来源（单向的）</p>
<ul>
<li>来自父类元素的属性</li>
<li>来自组件自身的状态 data</li>
<li>来自状态管理器</li>
</ul>
<p>状态data 和 属性props 区别</p>
<ul>
<li>状态是组件自身的数据</li>
<li>属性来自父组件的数据</li>
<li>状态或者属性的改变未必会让视图更新（只有做了响应才会更新，即放在了return里面）</li>
</ul>
<h1 id="合理应用计算属性和侦听器"><a href="#合理应用计算属性和侦听器" class="headerlink" title="合理应用计算属性和侦听器"></a>合理应用计算属性和侦听器</h1><p>　<br>计算属性computed</p>
<ul>
<li>减少模版中的计算逻辑</li>
<li>数据缓存</li>
<li>以来固定的数据类型（响应式编程）</li>
</ul>
<p>侦听器watch中可以执行任何逻辑，如函数节流，Ajax异步获取数据，甚至操作com</p>
<p>总之，computed能做的，watch都能做，反之则不行；能用computed的尽量用computed；</p>
<h1 id="生命周期的应用场景和函数式组件"><a href="#生命周期的应用场景和函数式组件" class="headerlink" title="生命周期的应用场景和函数式组件"></a>生命周期的应用场景和函数式组件</h1><p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期图示</a></p>
<p>函数式组件</p>
<ul>
<li>functional:true 可以将它看作一个方法</li>
<li>无状态、无实力、没有this上下文、无生命周期</li>
</ul>
<h1 id="指令的本质是什么"><a href="#指令的本质是什么" class="headerlink" title="指令的本质是什么"></a>指令的本质是什么</h1><p><a href="https://github.com/tangjinzhou/geektime-vue-1/tree/master/%E6%BC%94%E7%A4%BADEMO%E6%BA%90%E7%A0%81/src/views/1.7" target="_blank" rel="noopener">源码演示</a></p>
<h1 id="provide-amp-inject"><a href="#provide-amp-inject" class="headerlink" title="provide &amp; inject"></a>provide &amp; inject</h1><p><a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provide / inject</a></p>
<p><a href="https://github.com/tangjinzhou/geektime-vue-1/tree/master/%E6%BC%94%E7%A4%BADEMO%E6%BA%90%E7%A0%81/src/views/1.8" target="_blank" rel="noopener">源码演示</a></p>
<p>解决跨组件间的属性传递问题。</p>
<h1 id="获取跨层级组件实例"><a href="#获取跨层级组件实例" class="headerlink" title="获取跨层级组件实例"></a>获取跨层级组件实例</h1><p><a href="https://github.com/tangjinzhou/geektime-vue-1/tree/master/%E6%BC%94%E7%A4%BADEMO%E6%BA%90%E7%A0%81/src/views/1.9" target="_blank" rel="noopener">源码演示</a></p>
<h1 id="template-VS-JSX"><a href="#template-VS-JSX" class="headerlink" title="template VS JSX"></a>template VS JSX</h1><p><a href="https://github.com/tangjinzhou/geektime-vue-1/tree/master/%E6%BC%94%E7%A4%BADEMO%E6%BA%90%E7%A0%81/src/views/1.10" target="_blank" rel="noopener">源码演示</a></p>
<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex</a> 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<ul>
<li>state，驱动应用的数据源；</li>
<li>view，以声明方式将 state 映射到视图；</li>
<li>actions，响应在 view 上的用户输入导致的状态变化。
　<h1 id="在Vue中使用Vuex"><a href="#在Vue中使用Vuex" class="headerlink" title="在Vue中使用Vuex"></a>在Vue中使用Vuex</h1></li>
</ul>
<p><a href="https://github.com/tangjinzhou/geektime-vue-1/tree/master/vuex-demo1" target="_blank" rel="noopener">源码演示</a></p>
<h1 id="Vuex原理"><a href="#Vuex原理" class="headerlink" title="Vuex原理"></a>Vuex原理</h1><ul>
<li><code>State</code>提供一个响应式数据</li>
<li><code>Getter</code>借助Vue的计算属性computed来实现缓存</li>
<li><code>Mutation</code>更改state方法</li>
<li><code>Action</code>触发mutation方法</li>
<li><code>Module</code>Vue.set动态添加state到响应式数据中</li>
</ul>
<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">Vue Router</a></p>
<p><a href="https://github.com/tangjinzhou/geektime-vue-1/tree/master/router-demo" target="_blank" rel="noopener">源码演示</a></p>
<h1 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h1><p><a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">Nuxt</a></p>
<h1 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h1><p>vs code插件：Vetur：代码块功能</p>
<p>ESLint:代码规范、错误检查、</p>
<p>Prettier:代码规范提示</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>三种方式：</p>
<ul>
<li>jest或者mocha</li>
<li>@vue/test-utils</li>
<li>sinon</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create XX</span><br><span class="line">Manually select features</span><br><span class="line">除了默认之外还需要勾选 Unit Testing</span><br><span class="line">选用ESLint + Standard config </span><br><span class="line">Lint on save</span><br><span class="line">JEST</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/geektime-geekbang/geektime-vue-1/tree/master/test-demo" target="_blank" rel="noopener">demo</a></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Vue_app git:(master) vue create  vue-app</span><br></pre></td></tr></table></figure>

<p>手动选择</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ◉ Babel</span><br><span class="line"> ◯ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◉ Router</span><br><span class="line"> ◉ Vuex</span><br><span class="line"> ◉ CSS Pre-processors</span><br><span class="line"> ◉ Linter / Formatter</span><br><span class="line">❯◉ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure>

<p>其他选项<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router? (Requires proper server setup <span class="keyword">for</span> index fallback <span class="keyword">in</span> produc</span><br><span class="line">tion) Yes</span><br><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by defaul</span><br><span class="line">t): Less</span><br><span class="line">? Pick a linter / formatter config: Prettier</span><br><span class="line">? Pick additional lint features: </span><br><span class="line"> ◉ Lint on save</span><br><span class="line">❯◉ Lint and fix on commit</span><br><span class="line">? Pick additional lint features: Lint on save, Lint and fix on commit</span><br><span class="line">? Pick a unit testing solution: Jest</span><br><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, ESLint, etc.? In dedicated config files</span><br><span class="line">? Save this as a preset <span class="keyword">for</span> future projects? Yes</span><br><span class="line">? Save preset as: vue-app</span><br><span class="line">? Pick the package manager to use when installing dependencies: Yarn</span><br></pre></td></tr></table></figure></p>
<p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vue-app</span><br><span class="line">$ yarn serve</span><br></pre></td></tr></table></figure>

<p>安装两个依赖包（上面步骤创建工程时选择了Yarn构建，现在通过npm安装依赖包也是可以的原来）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i ant-design-vue moment</span><br></pre></td></tr></table></figure>

<h2 id="更改构建方式"><a href="#更改构建方式" class="headerlink" title="更改构建方式"></a>更改构建方式</h2><p><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create" target="_blank" rel="noopener">文档说明</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.vuerc </span><br><span class="line">修改： <span class="string">"packageManager"</span>: <span class="string">"yarn"</span>, <span class="comment">#或者是npm</span></span><br><span class="line"><span class="built_in">source</span>  ~/.vuerc</span><br></pre></td></tr></table></figure>

<p>我自己也重新操作了一下，项目构建成功之后的提示为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vue-app</span><br><span class="line">$ npm run serve</span><br></pre></td></tr></table></figure>


<h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> ERROR  Failed to compile with 1 errors                                                            7:20:06 PM</span><br><span class="line"></span><br><span class="line"> error  <span class="keyword">in</span> ./node_modules/ant-design-vue/dist/antd.less</span><br><span class="line"></span><br><span class="line">Module build failed (from ./node_modules/less-loader/dist/cjs.js):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// https://github.com/ant-design/ant-motion/issues/44</span><br><span class="line">.bezierEasingMixin();</span><br><span class="line">^</span><br><span class="line">Inline JavaScript is not enabled. Is it <span class="built_in">set</span> <span class="keyword">in</span> your options?</span><br><span class="line">      <span class="keyword">in</span> /Users/samtake/Documents/GitHub/Vue_app/vue-app/node_modules/ant-design-vue/lib/style/color/bezierEa</span><br><span class="line">sing.less (line 110, column 0)</span><br><span class="line"></span><br><span class="line"> @ ./node_modules/ant-design-vue/dist/antd.less 4:14-188 14:3-18:5 15:22-196</span><br><span class="line"> @ ./src/main.js</span><br><span class="line"> @ multi (webpack)-dev-server/client?http://192.168.0.103:8086/sockjs-node (webpack)/hot/dev-server.js ./src/</span><br><span class="line">main.js</span><br></pre></td></tr></table></figure>


<p> <a href="https://cli.vuejs.org/zh/config/#css-loaderoptions" target="_blank" rel="noopener">css.loaderOptions</a></p>
<p> 新建一个<code>vue.config.js</code>文件<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    css: &#123;</span><br><span class="line">        loaderOptions: &#123;</span><br><span class="line">          less: &#123;</span><br><span class="line">            // 这里的选项会传递给 css-loader</span><br><span class="line">            javascriptEnabled:<span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重新启动构建<code>npm run serve</code></p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p><a href="https://www.antdv.com/docs/vue/introduce-cn/#%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener">文档</a></p>
<p>配置babel.config.js文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123; <span class="string">"libraryName"</span>: <span class="string">"ant-design-vue"</span>, <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>, <span class="string">"style"</span>: <span class="literal">true</span> &#125;] // `style: <span class="literal">true</span>` 会加载 less 文件</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">import  &#123;Button&#125;  from <span class="string">'ant-design-vue'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm i --save-dev babel-plugin-import</span><br></pre></td></tr></table></figure>


<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>同时刷新URL路径的插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i nprogress</span><br></pre></td></tr></table></figure>


<p>有两种加载方式，推荐这种：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">component: &#123; render: h =&gt; h(<span class="string">"router-view"</span>) &#125;,</span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">"nav"</span>&gt;</span><br><span class="line">      &lt;router-link to=<span class="string">"/dashboard/analysis"</span>&gt;dashboard&lt;/router-link&gt; |</span><br><span class="line">      &lt;router-link to=<span class="string">"/form"</span>&gt;form&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">"less"</span>&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>BasicLayout.vue</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;SiderMenu /&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;Footer /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from <span class="string">"./Header"</span>;</span><br><span class="line">import Footer from <span class="string">"./Footer"</span>;</span><br><span class="line">import SiderMenu from <span class="string">"./SiderMenu"</span>;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Header,</span><br><span class="line">    Footer,</span><br><span class="line">    SiderMenu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><a href="https://www.antdv.com/components/layout-cn/" target="_blank" rel="noopener">Layout 布局</a></p>
<h2 id="菜单和路由的结合"><a href="#菜单和路由的结合" class="headerlink" title="菜单和路由的结合"></a>菜单和路由的结合</h2><p><code>layouts</code>文件夹是菜单的布局</p>
<p><code>router.js</code></p>
<ul>
<li>有name的才会渲染到菜单</li>
<li>不渲染到菜单，可以添加标志位<code>hideInMenu: true,</code></li>
<li>如果不想让菜单的子路由渲染出来，可以添加标志位：<code>hideChildrenMenu: true,</code></li>
</ul>
<h2 id="如何使用echarts第三方库"><a href="#如何使用echarts第三方库" class="headerlink" title="如何使用echarts第三方库"></a>如何使用echarts第三方库</h2><ul>
<li>npm i  XX</li>
<li>在component文件夹中进行封装</li>
<li>第三方库<code>resize-detector</code>的作用是监听空间大小变化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=<span class="string">"chartDom"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import echarts from <span class="string">"echarts"</span>;</span><br><span class="line">import debounce from <span class="string">"lodash/debounce"</span>;</span><br><span class="line">import &#123; addListener, removeListener &#125; from <span class="string">"resize-detector"</span>;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    option: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Object,</span><br><span class="line">      default: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    option(val) &#123;</span><br><span class="line">      this.chart.setOption(val);</span><br><span class="line">    &#125;</span><br><span class="line">    // option: &#123;</span><br><span class="line">    //   handler(val) &#123;</span><br><span class="line">    //     this.chart.setOption(val);</span><br><span class="line">    //   &#125;,</span><br><span class="line">    //   deep: <span class="literal">true</span></span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span></span>() &#123;</span><br><span class="line">    this.resize = debounce(this.resize, 300);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    this.renderChart();</span><br><span class="line">    addListener(this.<span class="variable">$refs</span>.chartDom, this.resize);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeDestroy</span></span>() &#123;</span><br><span class="line">    removeListener(this.<span class="variable">$refs</span>.chartDom, this.resize);</span><br><span class="line">    this.chart.dispose();</span><br><span class="line">    this.chart = null;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">resize</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">"resize"</span>);</span><br><span class="line">      this.chart.resize();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">renderChart</span></span>() &#123;</span><br><span class="line">      // 基于准备好的dom，初始化echarts实例</span><br><span class="line">      this.chart = echarts.init(this.<span class="variable">$refs</span>.chartDom);</span><br><span class="line">      this.chart.setOption(this.option);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="mock的使用"><a href="#mock的使用" class="headerlink" title="mock的使用"></a>mock的使用</h2><p>1.在mock文件夹创建对应的js文件<br>2.在vue.config.js配置对应的代理<br>3.<code>axios</code>像正常那样请求数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">      proxy: &#123;</span><br><span class="line">        <span class="string">"/api"</span>: &#123;</span><br><span class="line">          target: <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">          bypass: <span class="keyword">function</span>(req, res) &#123;</span><br><span class="line">            <span class="keyword">if</span> (req.headers.accept.indexOf(<span class="string">"html"</span>) !== -1) &#123;</span><br><span class="line">              console.log(<span class="string">"Skipping proxy for browser request."</span>);</span><br><span class="line">              <span class="built_in">return</span> <span class="string">"/index.html"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.MOCK !== <span class="string">"none"</span>) &#123;</span><br><span class="line">              const name = req.path</span><br><span class="line">                .split(<span class="string">"/api/"</span>)[1]</span><br><span class="line">                .split(<span class="string">"/"</span>)</span><br><span class="line">                .join(<span class="string">"_"</span>);</span><br><span class="line">              const mock = require(`./mock/<span class="variable">$&#123;name&#125;</span>`);</span><br><span class="line">              const result = mock(req.method);</span><br><span class="line">              delete require.cache[require.resolve(`./mock/<span class="variable">$&#123;name&#125;</span>`)];</span><br><span class="line">              <span class="built_in">return</span> res.send(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>


<h2 id="axios的使用"><a href="#axios的使用" class="headerlink" title="axios的使用"></a>axios的使用</h2><ul>
<li>切换环境的时候需要执行<code>npm run serve:no-mock</code>才会请求真实服务器</li>
<li>一般都会对axios进行封装</li>
</ul>
<h2 id="表单的使用"><a href="#表单的使用" class="headerlink" title="表单的使用"></a>表单的使用</h2><h2 id="表单的自动校验"><a href="#表单的自动校验" class="headerlink" title="表单的自动校验"></a>表单的自动校验</h2><h2 id="分步表单（Vuex、Vue-router）"><a href="#分步表单（Vuex、Vue-router）" class="headerlink" title="分步表单（Vuex、Vue-router）"></a>分步表单（Vuex、Vue-router）</h2><ul>
<li>store-module-form.js</li>
</ul>
<h2 id="自己封装一个表单"><a href="#自己封装一个表单" class="headerlink" title="自己封装一个表单"></a>自己封装一个表单</h2><p>components-ReceiverAccount.vue</p>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>C++重温</title>
    <url>/2019/11/04/C++%E9%87%8D%E6%B8%A9/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3850802-c610324dffd5bcc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C艹.jpg"></p>
<p>demo链接🔗<a href="https://github.com/samtake/C-review" target="_blank" rel="noopener">https://github.com/samtake/C-review</a></p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>C++提供了程序内联机制来减少函数调用的开销。在函数定义的返回值类型前面加一个<code>inline</code>关键字，“建议”编译器函数代码复制到程序中，避免函数调用。<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">using std::cout;</span><br><span class="line">using std::cin;</span><br><span class="line">using std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline double cube(const double side)&#123;</span><br><span class="line">    <span class="built_in">return</span> side*side*side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">testInlineFunction</span></span>()&#123;</span><br><span class="line">    double sideValue;</span><br><span class="line">    <span class="keyword">for</span> (int i=1 ; i&lt;=3 ; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"enter the side length of your cube:"</span>;</span><br><span class="line">        cin &gt;&gt;sideValue;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">"side="</span> &lt;&lt; sideValue &lt;&lt; <span class="string">"cube="</span> &lt;&lt; cube(sideValue) &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>using std::cout;</code>using语句使我们不用重复写<code>std::</code>前缀；或者使用<code>using namespace std;</code>代替。</li>
</ul>
<h2 id="引用以及引用形参"><a href="#引用以及引用形参" class="headerlink" title="引用以及引用形参"></a>引用以及引用形参</h2><ul>
<li>两种传参方式是：按值传递和按引用传递。</li>
<li>采用按值传递方式传参时，首先生成实参值的副本，然后将该值传递给被调函数。改变副本的值不会影响主调函数中实参的值。</li>
<li>通过按引用传参，允许被调函数直接访问主调函数中的数据，允许被调函数有选择的修改主调函数中的数据。</li>
<li>引用实参是其对应的函数调用中实参的别名。</li>
<li>通过<code>&amp;</code>来标记按引用传参</li>
</ul>
<p>引用以和引用形参</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int squareByValue(int number)&#123;</span><br><span class="line">    <span class="built_in">return</span> number *=number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void squareByReference(int &amp;numberRef)&#123;</span><br><span class="line">    numberRef *=numberRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数体内引用作为别名<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int z = 3;</span><br><span class="line">    int &amp;z_alias = z;//int &amp;z_alias；</span><br><span class="line">    cout &lt;&lt; <span class="string">"z= "</span> &lt;&lt; z &lt;&lt; endl &lt;&lt; <span class="string">" z_alias = "</span>  &lt;&lt;  z_alias &lt;&lt; endl;</span><br><span class="line">    z = 7;</span><br><span class="line">    cout &lt;&lt; <span class="string">"z= "</span> &lt;&lt; z &lt;&lt; endl &lt;&lt; <span class="string">" z_alias = "</span>  &lt;&lt;  z_alias &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">z= 3</span><br><span class="line"> z_alias = 3</span><br><span class="line">z= 7</span><br><span class="line"> z_alias = 7</span><br></pre></td></tr></table></figure>
<p>并且为初始化的引用<code>int &amp;z_alias；</code>会导致错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Declaration of reference variable <span class="string">'z_alias'</span> requires an initializer</span><br></pre></td></tr></table></figure>

<h2 id="空形参列表"><a href="#空形参列表" class="headerlink" title="空形参列表"></a>空形参列表</h2><p>在C++中，可以用<code>void</code>指定也可以通过在括号内不写任何语句定义空形参列表。如下两个函数是等价的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">print</span>();</span><br><span class="line">void <span class="built_in">print</span>(void);</span><br></pre></td></tr></table></figure>
<h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><ul>
<li>有些程序在多次调用一个函数时经常将相同的实参传递给某个形参，这种情况下，可以将该形参指定默认实参，即传递给该形参的默认值。</li>
<li>当发生函数调用时，如果省略了对应位置上的实参值，则编译器就会重写该函数调用并将默认值作为实参插入到函数调用中，在执行被调函数时，以该形参的默认值进行运算。</li>
<li>默认实参必须是函数形参列表中最右边的实参。</li>
<li>应该在函数名第一次出现时指定默认实参–通常在函数原型中指定。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int boxVolume(int length = 1, int width = 1, int height = 1);</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">testDefaultArgument</span></span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"default = "</span> &lt;&lt;boxVolume() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"length  = 2 : "</span> &lt;&lt;boxVolume(2) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"length  = 2 , width =3 : "</span> &lt;&lt;boxVolume(2,3) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"length  = 2 , width =3 , height = 4 : "</span> &lt;&lt;boxVolume(2, 3, 4) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int boxVolume(int length, int width, int height)&#123;</span><br><span class="line">    <span class="built_in">return</span> length*width*height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一元作用域运算符"><a href="#一元作用域运算符" class="headerlink" title="一元作用域运算符"></a>一元作用域运算符</h2><p>C++提供了一元作用域运算符，可以在含有与全局变量名的局部变量的域中访问该全局变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int number = 7;</span><br><span class="line">void <span class="function"><span class="title">testUnaryOperation</span></span>()&#123;</span><br><span class="line">    double number = 10.7;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"location number = "</span> &lt;&lt; number &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"gloable number = "</span> &lt;&lt; ::number &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location number = 10.7</span><br><span class="line">gloable number = 7</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul>
<li>C++中允许定义同名的函数，只要这些函数具有不同的形参集合即可（至少在形参类型或形参个数或形参类型的顺序上有区别）。这个功能称为函数重载。</li>
<li>调用重载函数时，C++编译器通过检查函数调用语句中的实参个数、类型及顺序选择适当的函数。</li>
<li>重载函数由函数的签名进行区分。</li>
<li>编译器根据函数形参的个数与类型将每个函数标识符编码，以保证类型安全链接，从而确保可以调用适当的重载函数，也确保实参与形参类型一致。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void <span class="function"><span class="title">functionOverloading</span></span>()&#123;</span><br><span class="line">    cout &lt;&lt; square(7) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; square(0.5) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int square(int x)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"integer : "</span>;</span><br><span class="line">    <span class="built_in">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double square(double x)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"double : "</span>;</span><br><span class="line">    <span class="built_in">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">integer</span> : 49</span><br><span class="line">double : 0.25</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><p>重载函数用于对不同数据类型的程序逻辑执行相似操作。如果各种数据类型的程序逻辑和操作是完全相同的，那么使用函数模版可以更加简洁、方便的执行重载。</p>
<ul>
<li>所有函数模版定义均以关键字<code>template</code>开始，随后是用尖括号<code>&lt;&gt;</code>括起来的模版形参列表.</li>
<li>模版列表中的每个形参（称为形式类型形参）前面都加关键字<code>typename</code>和 <code>class</code>。两者含义相同。</li>
<li>形式类型形参是基本数据类型或用户定义类型的占位符<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">T maximum(T value1, T value2, T value3 ) &#123;</span><br><span class="line">    T maximumValue = value1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value2 &gt; maximumValue) &#123;</span><br><span class="line">        maximumValue = value2 ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value3 &gt; maximumValue) &#123;</span><br><span class="line">        maximumValue = value3 ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> maximumValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>在C++中通常有main函数以及一个或多个既包含数据成员也包含成员函数的类构成，所以：</p>
<ul>
<li>在一个类中，可提供一个或多个成员函数。</li>
<li>类似的，对象也有属性，在程序中使用对象时带有这些属性。这些属性是对象所属的类的一部分。</li>
</ul>
<h2 id="定义一个具有成员函数的类"><a href="#定义一个具有成员函数的类" class="headerlink" title="定义一个具有成员函数的类"></a>定义一个具有成员函数的类</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定义</span><br><span class="line">class GradeBook &#123;</span><br><span class="line">    //  </span><br><span class="line">public:</span><br><span class="line">    void <span class="function"><span class="title">displayMessage</span></span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"grade book"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">void <span class="function"><span class="title">funcTestGradeBook</span></span>()&#123;</span><br><span class="line">    GradeBook myGradeBook;</span><br><span class="line">    myGradeBook.displayMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">grade book</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>
<ul>
<li>类的定义由 <code>class</code>及随后的类名GradeBook开始，类名通常使用驼峰模式拼写，通常首字母大写。</li>
<li>每个类体由左右打括号<code>{}</code> 括起来。</li>
<li>类定义由<code>;</code>分号结束。</li>
<li>成员函数的访问限定符有：<code>public</code>、<code>private</code>、<code>protected</code>三种。</li>
<li>在定义函数时，必须指定返回值类型。</li>
<li>成员函数名后的空括号表示该成员函数不需要传参。</li>
</ul>
<h2 id="定义一个有参成员函数"><a href="#定义一个有参成员函数" class="headerlink" title="定义一个有参成员函数"></a>定义一个有参成员函数</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定义一个有参成员函数</span><br><span class="line">    void displayMessageWithParms(string courseName)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"grade book"</span>&lt;&lt; courseName &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string courseName;</span><br><span class="line">    cout&lt;&lt; <span class="string">"enter course name:"</span>&lt;&lt;endl;</span><br><span class="line">    getline(cin, courseName);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    myGradeBook.displayMessageWithParms(<span class="string">"Chinese"</span>);</span><br><span class="line">    myGradeBook.displayMessageWithParms(courseName);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enter course name:</span><br><span class="line">kjjkjkj</span><br><span class="line"></span><br><span class="line">grade bookChinese</span><br><span class="line">grade bookkjjkjkj</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>
<h2 id="数据成员、set函数与get函数"><a href="#数据成员、set函数与get函数" class="headerlink" title="数据成员、set函数与get函数"></a>数据成员、set函数与get函数</h2><ul>
<li>在函数定义体重声明的变量称为局部变量，它们只能在从声明它们的行到该函数定义的结束右打括号<code>}</code>的范围内使用。</li>
<li>类通常包含一个或多个成员函数来操作属于该类特定对象的属性。属性在类定义中表示为变量。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class GradeBookHaveLocalVariable&#123;</span><br><span class="line">public:</span><br><span class="line">    void setCourseName(string name)&#123;</span><br><span class="line">        courseName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    string <span class="function"><span class="title">getCourseName</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> courseName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">displayMessage</span></span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"course  name: "</span>&lt;&lt; getCourseName() &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义一个有参成员函数</span><br><span class="line">    void displayMessageWithParms(string courseName)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"grade book"</span>&lt;&lt; courseName &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string courseName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">course  name: 语文</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>

<h2 id="用构造函数初始化对象"><a href="#用构造函数初始化对象" class="headerlink" title="用构造函数初始化对象"></a>用构造函数初始化对象</h2><p>构造函数:</p>
<ul>
<li>用于在创建该类对象时初始化该对象。</li>
<li>是一个特殊的成员函数，它的名字必须与类名相同。</li>
<li>不能有返回值。</li>
<li>通常声明为<code>public</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class GradeBookConstructor&#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    GradeBookConstructor(string name)&#123;</span><br><span class="line">        setCourseName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void setCourseName(string name)&#123;</span><br><span class="line">        courseName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string <span class="function"><span class="title">getCourseName</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> courseName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void <span class="function"><span class="title">displayMessage</span></span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"course  name: "</span>&lt;&lt; getCourseName() &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //定义一个有参成员函数</span><br><span class="line">    void displayMessageWithParms(string courseName)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"grade book"</span>&lt;&lt; courseName &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    string courseName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">funcTestGradeBookConstructor</span></span>()&#123;</span><br><span class="line">    GradeBookConstructor myGradeBookConstructor1(<span class="string">"Constructor"</span>);</span><br><span class="line">    GradeBookConstructor myGradeBookConstructor2(<span class="string">"构造函数"</span>);</span><br><span class="line">    </span><br><span class="line">    myGradeBookConstructor1.displayMessage();</span><br><span class="line">    myGradeBookConstructor2.displayMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">course  name: Constructor</span><br><span class="line">course  name: 构造函数</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>


<h1 id="用set函数验证数据"><a href="#用set函数验证数据" class="headerlink" title="用set函数验证数据"></a>用set函数验证数据</h1><p>我们在<code>.h</code>文件中进行类的定义，并包含指定指定类的接口（类的<code>public</code>成员函数）的函数原形。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class VertifyWithSetFunc &#123;</span><br><span class="line">    //instance variables</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    VertifyWithSetFunc(string);</span><br><span class="line">    </span><br><span class="line">    void setCourseName(string);</span><br><span class="line">    string getCourseName();</span><br><span class="line">    </span><br><span class="line">    void displayMessage();</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    string courseName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在单独的源码文件中定义成员函数：每个成员函数名前面都有类名与二院作用域运算符<code>::</code>，这将每个成员函数绑定到声明成员函数与数据成员的VertifyWithSetFunc类定义上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VertifyWithSetFunc::VertifyWithSetFunc(string name)&#123;</span><br><span class="line">    setCourseName(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道可以通过<code>set</code>函数，可以修改<code>private</code>数据成员的值。这里我们要做的是在<code>set</code>函数进行值得判断。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void VertifyWithSetFunc::setCourseName(string name)&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length() &lt;= 10) &#123;</span><br><span class="line">        courseName = name ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (name.length() &gt; 10) &#123;</span><br><span class="line">        courseName = name.substr(0, 10);</span><br><span class="line">        cout&lt;&lt; <span class="string">"name is long than 10 :"</span>&lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name is long than 10 :test2test2test2test2test2test2test2test2test2test2</span><br><span class="line">vertify1: test1</span><br><span class="line">vertify2: test2test2</span><br></pre></td></tr></table></figure>


<h1 id="访问成员函数的三种方式"><a href="#访问成员函数的三种方式" class="headerlink" title="访问成员函数的三种方式"></a>访问成员函数的三种方式</h1><p>访问成员函数的三种方式:</p>
<p>对象名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Count counter;</span><br><span class="line">counter.setX(1);</span><br><span class="line">cout &lt;&lt; <span class="string">"counter.setX(1);"</span> ;</span><br><span class="line">counter.print();</span><br></pre></td></tr></table></figure>



<p>指向对象的指针</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Count *counterPtr = &amp;counter;</span><br><span class="line">counterPtr-&gt;setX(2);</span><br><span class="line">cout &lt;&lt; <span class="string">"counterPtr-&gt;setX(2);"</span>;</span><br><span class="line">counterPtr-&gt;<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure>

<p>对象的引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Count &amp;counterRef = counter;</span><br><span class="line">counterRef.setX(3);</span><br><span class="line">cout &lt;&lt; <span class="string">"counterRef.setX(3);"</span>;</span><br><span class="line">counterRef.print();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">counter.setX(1);1</span><br><span class="line">counterPtr-&gt;setX(2);2</span><br><span class="line">counterRef.setX(3);3</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>




<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>析构函数(destructor)是一种特殊的成员函数。</p>
<ul>
<li>类的析构函数名是在类名前加一个波浪好<code>~</code></li>
<li>累的析构函数是在删除对象的时候被隐式调用</li>
<li>析构函数没有形参页不反悔任何值</li>
<li>析构函数必须是 <code>public</code>类型的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CreateAndDestructor::CreateAndDestructor(int ID, string msg)&#123;</span><br><span class="line">    objectID = ID;</span><br><span class="line">    message = msg;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"Object "</span> &lt;&lt; objectID &lt;&lt; <span class="string">" 构造函数 runs  "</span> &lt;&lt;message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void create(void)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"createFunc "</span> &lt;&lt; endl;</span><br><span class="line">    CreateAndDestructor fifth(5, <span class="string">"(local automatic in create)"</span>);</span><br><span class="line">    static CreateAndDestructor sixth(6, <span class="string">"(local automatic in create)"</span>);</span><br><span class="line">    CreateAndDestructor seventh(7, <span class="string">"(local automatic in create)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateAndDestructor::~<span class="function"><span class="title">CreateAndDestructor</span></span>()&#123;</span><br><span class="line">    cout&lt;&lt;(objectID ==1 || objectID == 6 ? <span class="string">"\n"</span> : <span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"Object "</span> &lt;&lt; objectID &lt;&lt; <span class="string">" 析构函数 runs   "</span> &lt;&lt;message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">testCreateAndDestructor</span></span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"testFunc "</span> &lt;&lt; endl;</span><br><span class="line">    CreateAndDestructor second(2, <span class="string">"(local automatic in testFunc)"</span>);</span><br><span class="line">    static CreateAndDestructor third(3, <span class="string">"(local automatic in testFunc)"</span>);</span><br><span class="line">    </span><br><span class="line">    create();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"testFunc : "</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    CreateAndDestructor forth(4, <span class="string">"(local automatic in testFunc)"</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"\ntestFunc end \n"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">testFunc </span><br><span class="line">Object 2 构造函数 runs  (<span class="built_in">local</span> automatic <span class="keyword">in</span> testFunc)</span><br><span class="line">Object 3 构造函数 runs  (<span class="built_in">local</span> automatic <span class="keyword">in</span> testFunc)</span><br><span class="line">createFunc </span><br><span class="line">Object 5 构造函数 runs  (<span class="built_in">local</span> automatic <span class="keyword">in</span> create)</span><br><span class="line">Object 6 构造函数 runs  (<span class="built_in">local</span> automatic <span class="keyword">in</span> create)</span><br><span class="line">Object 7 构造函数 runs  (<span class="built_in">local</span> automatic <span class="keyword">in</span> create)</span><br><span class="line">Object 7 析构函数 runs   (<span class="built_in">local</span> automatic <span class="keyword">in</span> create)</span><br><span class="line">Object 5 析构函数 runs   (<span class="built_in">local</span> automatic <span class="keyword">in</span> create)</span><br><span class="line">testFunc : </span><br><span class="line">Object 4 构造函数 runs  (<span class="built_in">local</span> automatic <span class="keyword">in</span> testFunc)</span><br><span class="line"></span><br><span class="line">testFunc end </span><br><span class="line"></span><br><span class="line">Object 4 析构函数 runs   (<span class="built_in">local</span> automatic <span class="keyword">in</span> testFunc)</span><br><span class="line">Object 2 析构函数 runs   (<span class="built_in">local</span> automatic <span class="keyword">in</span> testFunc)</span><br><span class="line"></span><br><span class="line">Object 6 析构函数 runs   (<span class="built_in">local</span> automatic <span class="keyword">in</span> create)</span><br><span class="line">Object 3 析构函数 runs   (<span class="built_in">local</span> automatic <span class="keyword">in</span> testFunc)</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>

<ul>
<li>在全局作用域内定义的对象的构造函数在该文件中的任何其他函数（包括<code>main</code>函数）开始执行之前执行。</li>
<li>在<code>main</code>函数终止时，调用响应的析构函数。<code>exit</code>函数强制程序立即终止并且不执行自动对象的析构函数。</li>
<li>自动局部对象的 <code>析构函数</code>在执行到达定义该对象的程序点是调用，<code>对应的析构函数</code>是在该对象离开该对像所在的作用域时调用。</li>
<li><code>static</code>局部对象的<code>析构函数</code>只在执行第一次到达定义对象的程序点时调用一次,<code>对应的析构函数</code>是在<code>main</code>函数终止时或者<code>exit</code>函数时调用。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC</title>
    <url>/2019/11/04/WebRTC/</url>
    <content><![CDATA[<h1 id="WebRTC介绍"><a href="#WebRTC介绍" class="headerlink" title="WebRTC介绍"></a>WebRTC介绍</h1><p><a href="[https://webrtc.org/](https://webrtc.org/)">WebRTC</a>一个由google开源的音视频处理+即时通讯的开源库，优秀的多媒体、跨平台框架。它极其庞大复杂，换句话来说功能很强大，然后就是WebRTC只是定义了客户端的规范，至于服务器可以根据自己的业务场景来实现，一般应用于：</p>
<ul>
<li>音视频会议、在线教育</li>
<li>照相机</li>
<li>音乐播放器</li>
<li>共享远程桌面</li>
<li>录制</li>
<li>实施人脸识别</li>
<li>游戏</li>
<li>文件传输工具</li>
<li>P2P网络加速</li>
<li>即时通讯工具</li>
</ul>
<h1 id="WebRTC-1-对-1-音视频实时通话"><a href="#WebRTC-1-对-1-音视频实时通话" class="headerlink" title="WebRTC 1 对 1 音视频实时通话"></a>WebRTC 1 对 1 音视频实时通话</h1><p><img src="/2019/11/04/WebRTC/webrtc1-1to1.png" alt="过程示意图"></p>
<p>即两个 WebRTC 终端（上图中的两个大方框）、一个 Signal（信令）服务器和一个 STUN/TURN 服务器。</p>
<p><code>WebRTC 终端</code>负责音视频采集、编解码、NAT 穿越、音视频数据传输。步骤流程如下：</p>
<ul>
<li>获取权限（摄像头、麦克风）</li>
<li>本地视频的采集与展示</li>
<li>创建<code>RTCPeerConnection</code></li>
<li>媒体协商</li>
<li>远端视频的展示</li>
</ul>
<p><code>Signal 服务器</code>负责信令处理，如加入房间、离开房间、媒体协商消息的传递等。<br><code>STUN/TURN 服务器</code>负责获取 WebRTC 终端在公网的 IP 地址，以及 NAT 穿越失败后的数据中转。</p>
<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p><code>Full Cone</code> 完全锥型NAT<br>当 host 主机通过 NAT 访问外网的 B 主机时，就会在 NAT 上打个“洞”，所有知道这个“洞”的主机都可以通过它与内网主机上的侦听程序通信。<br><code>所谓的“打洞”就是在 NAT 上建立一个内外网的映射表。</code><br>大多数人都选用<code>UDP</code>作为打洞协议.</p>
<p><img src="/2019/11/04/WebRTC/webrtc10-full-cone.png" alt></p>
<p><code>ip restricted</code>IP 限制锥型NAT<br>host 主机在 NAT 上“打洞”后，NAT 会对穿越洞口的 IP 地址做限制。只有登记的 IP 地址才可以通过。</p>
<p>IP 限制锥型 NAT 的映射表是一个 5 元组，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	内网 IP，</span><br><span class="line">	内网端口，</span><br><span class="line">	映射的外网 IP，</span><br><span class="line">	映射的外网端口，</span><br><span class="line">	被访问主机的 IP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/WebRTC/webrtc10-ip-restricted.png" alt></p>
<p><code>port restrected</code> 端口限制型NAT</p>
<p>不光在 NAT 上对打洞的 IP 地址做了限制，而且还对具体的端口做了限制。因此，端口限制型 NAT 的映射表是一个 6 元组，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	内网 IP，</span><br><span class="line">	内网端口，</span><br><span class="line">	映射的外网 IP，</span><br><span class="line">	映射的外网端口，</span><br><span class="line">	被访问主机的 IP,</span><br><span class="line">	被访问主机的端口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/WebRTC/webrtc10-port-restrcted.png" alt></p>
<p><code>symmetric</code> 对成型NAT<br>host 主机访问 B 时它在 NAT 上打了一个“洞”，而这个“洞”只有 B 主机上提供服务的端口发送的数据才能穿越，这一点与端口限制型 NAT 是一致的。</p>
<p>但它与端口限制型 NAT 最大的不同在于，如果 host 主机访问 A 时，它会在 NAT 上重新开一个“洞”，而不会使用之前访问 B 时打开的“洞”。也就是说对称型 NAT 对每个连接都使用不同的端口，甚至更换 IP 地址，而端口限制型 NAT 的多个连接则使用同一个端口，这对称型 NAT 与端口限制型 NAT 最大的不同.</p>
<p><img src="/2019/11/04/WebRTC/webrtc10-symmetric.png" alt></p>
<p><code>NAT 类型检测</code>步骤</p>
<ul>
<li>判断是否有 NAT 防护</li>
<li>探测 NAT 环境</li>
</ul>
<p><img src="/2019/11/04/WebRTC/webrtc10-nat-check.png" alt></p>
<h1 id="STUN协议"><a href="#STUN协议" class="headerlink" title="STUN协议"></a>STUN协议</h1><ul>
<li>STUN存在的目的就是进行NAT穿越。</li>
<li>STUN是典型的客户端/服务器模式，即：客户端发送请求，服务端进行相应。</li>
</ul>
<p>STUN有着两套规范，分别是：<br><code>RFC3489</code>Simple Traversal of UDP Through NAT</p>
<p>RFC3489定义属性<br>| 属性 | 作用 |  |<br>| :—–| :— | :—- |<br>| 0x001 | mapped-address | 获取客户端映射地址 |<br>| 0x002 | response-address | 指明对于mapped-address的相应应该由哪里发送 |<br>| 0x003 | change-request | 请求服务端使用不同的IP和端口发送响应 |<br>| 0x004 | souce-address | 制定服务器的IP和端口 |<br>| 0x005 | change-addresss | 它是change-addresss请求的响应 |<br>| 0x006 | user-name | 用于安全验证 |<br>| 0x007 | password | 用于安全验证 |<br>| 0x008 | message-integrity | 消息完整性验证 |<br>| 0x009 | error-code | 错误码 |<br>| 0x00a | unknow-attributes | 未知属性 |<br>| 0x00b | peflected-from | 拒约 |</p>
<p><code>RFC5389</code>Session Traversal Utilities for NAT（它是UDP和TCP都有用到的）</p>
<h1 id="TURN协议"><a href="#TURN协议" class="headerlink" title="TURN协议"></a>TURN协议</h1><ul>
<li>目的是解决堆成NAT无法穿越的问题</li>
<li>其建立在STUN之上，消息格式使用STUN格式消息</li>
<li>TURN Client要求服务端分配一个公共IP和Port用于接收或发送数据</li>
</ul>
<p><img src="/2019/11/04/WebRTC/turn-demo.png" alt></p>
<h1 id="ICE框架"><a href="#ICE框架" class="headerlink" title="ICE框架"></a>ICE框架</h1><ul>
<li>收集Candidate（本机所有IP和制定端口）</li>
<li>对Candidate Pair 排序</li>
<li>连通性检查</li>
</ul>
<p>什么是 Candidate?<br>它表示 WebRTC 与远端通信时使用的协议、IP 地址和端口，一般由以下字段组成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	IP: xxx.xxx.xxx.xxx,</span><br><span class="line">	port: number,</span><br><span class="line">	<span class="built_in">type</span>: host/srflx/relay,</span><br><span class="line">	priority: number,</span><br><span class="line">	protocol: UDP/TCP,</span><br><span class="line">	usernameFragment: string</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，候选者类型中的 host 表示本机候选者，srflx 表示内网主机映射的外网的地址和端口，relay 表示中继候选者。</p>
<h1 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h1><p><code>SDP</code>session description protocol，它是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。</p>
<h1 id="RTP-RTCP"><a href="#RTP-RTCP" class="headerlink" title="RTP/RTCP"></a>RTP/RTCP</h1><p> 一般情况下，在实时互动直播系统传输音视频数据流时，我们并不直接将音视频数据流交给 UDP 传输，而是先给音视频数据加个 RTP 头，然后再交给 UDP 进行传输。</p>
<p>在使用 RTP 包传输数据时，难免会发生丢包、乱序、抖动等问题，但在处理这些问题之前，它首先要让各端都知道它们自己的网络质量到底是怎样的，这就是 RTCP 的作用。</p>
<p>各协议头字段如下，SSRC为共享媒体流的源。</p>
<p><img src="/2019/11/04/WebRTC/RTP-protocol-header.png" alt="RTP"></p>
<p><img src="/2019/11/04/WebRTC/RTCP-protocol-header.png" alt="RTCP"></p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg</title>
    <url>/2019/11/04/FFmpeg/</url>
    <content><![CDATA[<h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p><a href="http://ffmpeg.org/download.html" target="_blank" rel="noopener">FFmpeg</a>是一个音视频处理库，提供了如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>源码安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  GitHub git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git ffmpeg</span><br><span class="line">Cloning into <span class="string">'ffmpeg'</span>...</span><br><span class="line">remote: Counting objects: 588505, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (120835/120835), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 588505 (delta 471727), reused 581424 (delta 466456)</span><br><span class="line">Receiving objects: 100% (588505/588505), 138.43 MiB | 2.74 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (471727/471727), <span class="keyword">done</span>.</span><br><span class="line">Checking out files: 100% (7264/7264), <span class="keyword">done</span>.</span><br><span class="line">➜  GitHub <span class="built_in">cd</span> ffmpeg </span><br><span class="line">➜  ffmpeg git:(master) ls</span><br><span class="line">CONTRIBUTING.md  LICENSE.md       ffbuild          libpostproc</span><br><span class="line">COPYING.GPLv2    MAINTAINERS      fftools          libswresample</span><br><span class="line">COPYING.GPLv3    Makefile         libavcodec       libswscale</span><br><span class="line">COPYING.LGPLv2.1 README.md        libavdevice      presets</span><br><span class="line">COPYING.LGPLv3   RELEASE          libavfilter      tests</span><br><span class="line">CREDITS          compat           libavformat      tools</span><br><span class="line">Changelog        configure        libavresample</span><br><span class="line">INSTALL.md       doc              libavutil</span><br><span class="line">➜  ffmpeg git:(master) ./configure --<span class="built_in">help</span></span><br><span class="line">➜  ffmpeg git:(master) ./configure --<span class="built_in">help</span> | more </span><br><span class="line">Usage: configure [options]</span><br><span class="line">Options: [defaults <span class="keyword">in</span> brackets after descriptions]</span><br><span class="line"></span><br><span class="line">➜  ffmpeg git:(master) ./configure --prefix=/usr/<span class="built_in">local</span>/ffmpeg --<span class="built_in">enable</span>-gpl  --<span class="built_in">enable</span>-nonfree  --<span class="built_in">enable</span>-libfdk-aac  --<span class="built_in">enable</span>-libx264   --<span class="built_in">enable</span>-libx265  --<span class="built_in">enable</span>-filter=delogo  --<span class="built_in">enable</span>-debug  --<span class="built_in">disable</span>-optimizations --<span class="built_in">enable</span>-libspeex  --<span class="built_in">enable</span>-videotoolbox  --<span class="built_in">enable</span>-shared  --<span class="built_in">enable</span>-pthreads  --<span class="built_in">enable</span>-version3  --<span class="built_in">enable</span>-hardcoded-tables --cc=clang --host-cflags=  --host-ldflags=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">报错、报错、报错、报错、</span><br><span class="line">nasm/yasm not found or too old. Use --<span class="built_in">disable</span>-x86asm <span class="keyword">for</span> a crippled build.</span><br><span class="line">ERROR: libfdk_aac not found</span><br><span class="line">ERROR: speex not found using pkg-config</span><br><span class="line">ERROR: libx264 not found</span><br><span class="line"></span><br><span class="line">前面三种都可以通过brew install来解决，但是libx264怎么搞都拉不下。。。</span><br></pre></td></tr></table></figure>

<p>通过brew安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ffmpeg git:(master) brew install ffmpeg</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Installing dependencies <span class="keyword">for</span> ffmpeg: aom,,,,</span><br><span class="line"></span><br><span class="line">==&gt; Caveats</span><br><span class="line">gettext is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because macOS provides the BSD gettext library &amp; some software gets confused <span class="keyword">if</span> both are <span class="keyword">in</span> the library path.</span><br><span class="line"></span><br><span class="line">If you need to have gettext first <span class="keyword">in</span> your PATH run:</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/gettext/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find gettext you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/gettext/lib"</span></span><br><span class="line">  <span class="built_in">export</span> CPPFLAGS=<span class="string">"-I/usr/local/opt/gettext/include"</span></span><br><span class="line">==&gt; Caveats</span><br><span class="line">libffi is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because some formulae require a newer version of libffi.</span><br><span class="line"></span><br><span class="line">For compilers to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/libffi/lib"</span></span><br><span class="line"></span><br><span class="line">For pkg-config to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> PKG_CONFIG_PATH=<span class="string">"/usr/local/opt/libffi/lib/pkgconfig"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==&gt; Caveats</span><br><span class="line">==&gt; gettext</span><br><span class="line">gettext is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because macOS provides the BSD gettext library &amp; some software gets confused <span class="keyword">if</span> both are <span class="keyword">in</span> the library path.</span><br><span class="line"></span><br><span class="line">If you need to have gettext first <span class="keyword">in</span> your PATH run:</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/gettext/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find gettext you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/gettext/lib"</span></span><br><span class="line">  <span class="built_in">export</span> CPPFLAGS=<span class="string">"-I/usr/local/opt/gettext/include"</span></span><br><span class="line"></span><br><span class="line">==&gt; libffi</span><br><span class="line">libffi is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because some formulae require a newer version of libffi.</span><br><span class="line"></span><br><span class="line">For compilers to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/libffi/lib"</span></span><br><span class="line"></span><br><span class="line">For pkg-config to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> PKG_CONFIG_PATH=<span class="string">"/usr/local/opt/libffi/lib/pkgconfig"</span></span><br><span class="line"></span><br><span class="line">==&gt; unbound</span><br><span class="line">To have launchd start unbound now and restart at startup:</span><br><span class="line">  sudo brew services start unbound</span><br><span class="line">==&gt; glib</span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/<span class="built_in">local</span>/etc/bash_completion.d</span><br><span class="line">==&gt; tesseract</span><br><span class="line">This formula contains only the <span class="string">"eng"</span>, <span class="string">"osd"</span>, and <span class="string">"snum"</span> language data files.</span><br><span class="line">If you need any other supported languages, run `brew install tesseract-lang`.</span><br></pre></td></tr></table></figure>


<p><code>brew info ffmpeg</code>可以看到x264, x265这些包都是有安装的。升级则通过<code>brew update &amp;&amp; brew upgrade ffmpeg</code>.</p>
<p>第二种方式安装连环境变量都不需要设置，完美极了。</p>
<h1 id="目录及作用"><a href="#目录及作用" class="headerlink" title="目录及作用"></a>目录及作用</h1><ul>
<li>libavcodec： 提供了一系列编码器的实现。</li>
<li>libavformat： 实现在流协议，容器格式及其本IO访问。</li>
<li>libavutil： 包括了hash器，解码器和各利工具函数。</li>
<li>libavfilter： 提供了各种音视频过滤器。</li>
<li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li>
<li>libswresample： 实现了混音和重采样。</li>
<li>libswscale： 实现了色彩转换和缩放工能。</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>音／视频流</code> 在音视频领域，我们把一路音／视频称为一路流。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p>
<p><code>容器</code> 我们一般把 MP4､ FLV、MOV等文件格式称之为容器。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p>
<p><code>channel</code> 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/weixin_33985507/article/details/94470495" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33985507/article/details/94470495</a></p>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/15811977" target="_blank" rel="noopener">https://blog.csdn.net/leixiaohua1020/article/details/15811977</a></p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基础01</title>
    <url>/2019/11/01/Swift%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="使用let关键字来声明常量"><a href="#使用let关键字来声明常量" class="headerlink" title="使用let关键字来声明常量"></a>使用let关键字来声明常量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="使用var关键字来声明变量"><a href="#使用var关键字来声明变量" class="headerlink" title="使用var关键字来声明变量"></a>使用var关键字来声明变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var temp = 0</span><br><span class="line">temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="可以在一行中声明多个变量或常量，用逗号分隔"><a href="#可以在一行中声明多个变量或常量，用逗号分隔" class="headerlink" title="可以在一行中声明多个变量或常量，用逗号分隔"></a>可以在一行中声明多个变量或常量，用逗号分隔</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var x=0.1, y=10.1, z=1.0</span><br></pre></td></tr></table></figure>
<h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><p>在声明一个变量或常量的时候提供类型标注，来明确变量或常量能够储存值的类型</p>
<p>添加类型标注的方法是在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称</p>
<p>可以在一行中定义多个相关的变量为相同类型，用逗号分隔，只要在最后的变量名字后边加上类型标注</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var msg: String</span><br><span class="line">msg = <span class="string">"message"</span></span><br></pre></td></tr></table></figure>

<h3 id="变量和常量命名"><a href="#变量和常量命名" class="headerlink" title="变量和常量命名"></a>变量和常量命名</h3><p>几乎可以使用任何自负，甚至包括Unicode字符</p>
<p>不能包括空白字符、数学符号、箭头、保留的（或无效的）Unicode码位、连线和制表符。也不能以数字开头。</p>
<h3 id="打印常量和变量"><a href="#打印常量和变量" class="headerlink" title="打印常量和变量"></a>打印常量和变量</h3><p>print</p>
<p>字符串插值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">"show string"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"显示str\(str)"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>8，16，32，64位编码的有符号和无符号整数（例如：UInt8,Int8）</p>
<p>通过min和max属性访问每个整数类型的最小值和最大值</p>
<p>Int，拥有与当前平台的原生字相同的长度；UInt，与平台长度相关的无符号整数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"UInt8 min \(UInt8.min), UInt8 max \(UInt8.max)"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p> Double 64位浮点数，至少有15位数字的精度</p>
<p> Float 32位浮点数，至少有6位数字的精度</p>
<h3 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h3><p>表示true和false</p>
<p>Swift的类型安全机制会阻止你用一个非布尔量的值替代掉Bool</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p><img src="/2019/11/01/Swift%E5%9F%BA%E7%A1%8001/Swift_%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4.png" alt="Swift_数值范围"></p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p> 类型别名是一个为已存在类型定义的一个可选择的名字<br> <code>typealias</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typealias AudioSample = UInt8</span><br><span class="line"><span class="built_in">let</span> sample: AudioSample = 32</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><h3 id="使用Tuple组合多个值"><a href="#使用Tuple组合多个值" class="headerlink" title="使用Tuple组合多个值"></a>使用Tuple组合多个值</h3><p>元组把多个值合并成单一的复合型的值</p>
<p>元组内的值可以是任何类型，而且可以不必是同一类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.0)</span><br><span class="line"><span class="built_in">print</span>(error.1)</span><br></pre></td></tr></table></figure>
<h3 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h3><p>元组中的每一个元素可以制定对应的元素名称</p>
<p>如果没有制定名称的元素也可以使用下标的方式来引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (error: 1,  errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.error)</span><br><span class="line"><span class="built_in">print</span>(error.errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="Tuple修改"><a href="#Tuple修改" class="headerlink" title="Tuple修改"></a>Tuple修改</h3><p>用var定义的元组就是可变元组，let定义的就是不可变元组</p>
<p><code>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</code></p>
<p>可以对可变元组的元素进行修改，但是不能改变其类型</p>
<p>Any类型可以改为任何类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var error:(errorCode: Int, errorMsg:Any) = (errorCode: 1, errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMsg = 3</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>可以将一个元组的内容分解成单独的常量或变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (error, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<p>如果只需要使用其中的一部分数据，不需要的数据可以用下划线<code>_</code>代替</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (_, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h3><p>使用Tuple为函数返回多个值</p>
<p>返回值的Tuple可以在函数的返回类型部分被命名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func requestWithUrl(url: String) -&gt; (errorCode: Int, errorMsg: String) &#123;</span><br><span class="line">    <span class="built_in">return</span> (1, <span class="string">"没有权限"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> error = requestWithUrl(url: <span class="string">""</span>)</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>通过在变量类型后面加<code>?</code>表示：这里有一个值，它表示x，或者这里根本没有值</p>
<p>可以通过给可选变量赋值一个nil来将之设置为没有值</p>
<p>在Swift中，nil不是指针，他是值缺失的一种特殊类型，任何类型的可选类项都可以设置成nil而不仅仅是对西那个类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = nil</span><br></pre></td></tr></table></figure>

<h3 id="Optional-if"><a href="#Optional-if" class="headerlink" title="Optional-if"></a>Optional-if</h3><p>可选项是没法直接食用的，需要用!展开之后才能使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> str != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h3><p>可以使用可选项的绑定来判断是否包含值，如果包含就把值赋给一个临时的常量或者变量</p>
<p>可选绑定可以与if和while的语句使用来检查可选项内部的值，并赋值给一个变量或常量 </p>
<p>同一个if语句中包含多个可选项绑定时，用逗号分隔开即可。如果人一个选项绑定结果是nil或者布尔值为false，那么整个if判断会被看作false</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> actualStr = str &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-隐式展开"><a href="#Optional-隐式展开" class="headerlink" title="Optional-隐式展开"></a>Optional-隐式展开</h3><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开</p>
<p>通过在声明的类型后边添加一个叹号<code>!</code>而非问好来书写隐式展开可选项</p>
<p>隐式展开可选项主要被用于Swift类的初始化过程中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String! = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str!.count</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<h3 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h3><p>可选项后面加问号</p>
<p>如果可选项不为nil，返回一个可选项结果，否则返回nil</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str?.count</span><br><span class="line"><span class="keyword">if</span> count != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> lastIndex = count! - 1</span><br><span class="line">    <span class="built_in">print</span>(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var emptyString = <span class="string">""</span></span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(Noting<span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字符串字面亮是被双引号<code>&quot;</code>包裹的固定顺序的文本字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str = <span class="string">"some string"</span></span><br></pre></td></tr></table></figure>

<h3 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h3><p>字多行符串字面量是被三个双引号<code>&quot;&quot;&quot;</code>引起来的一系列字符</p>
<p>开始和结束默认不会有换行符</p>
<p>反斜杠只会在代码阅读上方便，输出时没有实际的换行功能<code>\</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">""</span><span class="string">"var emptyString = "</span><span class="string">" \</span></span><br><span class="line"><span class="string">var anotherEmptyString = String() \</span></span><br><span class="line"><span class="string">if emptyString.isEmpty &#123; \</span></span><br><span class="line"><span class="string">    print(Noting"</span>) \</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">print(str)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h3><p>转义特殊字符</p>
<p>任意的Unicode标量  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展字符串分隔符"><a href="#扩展字符串分隔符" class="headerlink" title="扩展字符串分隔符"></a>扩展字符串分隔符</h3><p>在字符串字面量中放置扩展分隔符来在字符串中包含特殊字符而不让它们真的生效</p>
<p>将字符串放在双引号内并由井号#包裹</p>
<p>如果字符串里有”#则首尾需要两个##(首尾##与包含的”#不一样即可)</p>
<p>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的#号数量的#号，并在前面添加转义符号\</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\n\n444"#</span></span><br><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\#n\n444"#</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的可变形"><a href="#字符串的可变形" class="headerlink" title="字符串的可变形"></a>字符串的可变形</h3><p>var 可修改<br>let 不可修改</p>
<h3 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h3><p>String 值在传递给方法或者函数的时候会被复制过去</p>
<p>赋值给常量和变量的时候也是一样</p>
<h3 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h3><p>for-in 循环遍历String中的每一个独立的Character</p>
<p>Character类型</p>
<p>String值可以通过传入Character 数组来构造</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"abcdef"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> tempCharacters: [Character] = [<span class="string">"d"</span>,<span class="string">"f"</span>,<span class="string">"d"</span>,<span class="string">"h"</span>]</span><br><span class="line"><span class="built_in">let</span> str = String(tempCharacters)</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>通过加运算符<code>+</code>创建新字符串</p>
<p>使用加赋值符号<code>+=</code>在已经存在的String值末尾追加一个String值</p>
<p>使用String类型的<code>append()</code>方法来给一个String变量的末尾追加character值</p>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p><code>\(some)</code> some代表：混合常量、变量、字面量和表达式的字符串面量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="comment">#"1 * 3 = \#(1*3)."#)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>每个String值都有相关的索引类型，String.index，它相当于每个Character在字符串重的位置</p>
<p>startIndex属性来访问String中第一个Character的位置。endIndex属性就是String中最后一个字符后的位置</p>
<p>endIndex属性并不是字符串下表脚本的合法实际参数</p>
<p>如果String为空，则startIndex与endIndex相等</p>
<p>使用index(before:)和index(after:)方法来访问给定索引的前后</p>
<p>要访问给定索引更远的索引，你可以使用index(_:offsetBy:)</p>
<p>使用indices属性来访问字符串中每个字符的索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> hello = <span class="string">"hello"</span></span><br><span class="line">hello[hello.startIndex]</span><br><span class="line">hello[hello.index(before: hello.endIndex)]</span><br><span class="line">hello[hello.index(after: hello.startIndex)]</span><br><span class="line"><span class="built_in">let</span> index = hello.index(hello.startIndex, offsetBy: 2)</span><br><span class="line">hello[index]</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入字符，使用insert(_:at:)方法</p>
<p>插入另一个字符串的内容到特定的索引，使用insert(contentsOs:at:)方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, at: welcome.endIndex)</span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf: <span class="string">"ererer"</span>, at: welcome.index(before: welcome.endIndex))</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>移除字符串remove(at:)</p>
<p>移除特定范围的字符串removeSubrange(range)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> range = welcome.index(welcome.endIndex, offsetBy: -1)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br></pre></td></tr></table></figure>

<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>使用下表或者累死prefix(_:)的方法得到的子字符串是SubString类型</p>
<p>SubString拥有String的大部分方法</p>
<p>SubString可以转成String类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> index3 = hello.lastIndex(of: <span class="string">"o"</span>) ?? hello.endIndex</span><br><span class="line"><span class="built_in">let</span> begin = hello[..&lt;index3]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> newHello = String(begin)</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>字符串和字符相等性(==和==)</p>
<p>前缀相等hasPrefix(_:)</p>
<p>后缀相等hasSuffix(_:)</p>
<h2 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a>赋值和算术运算符</h2><p>一元运算符、二元运算符、三元运算符</p>
<p>赋值运算符不会返回值</p>
<h2 id="如何处理算术结果溢出"><a href="#如何处理算术结果溢出" class="headerlink" title="如何处理算术结果溢出"></a>如何处理算术结果溢出</h2><p>在默认情况下，当一个整数赋超过它容量的值时，Swift会报错而不是生成一个无效的数，给我们操作过大或者过小的数的时候提供了额外的安全性</p>
<p>同时提供了三个算术溢出运算符来让系统支持整数溢出的运算</p>
<p>溢出加法<code>&amp;+</code></p>
<p>溢出减法<code>&amp;-</code></p>
<p>溢出乘法<code>&amp;*</code></p>
<h3 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h3><p>溢出也会发生在有符号整形数值上</p>
<p>对于无符号与有符号整形数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
<h2 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符??"></a>合并空值运算符<code>??</code></h2><p>合并空值运算符(a??b)如果选项a有值则展开，如果没有值，是nil，则返回默认值b</p>
<p>表达式a必须是一个可选类型。表达式b必须与a的存储类型相同。</p>
<p>实际上它就是相当于三目运算符<code>_?_:_</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func addTwoNum(num1: Int?, num2: Int2?) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> (num1 ?? 0) +(num2 ?? 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><h3 id="闭区间运算符a-b"><a href="#闭区间运算符a-b" class="headerlink" title="闭区间运算符a...b"></a>闭区间运算符<code>a...b</code></h3><p>定义了从a到b的一组范围，并且包含a和b</p>
<p>a的值不能大于b的值</p>
<h3 id="半开区间运算符a-lt-b"><a href="#半开区间运算符a-lt-b" class="headerlink" title="半开区间运算符a..&lt;b"></a>半开区间运算符<code>a..&lt;b</code></h3><p>定义了从a到b但不包含b的区间</p>
<p>a的值不能大于b的值，如果a与b的值相等，那返回的区间将会是空的</p>
<h3 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h3><p>比如说，一个包含数组所有的元素的区间，从索引2到数组的结束。在这种情况下，你可以省略区间运算符一侧的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[2...] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[...2] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倒序索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (0..&lt;10&gt;).<span class="function"><span class="title">reversed</span></span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间运算符在字符串上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> range = welcome.startIndex...welcome.index(welcome.endIndex, offsetBy: -6)</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(welcome)]</span><br></pre></td></tr></table></figure>

<p>区间运算符在比较类型上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> interval = <span class="string">"a"</span>...<span class="string">"z"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> welcome &#123;</span><br><span class="line">    <span class="keyword">if</span> !interval.contains(String(c)) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(c)不是小写字母"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符"></a>位取反运算符</h3><p>位取反运算符(~)是对所有位的数字进行取反操作</p>
<h3 id="位与运算符"><a href="#位与运算符" class="headerlink" title="位与运算符"></a>位与运算符</h3><p>位与运算符(&amp;)是对两个数的比特位进行合并。它会返回一个新的数，只有当这两个数都是1的时候才能返回1。</p>
<h3 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符"></a>位或运算符</h3><p>位或运算符(|)是对两个数的比特位进行比较。它会返回一个新的数，只要两个操作位任意一个为1时，那么对应的位数就为1。</p>
<h3 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符"></a>位异或运算符</h3><p>位异或运算符(^))，当两个操作数的对应位不相同时，那么该数对应的位数就为1。</p>
<h3 id="位左移和右移运算符"><a href="#位左移和右移运算符" class="headerlink" title="位左移和右移运算符"></a>位左移和右移运算符</h3><p>位左移(&lt;&lt;)和右移运算符(&gt;&gt;)可以吧所有位数的数字向左或向右移动一个确定的位数。</p>
<p>位座椅和右移具有给整数乘以或除以二的效果。将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。</p>
<h3 id="无符号整数的唯一操作"><a href="#无符号整数的唯一操作" class="headerlink" title="无符号整数的唯一操作"></a>无符号整数的唯一操作</h3><p>用0填充左移或右移后产生的空白位</p>
<h3 id="有符号整数的移位操作"><a href="#有符号整数的移位操作" class="headerlink" title="有符号整数的移位操作"></a>有符号整数的移位操作</h3><p>第一位表示整数还是负数（0正数，1负数）</p>
<h3 id="位运算符应用"><a href="#位运算符应用" class="headerlink" title="位运算符应用"></a>位运算符应用</h3><ul>
<li>两个数字交换</li>
<li>求赋符号整形数二进制中1的个数</li>
<li>判断一个整数是否为为2的整数次幂</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"new page title"</span></span><br></pre></td></tr></table></figure>


<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"></span><br><span class="line">$ hexo d --g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<p>Markdown 表格<br><code>-:</code> 设置内容和标题栏居右对齐。<br><code>:-</code> 设置内容和标题栏居左对齐。<br><code>:-:</code> 设置内容和标题栏居中对齐。</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<p><a href="http://support.typora.io/Draw-Diagrams-With-Markdown/" target="_blank" rel="noopener">tyora 流程图文档</a></p>
]]></content>
  </entry>
</search>
