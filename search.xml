<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FFmpeg（六）</title>
    <url>/2020/03/24/FFmpeg%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK"><a href="#通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK" class="headerlink" title="通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK"></a>通过FFmpeg源码使用脚本编译出可以在iOS下使用的SDK</h1><p>具体脚本链接：<a href="https://github.com/kewlbear/FFmpeg-iOS-build-script" target="_blank" rel="noopener">FFmpeg-iOS-build-script</a></p>
<ul>
<li>在FFmpeg源码的上一级目录添加<code>build-ffmpeg.sh</code>文件</li>
<li>命令行执行：<code>./build-ffmpeg.sh</code></li>
<li>如果无执行权限的话执行：<code>chmod 777 ./build-ffmpeg.sh</code></li>
<li>注意：打包上传到商店时使用的SDK只需要真机的</li>
</ul>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（五）</title>
    <url>/2020/03/24/FFmpeg%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>FFmpeg与SDL结合，实现多媒体播放器，内容有：多线程与锁， 锁与条件变量在实际中的应用，音视频同步，seek等。</p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（四）</title>
    <url>/2020/03/24/FFmpeg%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://samtake.github.io/2019/11/04/FFmpeg/" target="_blank" rel="noopener">FFmpeg-安装及基本概念</a><br><a href="https://samtake.github.io/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">FFmpeg-命令</a><br><a href="https://samtake.github.io/2020/03/23/FFmpeg%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="noopener">通过 C语言 操作FFmpeg对多媒体文件的处理</a></p>
<h1 id="SDL简介"><a href="#SDL简介" class="headerlink" title="SDL简介"></a>SDL简介</h1><p><a href="http://libsdl.org/download-2.0.php" target="_blank" rel="noopener">SDL</a>可以对音视频进行渲染，这里主要部分有：安装SDL、使用SDL的基本步骤、SDL窗口渲染、SDL事件处理、SDL纹理渲染。</p>
<h1 id="安装SDL"><a href="#安装SDL" class="headerlink" title="安装SDL"></a>安装SDL</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ brew info SDl2</span><br><span class="line">➜  ~ brew info SDl2</span><br><span class="line">SDl2: stable 2.0.10 (bottled), HEAD</span><br><span class="line">Low-level access to audio, keyboard, mouse, joystick, and graphics</span><br><span class="line">https://www.libsdl.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/SDl2/2.0.10 (87 files, 4.6MB)</span><br><span class="line">  Poured from bottle on 2020-03-24 at 14:13:57</span><br><span class="line">From: git://mirrors.ustc.edu.cn/homebrew-core.git//Formula/sdl2.rb</span><br><span class="line">==&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">	Install HEAD version</span><br></pre></td></tr></table></figure>


<h1 id="使用SDL的基本步骤"><a href="#使用SDL的基本步骤" class="headerlink" title="使用SDL的基本步骤"></a>使用SDL的基本步骤</h1><h1 id="SDL窗口渲染"><a href="#SDL窗口渲染" class="headerlink" title="SDL窗口渲染"></a>SDL窗口渲染</h1><h1 id="SDL事件处理"><a href="#SDL事件处理" class="headerlink" title="SDL事件处理"></a>SDL事件处理</h1><h1 id="SDL彻底理解纹理渲染"><a href="#SDL彻底理解纹理渲染" class="headerlink" title="SDL彻底理解纹理渲染"></a>SDL彻底理解纹理渲染</h1>]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（三）</title>
    <url>/2020/03/23/FFmpeg%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://samtake.github.io/2019/11/04/FFmpeg/" target="_blank" rel="noopener">FFmpeg-安装及基本概念</a><br><a href="https://samtake.github.io/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">FFmpeg-命令</a><br><a href="https://github.com/samtake/FFmpeg-demo" target="_blank" rel="noopener">FFmpeg-demo源码地址</a><br>这里记录通过 C语言 操作FFmpeg对多媒体文件的处理</p>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>常用日志级别（级别由高到底排列）<br>1.AV_LOFG_ERROR<br>2.AV_LOG_WARNING<br>3.AV_LOG_INFO</p>
<p>启用步骤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include &lt;libavutil/log.h&gt;</span><br><span class="line">av_log_set_level(AV_LOG_DEBUG) <span class="comment">#只有该级别以及该级别之上的日志才会打印</span></span><br><span class="line">av_log(NULL,AV_LOG_INFO,<span class="string">"hello world:%s\n"</span>,<span class="string">"op"</span> )</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) clang -g -o ffmpeg_log ffmpeg_log.c -lavutil</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./ffmpeg_log</span><br><span class="line">hello world!</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗</span><br></pre></td></tr></table></figure>


<h1 id="文件的删除-amp-重命名"><a href="#文件的删除-amp-重命名" class="headerlink" title="文件的删除&amp;重命名"></a>文件的删除&amp;重命名</h1><p><code>avpriv_io_move(&quot;111.txt&quot;,&quot;222.txt&quot;);</code>重命名<br><code>avpriv_io_delete(&quot;./mytestfile.txt&quot;);</code>删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --libs libavformat`</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ pkg-config --libs libavformat  <span class="comment">#这一命令的作用时：在系统中寻找到libavformat库所在的位置</span></span><br><span class="line">-L/usr/<span class="built_in">local</span>/Cellar/ffmpeg/4.2.2_2/lib -lavformat</span><br></pre></td></tr></table></figure>

<h1 id="操作目录"><a href="#操作目录" class="headerlink" title="操作目录"></a>操作目录</h1><p><code>avio_open_dir</code><br><code>avio_read_dir</code><br><code>avio_free_directory_entry</code><br><code>avio_close_dir</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">av_log(NULL, AV_LOG_INFO, <span class="string">"%12"</span>PRId64<span class="string">"%s \n"</span>,entry-&gt;size,entry-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="comment"># PRId64 是ffmpeg里面定义的一个宏，ffmpeg里面读取的文件也是64位的。</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o list ffmpeg_list.c `pkg-config --libs libavformat libavutil`</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./list</span><br><span class="line">         186ffmpeg_log.c </span><br><span class="line">        2442build_ffmpeg_for_android.sh </span><br><span class="line">        4433list.c </span><br><span class="line">         818ffmpeg_list.c </span><br><span class="line">          96list.dSYM </span><br><span class="line">          96ffmpeg_del.dSYM </span><br><span class="line">        5209encode_audio.c </span><br><span class="line">        1051read_file.c </span><br><span class="line">       11151extr_video.c </span><br><span class="line">       11027avmerge.c </span><br><span class="line">        9532decode_video.c </span><br><span class="line">        5747cutvideo.c </span><br><span class="line">        8760ffmpeg_del </span><br><span class="line">        4265encode_video.c </span><br><span class="line">        8760ffmpeg_log </span><br><span class="line">        6500extr_audio.c </span><br><span class="line">        9380list </span><br><span class="line">          96android </span><br><span class="line">        1073mediainfo.c </span><br><span class="line">        7020decode_audio.c </span><br><span class="line">         541ffmpeg_file.c </span><br><span class="line">        5132remuxing.c </span><br><span class="line">         448.git </span><br><span class="line">          96ffmpeg_log.dSYM </span><br><span class="line">         803write_file.c </span><br><span class="line">        5066extra_audio_ffapi.c </span><br><span class="line">         288player</span><br></pre></td></tr></table></figure>

<h1 id="打印音视频meta信息"><a href="#打印音视频meta信息" class="headerlink" title="打印音视频meta信息"></a>打印音视频meta信息</h1><p><code>av_register_all</code><br><code>avformat_open_input</code><br><code>av_dump_format(fmt_ctx, 0, &quot;./test.mp4&quot;, 0/**输入信息*/);</code></p>
<p>输入信息 填0<br>输入信息 填1</p>
<p><code>avformat_close_input</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o mediainfo mediainfo.c `pkg-config --libs libavutil libavformat`</span><br><span class="line">mediainfo.c:17:5: warning: <span class="string">'av_register_all'</span> is deprecated [-Wdeprecated-declarations]</span><br><span class="line">    av_register_all();</span><br><span class="line">    ^</span><br><span class="line">/usr/<span class="built_in">local</span>/include/libavformat/avformat.h:2049:1: note: <span class="string">'av_register_all'</span> has been explicitly marked deprecated here</span><br><span class="line">attribute_deprecated</span><br><span class="line">^</span><br><span class="line">/usr/<span class="built_in">local</span>/include/libavutil/attributes.h:94:49: note: expanded from macro <span class="string">'attribute_deprecated'</span></span><br><span class="line"><span class="comment">#    define attribute_deprecated __attribute__((deprecated))</span></span><br><span class="line">                                                ^</span><br><span class="line">1 warning generated.</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./mediainfo</span><br><span class="line">Input <span class="comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from './test.mp4':</span></span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : mp42</span><br><span class="line">    minor_version   : 0</span><br><span class="line">    compatible_brands: isommp42</span><br><span class="line">    creation_time   : 2020-03-19T07:15:55.000000Z</span><br><span class="line">  Duration: 00:00:55.51, start: 0.000000, bitrate: 8422 kb/s</span><br><span class="line">    Stream <span class="comment">#0:0(eng): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 380 kb/s (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2020-03-19T07:15:55.000000Z</span><br><span class="line">      handler_name    : Mainconcept MP4 Sound Media Handler</span><br><span class="line">    Stream <span class="comment">#0:1(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 1280x720 [SAR 1:1 DAR 16:9], 8040 kb/s, 50 fps, 50 tbr, 50k tbn, 100 tbc (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2020-03-19T07:15:55.000000Z</span><br><span class="line">      handler_name    : Mainconcept MP4 Video Media Handler</span><br><span class="line">      encoder         : AVC Cod</span><br></pre></td></tr></table></figure>

<h1 id="抽取多媒体中的音频数据"><a href="#抽取多媒体中的音频数据" class="headerlink" title="抽取多媒体中的音频数据"></a>抽取多媒体中的音频数据</h1><p>av_init_packet(&amp;pkt);</p>
<p>av_find_best_stream</p>
<p>av_read_frame/av_packet_unref</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o extr_audio  extr_audio.c `pkg-config --libs libavutil libavformat`</span><br><span class="line">./extr_audio  ./test.mp4  ./test.aac  </span><br><span class="line">ffplay test.aac</span><br></pre></td></tr></table></figure>

<h1 id="抽取多媒体中的H264视频数据"><a href="#抽取多媒体中的H264视频数据" class="headerlink" title="抽取多媒体中的H264视频数据"></a>抽取多媒体中的H264视频数据</h1><p>先要知道的三点：<br>1.将多媒体中的H264视频数据抽取后，它其实是由一帧一帧压缩后的视频帧组成的，如何区分这一帧一帧的视频帧呢？两种方法：</p>
<ul>
<li>在每一帧的长度前面加一个真的长度，当读取第一帧的时候先读取这一帧的长度，根据这一帧的长度在读取帧的数据长度，依次下去。。。</li>
<li>在每一帧的前面加关键字（特征码），只要遇到特征码就知道这一帧开始了，上一帧结束了。</li>
</ul>
<p>2.SPS/PPS（它只有几个字节，不会增加网络负担）<br>解码的视频参数，以及视频帧的宽高（也就是常说的视频分辨率），等等都是存在于SPS/PPS。</p>
<p>视频播放时，每次切换分辨率都要更新SPS/PPS。</p>
<p>而在视频直播时，在每个关键帧里面都会有一个SPS/PPS。</p>
<p>3.ffmpeg如何获取SPS/PPS？<br>codec-&gt;extradata</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o extr_video  extr_video.c `pkg-config --libs libavutil libavformat`</span><br><span class="line">./extr_video ./test.mp4  test.h264</span><br><span class="line">ffplay test.h264</span><br></pre></td></tr></table></figure>

<h1 id="mp4转flv"><a href="#mp4转flv" class="headerlink" title="mp4转flv"></a>mp4转flv</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">avformat_alloc_output_context2/avformat_free_context</span><br><span class="line"></span><br><span class="line">avformat_new_stream</span><br><span class="line"></span><br><span class="line">avcodec_parameters_copy</span><br><span class="line"></span><br><span class="line">avformat_write_header  <span class="comment">#头</span></span><br><span class="line"></span><br><span class="line">av_interleaved_write_frame  <span class="comment">#头数据</span></span><br><span class="line"></span><br><span class="line">av_write_trailer   <span class="comment">#尾</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o remuxing  remuxing.c `pkg-config --libs  libavformat`</span><br><span class="line">./remuxing ./test.mp4 test.flv   </span><br><span class="line">ffplay  test.flv</span><br></pre></td></tr></table></figure>

<h1 id="音视频裁剪"><a href="#音视频裁剪" class="headerlink" title="音视频裁剪"></a>音视频裁剪</h1><p>av_seek_frame</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o cutvideo  cutvideo.c `pkg-config --libs  libavformat  libavcodec`</span><br><span class="line">./cutvideo  10  20  ./test.mp4 cutvideo.mp4</span><br><span class="line">ffplay cutvideo.mp4</span><br></pre></td></tr></table></figure>


<h1 id="FFmpeg编解码概括"><a href="#FFmpeg编解码概括" class="headerlink" title="FFmpeg编解码概括"></a>FFmpeg编解码概括</h1><p>类型：</p>
<ul>
<li>H264解码</li>
<li>H264编码</li>
<li>AAC解码</li>
<li>AAC编码</li>
</ul>
<p>用到的头文件：</p>
<ul>
<li>libavcodec/avcodec.h</li>
</ul>
<p>用到的结构体：</p>
<ul>
<li>AVCodec编解码结构体</li>
<li>AVCodecContext 编解码器上下文</li>
<li>AVFrame 解码后的帧</li>
</ul>
<p>结构体内存的分配和释放API：</p>
<ul>
<li>av_frame_alloc/av_frame_free()</li>
<li>avcodec_alloc_context3()</li>
<li>avcodec_free_context()</li>
</ul>
<p>解码步骤：</p>
<ul>
<li><code>avcodec_find_decoder</code>查找解码器</li>
<li><code>avcodec_open2</code>打开解码器</li>
<li><code>avcodec_decode_video2</code>解码，得到RGB或者YUV数据</li>
</ul>
<h1 id="H264编码"><a href="#H264编码" class="headerlink" title="H264编码"></a>H264编码</h1><p>步骤：</p>
<ul>
<li><code>avcodec_find_encoder_by_name</code>查看编码器</li>
<li><code>avcodec_open2</code>设置编码参数，并打开编码器</li>
<li><code>avcodec_encode_video2</code>编码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o encode_video  encode_video.c `pkg-config --libs  libavcodec` </span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./encode_video  </span><br><span class="line">Usage: ./encode_video &lt;output file&gt; &lt;codec name&gt;</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./encode_video  encode_video.h264 libx264</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ffplay encode_video.h264</span><br></pre></td></tr></table></figure>

<h1 id="视频转图片"><a href="#视频转图片" class="headerlink" title="视频转图片"></a>视频转图片</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  FFmpeg-demo git:(master) ✗ clang -g -o decode_video  decode_video.c `pkg-config --libs  libavformat libavutil libavcodec libswscale`</span><br><span class="line">➜  FFmpeg-demo git:(master) ✗ ./decode_video ./test.mp4 ./</span><br></pre></td></tr></table></figure>



<h1 id="AAC编码"><a href="#AAC编码" class="headerlink" title="AAC编码"></a>AAC编码</h1><p>avcodec_encodec_audio2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -o encode_audio encode_audio.c `pkg-config --libs libavcodec`</span><br><span class="line">./encode_audio encode_audio.aac</span><br><span class="line">ffplay  encode_audio.aac</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg（二）</title>
    <url>/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>接着<a href="https://samtake.github.io/2019/11/04/FFmpeg/" target="_blank" rel="noopener">FFmpeg这一篇</a>，这里记录FFmpeg的命令。</p>
<h1 id="命令分成以下几类："><a href="#命令分成以下几类：" class="headerlink" title="命令分成以下几类："></a>命令分成以下几类：</h1><ul>
<li>基本信息查询命令</li>
<li>录制</li>
<li>分解/复用</li>
<li>处理原始数据</li>
<li>滤镜</li>
<li>切割与合并</li>
<li>图／视互转</li>
<li>直播相关<br>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</li>
</ul>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/ffmpeg%E6%92%AD%E6%94%BE%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="ffmpeg播放多媒体文件的流程"></p>
<p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。<br>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。<br>您可以通过使用-vn / -an / -sn / -dn选项来禁用某些默认设置。 要进行全面的手动控制，请使用-map选项，该选项禁用刚描述的默认设置。<br>下面我们就来详细介绍一下这些命令。</p>
<h1 id="基本信息查询命令"><a href="#基本信息查询命令" class="headerlink" title="基本信息查询命令"></a>基本信息查询命令</h1><h2 id="基本信息查询"><a href="#基本信息查询" class="headerlink" title="基本信息查询"></a>基本信息查询</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 ffmpeg -filters 来查询。详细参数说明如下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-version</td>
<td align="left">显示版本。</td>
</tr>
<tr>
<td align="left">-formats</td>
<td align="left">显示可用的格式（包括设备）。</td>
</tr>
<tr>
<td align="left">-demuxers</td>
<td align="left">显示可用的demuxers。</td>
</tr>
<tr>
<td align="left">-muxers</td>
<td align="left">显示可用的muxers。</td>
</tr>
<tr>
<td align="left">-devices</td>
<td align="left">显示可用的设备。</td>
</tr>
<tr>
<td align="left">-codecs</td>
<td align="left">显示libavcodec已知的所有编解码器。</td>
</tr>
<tr>
<td align="left">-decoders</td>
<td align="left">显示可用的解码器。</td>
</tr>
<tr>
<td align="left">-encoders</td>
<td align="left">显示所有可用的编码器。</td>
</tr>
<tr>
<td align="left">-bsfs</td>
<td align="left">显示可用的比特流filter。</td>
</tr>
<tr>
<td align="left">-protocols</td>
<td align="left">显示可用的协议。</td>
</tr>
<tr>
<td align="left">-filters</td>
<td align="left">显示可用的libavfilter过滤器。</td>
</tr>
<tr>
<td align="left">-pix_fmts</td>
<td align="left">显示可用的像素格式。</td>
</tr>
<tr>
<td align="left">-sample_fmts</td>
<td align="left">显示可用的采样格式。</td>
</tr>
<tr>
<td align="left">-layouts</td>
<td align="left">显示channel名称和标准channel布局。</td>
</tr>
<tr>
<td align="left">-colors</td>
<td align="left">显示识别的颜色名称。</td>
</tr>
</tbody></table>
<h2 id="命令格式与参数"><a href="#命令格式与参数" class="headerlink" title="命令格式与参数"></a>命令格式与参数</h2><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。<br>下面是 FFMPEG 的基本命令格式：<br><code>ffmpeg [global_options] {[input_file_options] -i input_url} ...</code><br>                        <code>{[output_file_options] output_url} ...</code></p>
<p><code>ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等，并写入任意数量的输出“文件”。</code></p>
<p>原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。 流的数量和/或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。<br>要引用选项中的输入文件，您必须使用它们的索引（从0开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如。 2：3是指第三个输入文件中的第四个流。<br>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p>
<h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><p>参数    说明<br><code>-f fmt（输入/输出）</code>    强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。<br><code>-i url（输入）</code>    输入文件的网址<br><code>-y（全局参数）</code>    覆盖输出文件而不询问。<br><code>-n（全局参数）</code>    不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。<br><code>-c [：stream_specifier] codec（输入/输出，每个流）</code>    选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT<br><code>-codec [：stream_specifier]编解码器（输入/输出，每个流）    同 -c</code>-t duration（输入/输出）<code>当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</code>-ss位置（输入/输出）`    当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</p>
<p><code>-frames [：stream_specifier] framecount（output，per-stream）</code>    停止在帧计数帧之后写入流。</p>
<p><code>-filter [：stream_specifier] filtergraph（output，per-stream）</code>    创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</p>
<h2 id="视频参数"><a href="#视频参数" class="headerlink" title="视频参数"></a>视频参数</h2><p>参数    说明<br><code>-vframes num（输出）</code>    设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。<br><code>-r [：stream_specifier] fps（输入/输出，每个流）</code>    设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。<br><code>-s [：stream_specifier]大小（输入/输出，每个流）</code>    设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。<br><code>-aspect [：stream_specifier] 宽高比（输出，每个流）</code>    设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。<br><code>-vn（输出）</code>    禁用视频录制。<br><code>-vcodec编解码器（输出）</code>    设置视频编解码器。这是-codec：v的别名。<br><code>-vf filtergraph（输出）</code>    创建由filtergraph指定的过滤器图，并使用它来过滤流。</p>
<h2 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h2><p>参数    说明<br><code>-aframes（输出）</code>    设置要输出的音频帧的数量。这是-frames：a的一个过时的别名。<br><code>-ar [：stream_specifier] freq（输入/输出，每个流）</code>    设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。<br><code>-ac [：stream_specifier]通道（输入/输出，每个流）</code>    设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。<br><code>-an（输出）</code>    禁用录音。<br><code>-acodec编解码器（输入/输出）</code>    设置音频编解码器。这是-codec的别名：a。<br><code>-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</code>    设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。<br><code>-af filtergraph（输出）</code>    创建由filtergraph指定的过滤器图，并使用它来过滤流。<br>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p>
<h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。<br><code>ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</code></p>
<h3 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h3><p><code>ffmpeg -f avfoundation -i 1 -r 30 out.yuv</code></p>
<ul>
<li>-f 指定使用 avfoundation 采集数据。</li>
<li>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</li>
<li>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r用于限制输出。<br>注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</li>
</ul>
<h3 id="录屏-声音"><a href="#录屏-声音" class="headerlink" title="录屏+声音"></a>录屏+声音</h3><p><code>ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</code></p>
<ul>
<li>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</li>
<li>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</li>
<li>-crf 是 x264 的参数。 0 表式无损压缩。</li>
<li>-c:a 与参数 -acodec 一样，表示音频编码器。</li>
<li>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</li>
<li>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</li>
</ul>
<h3 id="录视频"><a href="#录视频" class="headerlink" title="录视频"></a>录视频</h3><p><code>ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</code> </p>
<ul>
<li>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</li>
<li>-f 指定使用 avfoundation 采集数据。</li>
<li>-i 指定视频设备的索引号。</li>
</ul>
<h3 id="视频-音频"><a href="#视频-音频" class="headerlink" title="视频+音频"></a>视频+音频</h3><p><code>ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</code> </p>
<h3 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h3><p><code>ffmpeg -f avfoundation -i :0 out.wav</code></p>
<h3 id="录制音频裸数据"><a href="#录制音频裸数据" class="headerlink" title="录制音频裸数据"></a>录制音频裸数据</h3><p><code>ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</code></p>
<h2 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%8D%E7%94%A8.png" alt="分解与复用"></p>
<p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p>
<h3 id="抽取音频流"><a href="#抽取音频流" class="headerlink" title="抽取音频流"></a>抽取音频流</h3><p><code>ffmpeg -i input.mp4 -acodec copy -vn out.aac</code></p>
<ul>
<li>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</li>
<li>vn: v 代表视频，n 代表 no 也就是无视频的意思。</li>
</ul>
<h3 id="抽取视频流"><a href="#抽取视频流" class="headerlink" title="抽取视频流"></a>抽取视频流</h3><p><code>ffmpeg -i input.mp4 -vcodec copy -an out.h264</code></p>
<ul>
<li>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</li>
<li>an: a 代表视频，n 代表 no 也就是无音频的意思。</li>
</ul>
<h3 id="转格式"><a href="#转格式" class="headerlink" title="转格式"></a>转格式</h3><p><code>ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</code><br>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv。</p>
<h3 id="音视频合并"><a href="#音视频合并" class="headerlink" title="音视频合并"></a>音视频合并</h3><p><code>ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</code></p>
<h2 id="处理原始数据"><a href="#处理原始数据" class="headerlink" title="处理原始数据"></a>处理原始数据</h2><h3 id="提取YUV数据"><a href="#提取YUV数据" class="headerlink" title="提取YUV数据"></a>提取YUV数据</h3><p><code>ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv
ffplay -s wxh out.yuv</code></p>
<ul>
<li>-c:v rawvideo 指定将视频转成原始数据</li>
<li>-pixel_format yuv420p 指定转换格式为yuv420p</li>
</ul>
<h3 id="YUV转H264"><a href="#YUV转H264" class="headerlink" title="YUV转H264"></a>YUV转H264</h3><p><code>ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</code></p>
<h3 id="提取PCM数据"><a href="#提取PCM数据" class="headerlink" title="提取PCM数据"></a>提取PCM数据</h3><p><code>ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm
ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</code></p>
<h3 id="PCM转WAV"><a href="#PCM转WAV" class="headerlink" title="PCM转WAV"></a>PCM转WAV</h3><p><code>ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</code></p>
<h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>在编码之前，ffmpeg可以使用libavfilter库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg区分两种类型的过滤器图形：简单和复杂。</p>
<h3 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E7%AE%80%E5%8D%95%E6%BB%A4%E9%95%9C1.png" alt="简单滤镜1"></p>
<p>简单的filtergraphs配置了per-stream-filter选项（分别为视频和音频使用-vf和-af别名）。 一个简单的视频filtergraph可以看起来像这样的例子：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E7%AE%80%E5%8D%95%E6%BB%A4%E9%95%9C2.png" alt="简单滤镜2"></p>
<p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的fps过滤器会改变帧数，但不会触及帧内容。 另一个例子是setpts过滤器，它只设置时间戳，否则不改变帧。</p>
<h3 id="复杂滤镜"><a href="#复杂滤镜" class="headerlink" title="复杂滤镜"></a>复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p>
<p><img src="/2020/03/23/FFmpeg%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%A4%8D%E6%9D%82%E6%BB%A4%E9%95%9C1.png" alt="复杂滤镜1.png"></p>
<p>复杂的过滤器图使用-filter_complex选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。<br>-lavfi选项等同于-filter_complex。<br>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是amix滤波器。</p>
<h3 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h3><p><code>ffmpeg -i out.mp4  -vf &quot;movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]&quot; water.mp4</code></p>
<ul>
<li>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。<h3 id="删除水印"><a href="#删除水印" class="headerlink" title="删除水印"></a>删除水印</h3>先通过 ffplay 找到要删除 LOGO 的位置<br><code>ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1</code><br>使用 delogo 滤镜删除 LOGO<br><code>ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv</code><h3 id="视频缩小一倍"><a href="#视频缩小一倍" class="headerlink" title="视频缩小一倍"></a>视频缩小一倍</h3><code>ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</code></li>
<li>vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。<h3 id="视频裁剪"><a href="#视频裁剪" class="headerlink" title="视频裁剪"></a>视频裁剪</h3><code>ffmpeg -i VR.mov  -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</code><br>crop 格式：crop=out_w:out_h:x:y</li>
<li>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</li>
<li>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</li>
<li>x : X坐标</li>
<li>y : Y坐标</li>
</ul>
<p>如果 x和y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。</p>
<h3 id="倍速播放"><a href="#倍速播放" class="headerlink" title="倍速播放"></a>倍速播放</h3><p><code>ffmpeg -i out.mp4 -filter_complex &quot;[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]&quot; -map &quot;[v]&quot; -map &quot;[a]&quot; speed2.0.mp4</code></p>
<ul>
<li>-filter_complex 复杂滤镜，[0:v]表示第一个（文件索引号是0）文件的视频作为输入。setpts=0.5*PTS表示每帧视频的pts时间戳都乘0.5 ，也就是差少一半。[v]表示输出的别名。音频同理就不详述了。</li>
<li>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</li>
</ul>
<h3 id="对称视频"><a href="#对称视频" class="headerlink" title="对称视频"></a>对称视频</h3><p><code>ffmpeg  -i out.mp4 -filter_complex &quot;[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w&quot; duicheng.mp4</code></p>
<ul>
<li>hflip 水平翻转<br>如果要修改为垂直翻转可以用vflip。<h3 id="画中画"><a href="#画中画" class="headerlink" title="画中画"></a>画中画</h3><code>ffmpeg -i out.mp4 -i out1.mp4 -filter_complex &quot;[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]&quot; -map &quot;[out]&quot; -movflags faststart new.mp4</code></li>
</ul>
<h3 id="录制画中画"><a href="#录制画中画" class="headerlink" title="录制画中画"></a>录制画中画</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation -i <span class="string">"0:0"</span></span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast </span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 </span><br><span class="line">-filter_complex <span class="string">"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]"</span> </span><br><span class="line">-map <span class="string">"[out]"</span> -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure>

<h3 id="多路视频拼接"><a href="#多路视频拼接" class="headerlink" title="多路视频拼接"></a>多路视频拼接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i <span class="string">"1"</span> -framerate 30 -f avfoundation   -i <span class="string">"0:0"</span> -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex <span class="string">"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]"</span> -map <span class="string">"[out]"</span> -movflags faststart  -map 1:a  c.mp4</span><br></pre></td></tr></table></figure>

<h2 id="音视频的拼接与裁剪"><a href="#音视频的拼接与裁剪" class="headerlink" title="音视频的拼接与裁剪"></a>音视频的拼接与裁剪</h2><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p><code>ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</code></p>
<ul>
<li>-ss 指定裁剪的开始时间，精确到秒</li>
<li>-t 被裁剪后的时长。</li>
</ul>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>首先创建一个 inputs.txt 文件，文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file <span class="string">'1.flv'</span></span><br><span class="line">file <span class="string">'2.flv'</span></span><br><span class="line">file <span class="string">'3.flv'</span></span><br></pre></td></tr></table></figure>
<p>然后执行下面的命令：<br><code>ffmpeg -f concat -i inputs.txt -c copy output.flv</code></p>
<p>hls切片<br><code>ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</code></p>
<ul>
<li>-strict -2 指明音频使有AAC。</li>
<li>-f hls 转成 m3u8 格式。</li>
</ul>
<h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><h3 id="视频转JPEG"><a href="#视频转JPEG" class="headerlink" title="视频转JPEG"></a>视频转JPEG</h3><p><code>ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</code></p>
<h3 id="视频转gif"><a href="#视频转gif" class="headerlink" title="视频转gif"></a>视频转gif</h3><p><code>ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</code></p>
<h3 id="图片转视频"><a href="#图片转视频" class="headerlink" title="图片转视频"></a>图片转视频</h3><p><code>ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</code></p>
<h2 id="直播相关"><a href="#直播相关" class="headerlink" title="直播相关"></a>直播相关</h2><h3 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h3><p><code>ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</code></p>
<h3 id="拉流保存"><a href="#拉流保存" class="headerlink" title="拉流保存"></a>拉流保存</h3><p><code>ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</code></p>
<h3 id="转流"><a href="#转流" class="headerlink" title="转流"></a>转流</h3><p><code>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream</code></p>
<h3 id="实时推流"><a href="#实时推流" class="headerlink" title="实时推流"></a>实时推流</h3><p><code>ffmpeg -framerate 15 -f avfoundation -i &quot;1&quot; -s 1280x720 -c:v libx264  -f  flv rtmp://localhost:1935/live/room
ffplay</code></p>
<h3 id="播放YUV-数据"><a href="#播放YUV-数据" class="headerlink" title="播放YUV 数据"></a>播放YUV 数据</h3><p><code>ffplay -pix_fmt nv12 -s 192x144 1.yuv</code></p>
<h3 id="播放YUV中的-Y平面"><a href="#播放YUV中的-Y平面" class="headerlink" title="播放YUV中的 Y平面"></a>播放YUV中的 Y平面</h3><p><code>ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes=&#39;y&#39; 1.yuv</code></p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC（二）</title>
    <url>/2020/03/22/WebRTC%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://samtake.github.io/2019/11/04/WebRTC/" target="_blank" rel="noopener">前一篇</a>有对WebRTC以及用到的协议做了一些简单介绍。</p>
<p>先回忆下WebRTC终端的五个流程：</p>
<ul>
<li>获取权限（摄像头、麦克风）</li>
<li>本地视频的采集与展示</li>
<li>创建<code>RTCPeerConnection</code></li>
<li>媒体协商</li>
<li>远端视频的展示</li>
</ul>
<h1 id="媒体协商"><a href="#媒体协商" class="headerlink" title="媒体协商"></a>媒体协商</h1><p>在双方通信时，双方必须清楚彼此使用的编解码器是什么，也必须知道传输过来的音视频流的 SSRC。媒体协商的作用就是让双方找到共同支持的媒体能力，如双方都支持的编解码器，从而最终实现彼此之间的音视频通信。</p>
<p>步骤：</p>
<ul>
<li>创建一个 RTCPeerConnection 对象</li>
<li>createOffer ，创建 Offer；</li>
<li>createAnswer，创建 Answer；</li>
<li>setLocalDescription，设置本地 SDP 信息；</li>
<li>setRemoteDescription，设置远端的 SDP 信息。</li>
</ul>
<p>流程叙述：</p>
<p>首先，呼叫方创建 Offer 类型的 SDP 消息。创建完成后，调用 setLocalDescriptoin 方法将该 Offer 保存到本地 Local 域，然后通过信令将 Offer 发送给被呼叫方。</p>
<p>被呼叫方收到 Offer 类型的 SDP 消息后，调用 setRemoteDescription 方法将 Offer 保存到它的 Remote 域。作为应答，被呼叫方要创建 Answer 类型的 SDP 消息，Answer 消息创建成功后，再调用 setLocalDescription 方法将 Answer 类型的 SDP 消息保存到本地的 Local 域。最后，被呼叫方将 Answer 消息通过信令发送给呼叫方。至此，被呼叫方的工作就完部完成了。</p>
<p>接下来是呼叫方的收尾工作，呼叫方收到 Answer 类型的消息后，调用 RTCPeerConnecton 对象的 setRemoteDescription 方法，将 Answer 保存到它的 Remote 域。</p>
<p>至此，整个媒体协商过程处理完毕。</p>
<h1 id="WebRTC建立连接"><a href="#WebRTC建立连接" class="headerlink" title="WebRTC建立连接"></a>WebRTC建立连接</h1><p><img src="/2020/03/22/WebRTC%EF%BC%88%E4%BA%8C%EF%BC%89/1to1-connected.png" alt></p>
<p>首先会尝试 NAT 穿越，即尝试端到端直连。如果能够穿越成功，那双方就通过直连的方式传输数据，这是最高效的。但如果 NAT 穿越失败，为了保障通信双方的连通性，WebRTC 会使用中继方式，当然使用这种方式传输效率会低一些。</p>
<p>在整个过程中，WebRTC 使用优先级的方法去建立连接，即局域网内的优先级最高，其次是 NAT 穿越，再次是通过中继服务器进行中转，这样就巧妙地实现了“既要高效传输，又能保证连通率”这个目标。</p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>lightworks视频剪辑软件基本操作教程</title>
    <url>/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p><code>LOG</code>放文件内容<br><code>EDIT</code>剪辑<br><code>VFX</code>加文字等效果<br><code>AUDIO</code>添加音频</p>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><p>Project Contents<br>Local Files<br>Audio Network<br>Pond5</p>
<h2 id="EDIT"><a href="#EDIT" class="headerlink" title="EDIT"></a>EDIT</h2><p>A开头的是视频文件本身自带的音效，点一下变暗后播放就没有这个音效了</p>
<p>剪切和合并点X键，剪切后可以随意看奥运与组合，点击不要的部分点邮件删除</p>
<p>右键点击速度可变慢或加快播放速度，不要的话就点删除，跨界见CTRL+Z可以还原上一步操作</p>
<p>可覆盖原本的音频或家在下面</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/EDIT-Audio.png" alt></p>
<h2 id="VFX"><a href="#VFX" class="headerlink" title="VFX"></a>VFX</h2><p>点击+添加文字，改变字体大小和颜色</p>
<h2 id="AUDIO"><a href="#AUDIO" class="headerlink" title="AUDIO"></a>AUDIO</h2><p>音量大小等修改</p>
<p>保存文件点右键出口-媒体文件-一般是MP4/AVI 720适宜，当然越大也越清楚，文件内存也越大</p>
<h1 id="2-界面和新建工程"><a href="#2-界面和新建工程" class="headerlink" title="2.界面和新建工程"></a>2.界面和新建工程</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-setting.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-project-type.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-project-contents.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial2-project-contents-windows.png" alt></p>
<h1 id="3-导入素材和新建序列"><a href="#3-导入素材和新建序列" class="headerlink" title="3.导入素材和新建序列"></a>3.导入素材和新建序列</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial3-import-setting3.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial3-import-setting3.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial3-new-serial1.png" alt></p>
<p>序列之间是不能嵌套的。</p>
<h1 id="4-时间线操作-amp-选定素材区域插入时间轴"><a href="#4-时间线操作-amp-选定素材区域插入时间轴" class="headerlink" title="4.时间线操作&amp;选定素材区域插入时间轴"></a>4.时间线操作&amp;选定素材区域插入时间轴</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-operation.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-blank.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-source.png" alt></p>
<p>同时时间轴上的素材可以左右拖拉：切换位置、前后时间延长</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial4-time-source-only.png" alt></p>
<h1 id="5-时间轴素材调整-amp-音频轨道同步"><a href="#5-时间轴素材调整-amp-音频轨道同步" class="headerlink" title="5.时间轴素材调整&amp;音频轨道同步"></a>5.时间轴素材调整&amp;音频轨道同步</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-zoom.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut2.png" alt></p>
<p>键盘的加减号是放大和缩小时间轴</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2.png" alt></p>
<p><code>Slip - Y</code>点击空格键播放，选中素材的另外前后素材位置没有变化，播放时长也没有变化，而该选中素材则随着播放，时间慢慢增加。<br><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-slip.png" alt></p>
<p><code>Slide - T</code>选中素材没有变化。</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-Slide.png" alt></p>
<p><code>Trim In - W</code></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-trim-in.png" alt></p>
<p><code>Trim Out - E</code>在出点标记处进行延长或缩短</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>1.假设只对视频进行缩减时，这会导致音视频不同轨，处理方法<br><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-auto-track.png" alt></p>
<p>2.<br><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial5-time-cut-method2-track-operation.png" alt></p>
<p> 3.快捷键</p>
<p> <code>j</code> 倒方</p>
<p> <code>k</code> 停止 </p>
<p> <code>l</code> 素材向右播放，重复按下<code>j</code>会加速向右播放</p>
<h1 id="6-添加转场-amp-转场相关设置"><a href="#6-添加转场-amp-转场相关设置" class="headerlink" title="6.添加转场&amp;转场相关设置"></a>6.添加转场&amp;转场相关设置</h1><h2 id="添加转场步骤"><a href="#添加转场步骤" class="headerlink" title="添加转场步骤"></a>添加转场步骤</h2><p>先要通过拖动素材，让两个素材的某个部分重叠，留出转场的空间。</p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-steps.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-other.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-other2.png" alt></p>
<p>音频和视频转场都是一样～～～操作差不多</p>
<h2 id="让结尾处渐暗"><a href="#让结尾处渐暗" class="headerlink" title="让结尾处渐暗"></a>让结尾处渐暗</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-black1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial6-transitions-black2.png" alt></p>
<h1 id="7-VFX节本操作-amp-剪辑播放速度调整"><a href="#7-VFX节本操作-amp-剪辑播放速度调整" class="headerlink" title="7.VFX节本操作&amp;剪辑播放速度调整"></a>7.VFX节本操作&amp;剪辑播放速度调整</h1><h2 id="添加字幕"><a href="#添加字幕" class="headerlink" title="添加字幕"></a>添加字幕</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial7-VFX1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial7-VFX2.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial7-VFX3.png" alt></p>
<h2 id="8-调整素材播放速度"><a href="#8-调整素材播放速度" class="headerlink" title="8.调整素材播放速度"></a>8.调整素材播放速度</h2><p>时间轴-右键-Speed-设置速度即可</p>
<h1 id="8-Routing简介-amp-应用"><a href="#8-Routing简介-amp-应用" class="headerlink" title="8.Routing简介&amp;应用"></a>8.Routing简介&amp;应用</h1><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial8-routing.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial8-routing-use1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial8-routing-use2.png" alt></p>
<h1 id="9-音频效果窗口-amp-导出设置"><a href="#9-音频效果窗口-amp-导出设置" class="headerlink" title="9.音频效果窗口&amp;导出设置"></a>9.音频效果窗口&amp;导出设置</h1><h2 id="渐入音效"><a href="#渐入音效" class="headerlink" title="渐入音效"></a>渐入音效</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-audio1.png" alt></p>
<h2 id="让关键帧效果位置整体改变"><a href="#让关键帧效果位置整体改变" class="headerlink" title="让关键帧效果位置整体改变"></a>让关键帧效果位置整体改变</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-audio2.png" alt></p>
<h2 id="其他的修音设置"><a href="#其他的修音设置" class="headerlink" title="其他的修音设置"></a>其他的修音设置</h2><h2 id="导出设置"><a href="#导出设置" class="headerlink" title="导出设置"></a>导出设置</h2><p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-export1.png" alt></p>
<p><img src="/2020/03/15/lightworks%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/serial9-export2.jpeg" alt></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://www.bilibili.com/video/av31939070" target="_blank" rel="noopener">Lightworks 14 Tutorials 中文字幕教程</a></p>
<p><a href="https://www.lwks.com/" target="_blank" rel="noopener">Lightworks 软件官方地址</a></p>
]]></content>
      <categories>
        <category>lightworks</category>
      </categories>
      <tags>
        <tag>lightworks</tag>
      </tags>
  </entry>
  <entry>
    <title>读书记录-20200311</title>
    <url>/2020/03/11/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-20200311/</url>
    <content><![CDATA[<p><img src="/2020/03/11/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-20200311/20200311-%E4%B9%A6%E5%8D%95.jpeg" alt></p>
<p>附录</p>
<p><a href="https://www.bilibili.com/video/av3755315?from=search&seid=1211682021322553260" target="_blank" rel="noopener">100个梦想的赞助商（微电影）</a></p>
<p><a href="https://www.bilibili.com/video/av37465443?from=search&seid=14561064290056795500" target="_blank" rel="noopener">我们的时代</a></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>ant-design学习</title>
    <url>/2020/03/03/ant-design%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>全篇下来太啰嗦，<a href="https://github.com/sorrycc/blog/issues/62" target="_blank" rel="noopener">umi + dva，完成用户管理的 CURD 应用</a>是重点，看这里就行了！！！</p>
<h2 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h2><p><a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a>,<code>antd</code> 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。</p>
<h3 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h3><ul>
<li><p>config：配置信息<br><code>config.js</code>全局配置，路由配置<br><code>defaultSettings.js</code>一些默认配置<br><code>plugin.config.js</code>插件配置</p>
</li>
<li><p>mock 模拟数据请求的</p>
</li>
<li><p>mode_modules 第三方库</p>
</li>
<li><p>public 放置第三方文件（比如说图片，第三方的json文件）</p>
</li>
<li><p>tests 做一些测试的</p>
</li>
<li><p>package.json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"ant-design-pro"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"An out-of-box UI solution for enterprise applications"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"analyze"</span>: <span class="string">"分析"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"编译"</span>,</span><br><span class="line">    <span class="string">"deploy"</span>: <span class="string">"部署"</span>,</span><br><span class="line">    <span class="string">"fetch:blocks"</span>: <span class="string">"从官网git里面去拉模块"</span>,</span><br><span class="line">    <span class="string">"format-imports"</span>: <span class="string">"代码格式（例如空格）"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"启动"</span>,</span><br><span class="line">    <span class="string">"start:no-mock"</span>: <span class="string">"cross-env MOCK=none umi dev"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"测试"</span>,</span><br><span class="line">    <span class="string">"test:all"</span>: <span class="string">"node ./tests/run-tests.js"</span>,</span><br><span class="line">    <span class="string">"test:component"</span>: <span class="string">"umi test ./src/components"</span>,</span><br><span class="line">    <span class="string">"ui"</span>: <span class="string">"umi ui"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>src</p>
</li>
</ul>
<p><code>assets</code>静态资源<br><code>components</code>组件目录<br><code>e2e</code><br><code>layouts</code>布局<br><code>locales</code>多语言<br><code>models</code>模型目录<br><code>pages</code>页面<br><code>services</code>提供服务，给页面提供请求<br><code>utils</code>工具类<br><code>global.less</code><br><code>global.tsx</code><br><code>manifelst.json</code><br><code>service-worker.js</code><br><code>typings.d.ts</code></p>
<h3 id="增加新页面"><a href="#增加新页面" class="headerlink" title="增加新页面"></a>增加新页面</h3><p>1.在config-config.js文件的routers节点添加代码</p>
<p>{name: ‘demo’, path: ‘/demo’, component: ‘./demo’},</p>
<p>2.在page目录下创建demo目录，并新建一个index.jsx文件。<br>3.添加源码。</p>
<h2 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h2><ul>
<li><a href="https://dvajs.com" target="_blank" rel="noopener">dva官网</a></li>
<li><a href="https://www.bilibili.com/video/av55863089?from=search&seid=7612457114058753391" target="_blank" rel="noopener">dva视频教程</a>，以及练习<a href="https://github.com/samtake/dva" target="_blank" rel="noopener">源码</a></li>
<li><a href="https://www.jianshu.com/p/0568a725f8f9" target="_blank" rel="noopener">dva.js的使用与说明</a></li>
</ul>
<h2 id="UmiJS"><a href="#UmiJS" class="headerlink" title="UmiJS"></a>UmiJS</h2><ul>
<li><a href="https://umijs.org/zh-CN" target="_blank" rel="noopener">UmiJS</a></li>
<li><a href="https://www.bilibili.com/video/av74033079?p=51" target="_blank" rel="noopener">UmiJS视频教程</a>，以及<a href="https://github.com/plter/ReactCourse20191031" target="_blank" rel="noopener">源码</a></li>
<li><a href="https://www.cnblogs.com/lihuijuan/p/11242976.html" target="_blank" rel="noopener">Ant Design Pro 脚手架+umiJS 实践总结</a></li>
</ul>
<h2 id="dva-umi"><a href="#dva-umi" class="headerlink" title="dva + umi"></a>dva + umi</h2><p>主要搞懂model、service的关系</p>
<ul>
<li><a href="https://github.com/sorrycc/blog/issues/62" target="_blank" rel="noopener">umi + dva，完成用户管理的 CURD 应用</a></li>
<li><a href="https://github.com/umijs/umi-example-dva-user-dashboard" target="_blank" rel="noopener">umi-example-dva-user-dashboard</a></li>
</ul>
]]></content>
      <categories>
        <category>ant-design</category>
      </categories>
      <tags>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitea</title>
    <url>/2020/03/02/Gitea/</url>
    <content><![CDATA[<p><a href="https://gitea.io/zh-cn/" target="_blank" rel="noopener">Gitea</a>:一个开源社区驱动的轻量级代码托管解决方案</p>
]]></content>
  </entry>
  <entry>
    <title>Golang搭建并行处理管道</title>
    <url>/2020/03/02/Golang%E6%90%AD%E5%BB%BA%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang练习笔记</title>
    <url>/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableZeroValue</span></span>() &#123;</span><br><span class="line">	var a int</span><br><span class="line">	var s string</span><br><span class="line">	fmt.Printf(<span class="string">"%d %q\n"</span>, a, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableInitialValue</span></span>() &#123;</span><br><span class="line">	var a, b int = 3, 4</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型推断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableTypeDeduction</span></span>() &#123;</span><br><span class="line">	var a, b, c, d = 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>利用冒号定义的简单写法  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">variableShorter</span></span>() &#123;</span><br><span class="line">	a, b, c, d := 3, 4, <span class="literal">true</span>, <span class="string">"def"</span></span><br><span class="line">	b = 6</span><br><span class="line">	var s string = <span class="string">"abc"</span></span><br><span class="line">	fmt.Println(a, b, c, d, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数外的变量定义(不能使用冒号定义，且它的作用域只在该包内部)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var aa = 55</span><br><span class="line">var ss = <span class="string">"llll"</span></span><br><span class="line">var bb = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">	bbb = 666</span><br><span class="line">	sss = <span class="string">"jjj"</span></span><br><span class="line">	ttt = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h2><p><code>bool</code>, <code>string</code>,</p>
<p><code>(u)int</code>, <code>(u)int8</code>, <code>(u)int16</code>, <code>(u)int32</code>, <code>(u)int64</code>, <code>uintptr</code>,</p>
<p><code>byte</code>, <code>rune</code>,</p>
<p><code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>,</p>
<h2 id="常量与枚举"><a href="#常量与枚举" class="headerlink" title="常量与枚举"></a>常量与枚举</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> func <span class="function"><span class="title">consts</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	const a, b = 3, 4</span><br><span class="line">	var c int</span><br><span class="line">	c = int(math.Sqrt(a*a + b + b))</span><br><span class="line">	fmt.Println(filename, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">enums</span></span>() &#123;</span><br><span class="line">	const (</span><br><span class="line">		cpp = iota</span><br><span class="line">		java</span><br><span class="line">		golang</span><br><span class="line">		swift</span><br><span class="line">		_</span><br><span class="line">		C</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	const (</span><br><span class="line">		b = 1 &lt;&lt; (10 * iota)</span><br><span class="line">		bb</span><br><span class="line">		bbb</span><br><span class="line">		bbbb</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	fmt.Println(cpp, java, golang, C)</span><br><span class="line">	fmt.Println(b, bb, bbb, bbbb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abc.txt 4</span><br><span class="line">0 1 2 5</span><br><span class="line">1 1024 1048576 1073741824</span><br></pre></td></tr></table></figure>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if的条件里可以赋值<br>if的条件里赋值的变量作用域就在这个if语句里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	const filename = <span class="string">"abc.txt"</span></span><br><span class="line">	<span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch后面可以没有表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func grade(score int) string &#123;</span><br><span class="line">	g := <span class="string">""</span></span><br><span class="line">	switch &#123;</span><br><span class="line">	<span class="keyword">case</span> score &lt; 0 || score &gt; 100:</span><br><span class="line">		panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	<span class="keyword">case</span> score &lt; 60:</span><br><span class="line">		g = <span class="string">"F"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 80:</span><br><span class="line">		g = <span class="string">"C"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 90:</span><br><span class="line">		g = <span class="string">"B"</span></span><br><span class="line">	<span class="keyword">case</span> score &lt; 100:</span><br><span class="line">		g = <span class="string">"A"</span></span><br><span class="line">		// default:</span><br><span class="line">		// 	panic(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func convertToBin(n int) string &#123;</span><br><span class="line">	res := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> ; n &gt; 0; n /= 2 &#123;</span><br><span class="line">		lsb := n % 2</span><br><span class="line">		res = strconv.Itoa(lsb) + res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printFile(filename string) &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	scanner := bufio.NewScanner(file)</span><br><span class="line">	<span class="keyword">for</span> scanner.<span class="function"><span class="title">Scan</span></span>() &#123;</span><br><span class="line">		fmt.Println(scanner.Text)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">forever</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"abc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>返回值类型写在后面</li>
<li>可返回多个值</li>
<li>函数作为参数</li>
<li>没有默认参数，有可选参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func div(a, b int) (q, r int) &#123;</span><br><span class="line">	// <span class="built_in">return</span> a / b, a % b</span><br><span class="line">	q = a / b</span><br><span class="line">	r = a % b</span><br><span class="line">	<span class="built_in">return</span> q, r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func pow(a, b int) int &#123;</span><br><span class="line">	<span class="built_in">return</span> int(math.Pow(float64(a), float64(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	q, r := div(8, 6)</span><br><span class="line">	fmt.Println(q, r)</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(pow, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者以匿名函数的形式进行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(apply(</span><br><span class="line">		func(a int, b int) int &#123;</span><br><span class="line">			<span class="built_in">return</span> int(math.Pow(</span><br><span class="line">				float64(a), float64(b)))</span><br><span class="line">		&#125;, 1, 5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>函数作为参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func apply(op func(int, int) int, a, b int) int &#123;</span><br><span class="line">	p := reflect.ValueOf(op).Pointer()</span><br><span class="line">	opName := runtime.FuncForPC(p).Name()</span><br><span class="line">	fmt.Printf(<span class="string">"Calling function %s with args "</span>+</span><br><span class="line">		<span class="string">"(%d, %d)\n"</span>, opName, a, b)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> op(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func sum(numbers ...int) int &#123;</span><br><span class="line">	s := 0</span><br><span class="line">	<span class="keyword">for</span> i := range numbers &#123;</span><br><span class="line">		s += numbers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>参数传递</p>
<ul>
<li><p>go语言只有值传递一种方式<br><code>var a int</code> 当参数传递给<code>fun f(pa *int)</code>它其实就是将a的指针&amp;a拷贝一份传递给pa,pa也跟&amp;a一样，同时指向a</p>
</li>
<li><p>再如：<code>var cache Cache</code> 当参数传递给<code>func f(cache Cache)</code>,参数Cache那么大不可能拷贝一份的，实际上Cache也只是一个指向data的指针，所以cache当参数的时候，它只是拷贝了一份指针，它同时也指向了data</p>
</li>
</ul>
<p>交换两个变量的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func swap(a, b int) &#123;</span><br><span class="line">	b, a = a, b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(a, b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  hello go run point.go</span><br><span class="line">3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>我们发现值没有变，这是需要使用指针，将a,b所指向的值改变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var a int = 2</span><br><span class="line">	var pa *int = &amp;a</span><br><span class="line">	*pa = 3</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) &#123;</span><br><span class="line">	*b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	exp()</span><br><span class="line"></span><br><span class="line">	a, b := 3, 4</span><br><span class="line">	swap(&amp;a, &amp;b)</span><br><span class="line">	println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	var arr1 [5]int</span><br><span class="line">	arr2 := [3]int&#123;1, 2, 3&#125;      //冒号等于的定义，需要给数组一个初值</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; //或者不指定数组个数</span><br><span class="line">	fmt.Println(arr1, arr2, arr3)</span><br><span class="line"></span><br><span class="line">	//二维数组定义</span><br><span class="line">	var grid [4][5]int</span><br><span class="line">	fmt.Println(grid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := 0; i &lt; len(arr3); i++ &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>下标</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := range arr3 &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>下标和值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := range arr3 &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>数组是值类型的，所以当参数用的时候需要指定长度<code>cannot use arr1 (type [5]int) as type [4]int in argument to printArray</code>，且在函数里面再次赋值后，它在外面是不会改变的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func printArray(arr [4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，依旧是1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以，[10]int和[20]int 是不同类型；调用func f(arr [10]int)会拷贝数组。需要改变它就需要用到指针了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">exp</span></span>() &#123;</span><br><span class="line">	arr3 := [...]int&#123;1, 2, 3, 4&#125; </span><br><span class="line"></span><br><span class="line">	printArray(&amp;arr3)</span><br><span class="line">	fmt.Println(arr3, arr3[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printArray(arr *[4]int) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := range arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	arr[0] = 100 //在外面调用时，改变为100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func updateSlice(s []int)&#123;</span><br><span class="line">	s[0] = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	//s := arr[2:6]</span><br><span class="line">	fmt.Println(<span class="string">"arr[2:6] ="</span>, arr[2:6])<span class="comment">#arr[2:6] = [2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[:6] ="</span>, arr[:6])<span class="comment">#arr[:6] = [0 1 2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[2:] ="</span>, arr[2:])<span class="comment">#arr[2:] = [2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[:] ="</span>, arr[:])<span class="comment">#arr[:] = [0 1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	s1 := arr[2:]</span><br><span class="line">	s2 := arr[:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s1"</span>)</span><br><span class="line">	updateSlice(s1)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 	after updateSlice(s1</span></span><br><span class="line"><span class="comment">#   [100 3 4 5 6 7]</span></span><br><span class="line"><span class="comment"># 	[0 1 100 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"after updateSlice(s2"</span>)</span><br><span class="line">	updateSlice(s2)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 	after updateSlice(s2</span></span><br><span class="line"><span class="comment"># 	[100 1 100 3 4 5 6 7] </span></span><br><span class="line"><span class="comment"># 	[100 1 100 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"printArray"</span>)</span><br><span class="line">	printArray(arr[:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 	printArray</span></span><br><span class="line"><span class="comment"># 	0 100</span></span><br><span class="line"><span class="comment"># 	1 50</span></span><br><span class="line"><span class="comment"># 	2 100</span></span><br><span class="line"><span class="comment"># 	3 3</span></span><br><span class="line"><span class="comment"># 	4 4</span></span><br><span class="line"><span class="comment">#	 5 5</span></span><br><span class="line"><span class="comment"># 	6 6</span></span><br><span class="line"><span class="comment"># 	7 7</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"reslice"</span>)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[:5]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s2 = s2[2:]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 	reslice</span></span><br><span class="line"><span class="comment"># 	[100 50 100 3 4 5 6 7]</span></span><br><span class="line"><span class="comment"># 	[100 50 100 3 4]</span></span><br><span class="line"><span class="comment"># 	[100 3 4]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/slice.png" alt="slice"></p>
<p>slice可以向后扩展，不可以向前扩展<br>s[i]不可以超越len(s)，向后扩展不可以超越底层数组 cap(s)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceExtension</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"sliceExtension"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]</span><br><span class="line">	s2 := s1[3:5]</span><br><span class="line">	fmt.Println(<span class="string">"s1="</span>, s1)</span><br><span class="line">	fmt.Println(<span class="string">"s2="</span>, s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># sliceExtension</span></span><br><span class="line"><span class="comment"># s1= [2 3 4 5]</span></span><br><span class="line"><span class="comment"># s2= [5 6]</span></span><br></pre></td></tr></table></figure>

<p>向slice添加元素时，如果超越了cap，系统会重新分配更大的底层数组<br>新的slice里面， ptr len cap都会变掉，所以必须接收append的返回值</p>
<p>s = append(s, value)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceAppend</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"slice append"</span>)</span><br><span class="line">	arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">	s1 := arr[2:6]       <span class="comment">#	2 3 4 5</span></span><br><span class="line">	s2 := s1[3:5]        <span class="comment">#	5 6</span></span><br><span class="line">	s3 := append(s2, 10) <span class="comment">#	5 6 10</span></span><br><span class="line">	s4 := append(s3, 11) <span class="comment">#	5 6 10 11</span></span><br><span class="line">	s5 := append(s4, 12) <span class="comment">#	5 6 10 11 12</span></span><br><span class="line">	fmt.Println(<span class="string">"s3="</span>, s3)</span><br><span class="line">	fmt.Println(<span class="string">"s4="</span>, s4)</span><br><span class="line">	fmt.Println(<span class="string">"s5="</span>, s5)</span><br><span class="line">	fmt.Println(<span class="string">"arr="</span>, arr) <span class="comment">#	0, 1, 2, 3, 4, 5, 6 10  数组长度不变的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice的创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">sliceCreate</span></span>() &#123;</span><br><span class="line">	var s []int  <span class="comment">#定义一个空slice</span></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		printSlice(s)</span><br><span class="line">		s = append(s, 2*i+1)</span><br><span class="line">	&#125;</span><br><span class="line">	println(s)</span><br><span class="line"></span><br><span class="line">	s1 := []int&#123;2, 3, 5, 6, 8, 2, 5&#125;</span><br><span class="line">	println(s1)</span><br><span class="line"></span><br><span class="line">	s2 := make([]int, 16)</span><br><span class="line">	s3 := make([]int, 10, 32) //32是开辟的空间<span class="built_in">cap</span></span><br><span class="line">	println(<span class="string">"print Slice  s2 s3"</span>)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">	printSlice(s3)</span><br><span class="line"></span><br><span class="line">	println(<span class="string">"Slice copy"</span>)</span><br><span class="line">	copy(s2, s1) <span class="comment"># 将s1复制给s2</span></span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">	//如何删除8</span><br><span class="line">	println(<span class="string">"Slice delete"</span>)</span><br><span class="line">	s2 = append(s2[:4], s2[5:]...)</span><br><span class="line">	printSlice(s2)</span><br><span class="line"></span><br><span class="line">	//删除头尾</span><br><span class="line">	fmt.Println(<span class="string">"pop from front"</span>)</span><br><span class="line">	front := s2[0]</span><br><span class="line">	s2 = s2[1:]</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"pop from back"</span>)</span><br><span class="line">	back := s2[len(s2)-1]</span><br><span class="line">	s2 = s2[:len(s2)-1]</span><br><span class="line">	fmt.Println(front, back)</span><br><span class="line">	printSlice(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> Slice  s2 s3</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0], len=10, <span class="built_in">cap</span>= 32</span><br><span class="line">Slice copy</span><br><span class="line">[2 3 5 6 8 2 5 0 0 0 0 0 0 0 0 0], len=16, <span class="built_in">cap</span>= 16</span><br><span class="line">Slice delete</span><br><span class="line">[2 3 5 6 2 5 0 0 0 0 0 0 0 0 0], len=15, <span class="built_in">cap</span>= 16</span><br><span class="line">pop from front</span><br><span class="line">pop from back</span><br><span class="line">2 0</span><br><span class="line">[3 5 6 2 5 0 0 0 0 0 0 0 0], len=13, <span class="built_in">cap</span>= 15</span><br></pre></td></tr></table></figure>



<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	m := map[string]string&#123;</span><br><span class="line">		<span class="string">"name"</span>:  <span class="string">"sam"</span>,</span><br><span class="line">		<span class="string">"class"</span>: <span class="string">"go"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	m2 := make(map[string]int)</span><br><span class="line"></span><br><span class="line">	var m3 map[string]int</span><br><span class="line"></span><br><span class="line">	fmt.Println(m2, m3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>遍历，key在map里是无序的～</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := range m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当key打错了，获取到的是空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取值</span><br><span class="line">	fmt.Println(<span class="string">"getting values"</span>)</span><br><span class="line">	name := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name)</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">	println(name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	println(<span class="string">"key does not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//删除</span><br><span class="line">	fmt.Println(<span class="string">"delete values"</span>)</span><br><span class="line">	name1, ok := m[<span class="string">"name"</span>]</span><br><span class="line">	println(name1, ok)</span><br></pre></td></tr></table></figure>

<p>map的key的类型可以是<br>除了slice,map,function的内建类型都可以作为key<br>struct类型不包含上述字段，也可以作为key</p>
<h2 id="字符和字符串的处理"><a href="#字符和字符串的处理" class="headerlink" title="字符和字符串的处理"></a>字符和字符串的处理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	s := <span class="string">"yes中文中文"</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	<span class="keyword">for</span> _, b := range []byte(s) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%X  "</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := range s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"(%d %X)"</span>, i, ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">"rune count:"</span>, utf8.RuneCountInString(s))</span><br><span class="line"></span><br><span class="line">	//单个字符转义</span><br><span class="line">	bytes := []byte(s)</span><br><span class="line">	<span class="keyword">for</span> len(bytes) &gt; 0 &#123;</span><br><span class="line">		ch, size := utf8.DecodeRune(bytes)</span><br><span class="line">		bytes = bytes[size:]</span><br><span class="line">		fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yes中文中文</span><br><span class="line">79  65  73  E4  B8  AD  E6  96  87  E4  B8  AD  E6  96  87  </span><br><span class="line">(0 79)(1 65)(2 73)(3 4E2D)(6 6587)(9 4E2D)(12 6587)</span><br><span class="line">rune count: 7</span><br><span class="line">y e s 中 文 中 文</span><br></pre></td></tr></table></figure>
<p>rune相当于go的char<br>使用range遍历string，rune对<br>使用utf8.RuneCountInString(s)获得字符数量<br>使用len获得字节长度<br>使用[]byte获得所有的字节</p>
<p>寻找最长不含重复字符的字串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func lengthOfNonRepeatSubStr(s string) int &#123;</span><br><span class="line">	lastOccurred := make(map[rune]int)</span><br><span class="line">	start := 0</span><br><span class="line">	maxLength := 0</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := range []rune(s) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123;</span><br><span class="line">			start = lastI + 1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i-start+1 &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start + 1</span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其它字符串操作<br>Fields Split Join<br>Contains Index<br>ToLower ToUpper<br>Trim TrimRight TrimLeft</p>
<h2 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>go仅支持封装，不支持继承和多态</p>
<p>结构体的创建：不论地址还是结构本身，一律使用<code>.</code>来访问成员</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定义</span><br><span class="line"><span class="built_in">type</span> treeNode struct &#123;</span><br><span class="line">	value       int</span><br><span class="line">	left, right *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂函数创建</span><br><span class="line">func createNode(value int) *treeNode &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;treeNode&#123;value: value&#125; //这里返回的是局部变量的地址给外部使用，在go依旧是可以的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var root treeNode</span><br><span class="line">	fmt.Println(root)</span><br><span class="line"></span><br><span class="line">	//创建</span><br><span class="line">	root = treeNode&#123;value: 3&#125;</span><br><span class="line">	root.left = &amp;treeNode&#123;&#125;</span><br><span class="line">	root.right = &amp;treeNode&#123;5, nil, nil&#125;</span><br><span class="line">	root.right.left = new(treeNode)</span><br><span class="line">	fmt.Println(root)</span><br><span class="line">	nodes := []treeNode&#123;</span><br><span class="line">		&#123;value: 3&#125;,</span><br><span class="line">		&#123;&#125;, </span><br><span class="line">		&#123;6, nil, &amp;root&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(nodes)</span><br><span class="line"></span><br><span class="line">	root.left.right = createNode(2)</span><br><span class="line">	fmt.Println(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给结构定义方法:<br>func后面括号的是方法接收者（其实就跟函数的返回值一样）<br>只有使用指针才可以改变结构的内容<br>nil指针也可以调用方法（可以将值传进来，但是nil的赋值会报错，需要做return处理）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//树的遍历:给结构定义方法</span><br><span class="line">func (node *treeNode) setValue(value int) &#123;</span><br><span class="line">	<span class="keyword">if</span> node == nil &#123;</span><br><span class="line">		fmt.Println(<span class="string">"setting value to nil node"</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	node.value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//值不会变</span><br><span class="line">// func (node treeNode) setValue(value int) &#123;</span><br><span class="line">// 	node.value = value</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">func (node *treeNode) setValue(value int) &#123;</span><br><span class="line">	node.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">"print\n"</span>)</span><br><span class="line">	root.print()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\nsetValue\n"</span>)</span><br><span class="line">	root.right.left.setValue(9)</span><br><span class="line">	root.right.left.print()</span><br></pre></td></tr></table></figure>


<p>中序遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"> 总结：</span><br><span class="line"> 要改变内容必须使用指针接收者</span><br><span class="line"> 结构过大也考虑使用指针接收者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 包和封装</span></span><br><span class="line"></span><br><span class="line">封装</span><br><span class="line">名字一般使用驼峰命名</span><br><span class="line">首字母大写：public（针对于包）</span><br><span class="line">首字母小写：private（针对于包）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">包</span><br><span class="line">每个目录一个包</span><br><span class="line">main包包含可执行入口</span><br><span class="line">为结构定义的方法必须放在同一个包内</span><br><span class="line">一个包可以放不同的文件</span><br><span class="line">建议结构体都不需要前缀包名（TreeNode改为Node即可）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 拓展已有类型</span></span><br><span class="line"></span><br><span class="line">定义别名</span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">type</span> myTreeNode struct &#123;</span><br><span class="line">	node *tree.TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后序遍历</span><br><span class="line">func (myNode *myTreeNode) <span class="function"><span class="title">postOrder</span></span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> myNode == nil || myNode.node == nil &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	left := myTreeNode&#123;myNode.node.Left&#125;</span><br><span class="line">	left.postOrder()</span><br><span class="line"></span><br><span class="line">	right := myTreeNode&#123;myNode.node.Right&#125;</span><br><span class="line">	right.postOrder()</span><br><span class="line"></span><br><span class="line">	myNode.node.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用组合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package queue</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Queue []int</span><br><span class="line"></span><br><span class="line">func (q *Queue) Push(v int) &#123;</span><br><span class="line">	*q = append(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Pop() int &#123;</span><br><span class="line">	head := (*q)[0]</span><br><span class="line">	*q = (*q)[1:]</span><br><span class="line">	<span class="built_in">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) IsEmpty() bool &#123;</span><br><span class="line">	<span class="built_in">return</span> len(*q) == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/queue"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	q := queue.Queue&#123;1&#125;</span><br><span class="line">	q.Push(2)</span><br><span class="line">	q.Push(3)</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.IsEmpty())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.IsEmpty())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用内嵌来扩展已有类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> myTreeNode struct &#123;</span><br><span class="line">	*tree.Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>GOPATH</li>
<li>GOVENDOR</li>
<li>go mod</li>
</ul>
<p>go mod的使用</p>
<p>引入需要的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>直接运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run zaptest.go</span><br></pre></td></tr></table></figure>


<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u 库名 </span><br><span class="line"></span><br><span class="line">go mod init modtest</span><br><span class="line"></span><br><span class="line">go build ./...</span><br></pre></td></tr></table></figure>

<p>增加依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get</span><br></pre></td></tr></table></figure>

<p>更新依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get [@version]</span><br><span class="line"></span><br><span class="line">go mod tidy  //更新版本之后，使用该命令可以去除多余的文件</span><br></pre></td></tr></table></figure>

<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>每个单独目录只有一个mian函数</p>
<p>build当前目录的所有子文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build ./...</span><br></pre></td></tr></table></figure>

<p>产生结果, 结果放在GOPATH的bin目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install ./...</span><br><span class="line">go env GOPATH</span><br></pre></td></tr></table></figure>

<h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>infra</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package infra</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (Retriver) Get(url string) string &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> string(bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>testing</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package testing</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (Retriver) Get(url string) string &#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">"fake content"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>download</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/downloader/infra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func getRetriver() retriver &#123;</span><br><span class="line">	// <span class="built_in">return</span> testing.Retriver&#123;&#125;//测试</span><br><span class="line">	<span class="built_in">return</span> infra.Retriver&#123;&#125;//真实数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//是infra还是testing的Retriver呢？如何判断呢：通过接口</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> retriver interface &#123;</span><br><span class="line">	Get(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var r retriver = getRetriver()</span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, r.Get(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck typing"></a>duck typing</h2><h2 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h2><p>接口的定义(接口由使用者定义)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"learngo/retriever/mock"</span></span><br><span class="line">	<span class="string">"learngo/retriever/real"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver interface &#123;</span><br><span class="line">	Get(url string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func download(r Retriver) string &#123;</span><br><span class="line">	<span class="built_in">return</span> r.Get(<span class="string">"http://www.imooc.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var r Retriver</span><br><span class="line">	r = mock.Retriver&#123;<span class="string">"this is a fake imooc.com"</span>&#125;</span><br><span class="line">	r = real.Retriver&#123;&#125;</span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的实现（不需要实现Retriver接口，只需要实现接口里的方法）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package real</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Retriver struct &#123;</span><br><span class="line">	UserAgent string</span><br><span class="line">	TimeOut   time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Retriver) Get(url string) string &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> string(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口的值类型"><a href="#接口的值类型" class="headerlink" title="接口的值类型"></a>接口的值类型</h2><p>switch判断类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func inspect(r Retriver) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"类型=%T 值=%v\n"</span>, r, r)</span><br><span class="line">	switch v := r.(<span class="built_in">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> mock.Retriver:</span><br><span class="line">		fmt.Println(<span class="string">"Contents:"</span>, v.Contents)</span><br><span class="line">	<span class="keyword">case</span> *real.Retriver:</span><br><span class="line">		fmt.Println(<span class="string">"UserAgent:"</span>, v.UserAgent)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type assertion</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">type</span> assertion</span><br><span class="line"></span><br><span class="line">	//real</span><br><span class="line">	realRetriver := r.(*real.Retriver)</span><br><span class="line">	fmt.Println(realRetriver.TimeOut)</span><br><span class="line"></span><br><span class="line">	//出错写法</span><br><span class="line">	realRetriver := r.(real.Retriver)</span><br><span class="line">	fmt.Println(realRetriver.TimeOut)</span><br><span class="line"></span><br><span class="line">	//防止出错</span><br><span class="line">	<span class="keyword">if</span> mockRetriver, ok := r.(mock.Retriver); ok &#123;</span><br><span class="line">		fmt.Println(mockRetriver.Contents)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not a mock retriver"</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>表示任何类型:interface{}</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//改为支持任何类型</span><br><span class="line"><span class="built_in">type</span> Queue []interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Push(v interface&#123;&#125;) &#123;</span><br><span class="line">	*q = append(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Pop() interface&#123;&#125; &#123;</span><br><span class="line">	head := (*q)[0]</span><br><span class="line">	*q = (*q)[1:]</span><br><span class="line">	<span class="built_in">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) IsEmpty() bool &#123;</span><br><span class="line">	<span class="built_in">return</span> len(*q) == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Retriver interface &#123;</span><br><span class="line">	Get(url string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Poster interface &#123;</span><br><span class="line">	Post(url string, form map[string]string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const url = <span class="string">"http://www.imooc.com"</span></span><br><span class="line"></span><br><span class="line">func download(r Retriver) string &#123;</span><br><span class="line">	<span class="built_in">return</span> r.Get(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func poster(poster Poster) &#123;</span><br><span class="line">	poster.Post(url,</span><br><span class="line">		map[string]string&#123;</span><br><span class="line">			<span class="string">"name"</span>:     <span class="string">"sam"</span>,</span><br><span class="line">			<span class="string">"language"</span>: <span class="string">"golang"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> RetriverPoster interface &#123;</span><br><span class="line">	Retriver</span><br><span class="line">	Poster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func session(s RetriverPoster) string &#123;</span><br><span class="line">	s.Post(url, map[string]string&#123;</span><br><span class="line">		<span class="string">"contents"</span>: <span class="string">"another facked imooc.com"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">return</span> s.Get(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="常用的系统接口"><a href="#常用的系统接口" class="headerlink" title="常用的系统接口"></a>常用的系统接口</h2><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>参数、变量、返回值都可以是函数<br>高阶函数（函数的参数依旧是个函数）<br>函数闭包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//返回一个函数</span><br><span class="line">func adder() func(int) int &#123;</span><br><span class="line">	sum := 0</span><br><span class="line">	<span class="built_in">return</span> func(v int) int &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		<span class="built_in">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	a := adder()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		fmt.Println((a(i)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>斐波那契数列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">	a, b := 0, 1</span><br><span class="line">	<span class="built_in">return</span> func() int &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">		<span class="built_in">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>为函数实现接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> intGen func() int</span><br><span class="line"></span><br><span class="line">func (g intGen) Read(</span><br><span class="line">	p []byte) (n int, err error) &#123;</span><br><span class="line">	next := g()</span><br><span class="line">	<span class="keyword">if</span> next &gt; 10000 &#123;</span><br><span class="line">		<span class="built_in">return</span> 0, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line">	s := fmt.Sprintf(<span class="string">"%d\n"</span>, next)</span><br><span class="line"></span><br><span class="line">	// TODO: incorrect <span class="keyword">if</span> p is too small!</span><br><span class="line">	<span class="built_in">return</span> strings.NewReader(s).Read(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func printFileContents(reader io.Reader) &#123;</span><br><span class="line">	scanner := bufio.NewScanner(reader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> scanner.<span class="function"><span class="title">Scan</span></span>() &#123;</span><br><span class="line">		fmt.Println(scanner.Text())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var f intGen = fib.Fibonacci()</span><br><span class="line">	printFileContents(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>利用函数遍历二叉树</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>确保调用在函数结束时发生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	defer fmt.Println(2)</span><br><span class="line">	defer fmt.Println(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defer是一个栈，先进后出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	defer fmt.Println(2)</span><br><span class="line">	defer fmt.Println(3)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">		defer fmt.Println(i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i == 30 &#123;</span><br><span class="line">			panic(<span class="string">"printed too many"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeFle(filename string) &#123;</span><br><span class="line">	file, err := os.Create(filename)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	defer writer.Flush()</span><br><span class="line"></span><br><span class="line">	f := fib.Fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		fmt.Fprintln(writer, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	writeFle(<span class="string">"fib.txt"</span>)</span><br><span class="line"></span><br><span class="line">	tryDefer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  defer go run defer.go</span><br><span class="line">30</span><br><span class="line">29</span><br><span class="line">28</span><br><span class="line">27</span><br><span class="line">26</span><br><span class="line">25</span><br><span class="line">24</span><br><span class="line">23</span><br><span class="line">22</span><br><span class="line">21</span><br><span class="line">20</span><br><span class="line">19</span><br><span class="line">18</span><br><span class="line">17</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">14</span><br><span class="line">13</span><br><span class="line">12</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">panic: printed too many</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.tryDefer()</span><br><span class="line">        /Users/samtake/Desktop/learngo/hello/errHandling/defer/defer.go:19 +0x2fc</span><br><span class="line">main.main()</span><br><span class="line">        /Users/samtake/Desktop/learngo/hello/errHandling/defer/defer.go:43 +0x3b</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p>何时调用defer</p>
<ul>
<li><p>Open/Close</p>
</li>
<li><p>Lock/Unlock</p>
</li>
<li><p>PrintHeader/PrintFooter</p>
</li>
</ul>
<p>错误处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryDefer</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">		defer fmt.Println(i)</span><br><span class="line">		<span class="keyword">if</span> i == 30 &#123;</span><br><span class="line">			// Uncomment panic to see</span><br><span class="line">			// how it works with defer</span><br><span class="line">			// panic(<span class="string">"printed too many"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeFle(filename string) &#123;</span><br><span class="line">	file, err := os.OpenFile(filename,</span><br><span class="line">		os.O_EXCL|os.O_CREATE|os.O_WRONLY, 0666)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		<span class="keyword">if</span> pathError, ok := err.(*os.PathError); !ok &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%s, %s, %s\n"</span>,</span><br><span class="line">				pathError.Op,</span><br><span class="line">				pathError.Path,</span><br><span class="line">				pathError.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	defer file.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	defer writer.Flush()</span><br><span class="line"></span><br><span class="line">	f := fib.Fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">		fmt.Fprintln(writer, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器统一出错处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> appHandler func(writer http.ResponseWriter,</span><br><span class="line">	request *http.Request) error</span><br><span class="line"></span><br><span class="line">func errWrapper(</span><br><span class="line">	handler appHandler) func(</span><br><span class="line">	http.ResponseWriter, *http.Request) &#123;</span><br><span class="line">	<span class="built_in">return</span> func(writer http.ResponseWriter,</span><br><span class="line">		request *http.Request) &#123;</span><br><span class="line">		// panic</span><br><span class="line">		defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			<span class="keyword">if</span> r := recover(); r != nil &#123;</span><br><span class="line">				log.Printf(<span class="string">"Panic: %v"</span>, r)</span><br><span class="line">				http.Error(writer,</span><br><span class="line">					http.StatusText(http.StatusInternalServerError),</span><br><span class="line">					http.StatusInternalServerError)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		err := handler(writer, request)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			log.Printf(<span class="string">"Error occurred "</span>+</span><br><span class="line">				<span class="string">"handling request: %s"</span>,</span><br><span class="line">				err.Error())</span><br><span class="line"></span><br><span class="line">			// user error</span><br><span class="line">			<span class="keyword">if</span> userErr, ok := err.(userError); ok &#123;</span><br><span class="line">				http.Error(writer,</span><br><span class="line">					userErr.Message(),</span><br><span class="line">					http.StatusBadRequest)</span><br><span class="line">				<span class="built_in">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// system error</span><br><span class="line">			code := http.StatusOK</span><br><span class="line">			switch &#123;</span><br><span class="line">			<span class="keyword">case</span> os.IsNotExist(err):</span><br><span class="line">				code = http.StatusNotFound</span><br><span class="line">			<span class="keyword">case</span> os.IsPermission(err):</span><br><span class="line">				code = http.StatusForbidden</span><br><span class="line">			default:</span><br><span class="line">				code = http.StatusInternalServerError</span><br><span class="line">			&#125;</span><br><span class="line">			http.Error(writer,</span><br><span class="line">				http.StatusText(code), code)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> userError interface &#123;</span><br><span class="line">	error</span><br><span class="line">	Message() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>,</span><br><span class="line">		errWrapper(filelisting.HandleFileList))</span><br><span class="line"></span><br><span class="line">	err := http.ListenAndServe(<span class="string">":8888"</span>, nil)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><p>panic<br>停止当前函数执行<br>一直向上返回，执行每一层的defer<br>如果没有遇见recover，程序就退出</p>
<p>recover<br>仅在defer调用中使用<br>获取panic的值<br>如果无法处理，可重新panic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">tryRecover</span></span>() &#123;</span><br><span class="line">	defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		r := recover()</span><br><span class="line">		<span class="keyword">if</span> r == nil &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Nothing to recover. "</span> +</span><br><span class="line">				<span class="string">"Please try uncomment errors "</span> +</span><br><span class="line">				<span class="string">"below."</span>)</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Error occurred:"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			panic(fmt.Sprintf(</span><br><span class="line">				<span class="string">"I don't know what to do: %v"</span>, r))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>go test 会自动执行路径包下面的“_test.go”文件（包括文件名包含 “_test.go” 的源文件），我们管称这些是测试文件，里面包含着你的测试函数，测试用例等。更多用法可以输入 “go help test” 查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="代码覆盖率和性能测试"><a href="#代码覆盖率和性能测试" class="headerlink" title="代码覆盖率和性能测试"></a>代码覆盖率和性能测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用pprof进行性能调优</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="测试http服务器"><a href="#测试http服务器" class="headerlink" title="测试http服务器"></a>测试http服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成文档和实力代码</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>轻量级“线程”<br>非抢占式多任务处理，由协程主动交出控制权（Printf是个IO操作，内部做了控制权切换）<br>多个协程可能在一个或多个线程上运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"hello form goroutine %d\n"</span>, i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="function"><span class="title">tryGoroutine</span></span>() &#123;</span><br><span class="line">	var a [10]int</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func(ii int) &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				a[ii]++</span><br><span class="line">				runtime.Gosched()//主动交出控制权</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据访问的冲突</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run -race goroutine.go</span><br></pre></td></tr></table></figure>

<p>查看cpu占用率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p>go语言的调度器</p>
<p>任何函数只需加上go就能送给调度器运行<br>不需要在定义时区分是否是异步函数<br>调度器在合适的点进行切换<br>使用-race来检测数据访问冲突</p>
<p>goroutine 可能的切换点<br>I/O、select<br>channel<br>等待锁<br>函数调用（有时会）<br>runtime.Gosched()<br>以上所列只是参考～真实情况就不一定～</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	// var c chan int //c == nil</span><br><span class="line">	c := make(chan int)</span><br><span class="line"></span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n := &lt;-c</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	c &lt;- 2 //如果main退出了，2是没有输出的</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func worker(c chan int) &#123;</span><br><span class="line">	<span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n := &lt;-c</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	// var c chan int //c == nil</span><br><span class="line">	c := make(chan int)</span><br><span class="line"></span><br><span class="line">	go worker(c)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	c &lt;- 2 //如果main退出了，2是没有输出的</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>channel作为参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func worker(id int, c chan int) &#123;</span><br><span class="line">	<span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var channels [10]chan int</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] = make(chan int)</span><br><span class="line">		go worker(i, channels[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>channel作为返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func creatWorker(id int) chan&lt;- int &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var channels [10]chan&lt;- int</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] = creatWorker(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存channel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">bufferedChannel</span></span>() &#123;</span><br><span class="line">	c := make(chan int, 3) //给个缓存3</span><br><span class="line">	go work(0, c)</span><br><span class="line">	c &lt;- 1</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>关闭通道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">channelClose</span></span>() &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go work(0, c)</span><br><span class="line">	c &lt;- <span class="string">'a'</span></span><br><span class="line">	c &lt;- <span class="string">'b'</span></span><br><span class="line">	c &lt;- <span class="string">'c'</span></span><br><span class="line">	c &lt;- <span class="string">'d'</span></span><br><span class="line">	close(c)</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭之后，依旧能收到（空串，0）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Worker 0 received a</span><br><span class="line">Worker 0 received b</span><br><span class="line">Worker 0 received c</span><br><span class="line">Worker 0 received d</span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 received </span><br><span class="line">Worker 0 r</span><br></pre></td></tr></table></figure>

<p>解决关闭之后不再输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, ok := &lt;-c</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="built_in">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func work(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> n := range c &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用channel等待goroutine结束（重点）"><a href="#使用channel等待goroutine结束（重点）" class="headerlink" title="使用channel等待goroutine结束（重点）"></a>使用channel等待goroutine结束（重点）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func doWork(id int,</span><br><span class="line">	w worker) &#123;</span><br><span class="line">	<span class="keyword">for</span> n := range w.in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>,</span><br><span class="line">			id, n)</span><br><span class="line">		w.done()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> worker struct &#123;</span><br><span class="line">	<span class="keyword">in</span>   chan int</span><br><span class="line">	<span class="keyword">done</span> func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createWorker(</span><br><span class="line">	id int, wg *sync.WaitGroup) worker &#123;</span><br><span class="line">	w := worker&#123;</span><br><span class="line">		<span class="keyword">in</span>: make(chan int),</span><br><span class="line">		<span class="keyword">done</span>: <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	go doWork(id, w)</span><br><span class="line">	<span class="built_in">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">chanDemo</span></span>() &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	var workers [10]worker</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		workers[i] = createWorker(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Add(20)</span><br><span class="line">	<span class="keyword">for</span> i, worker := range workers &#123;</span><br><span class="line">		worker.in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, worker := range workers &#123;</span><br><span class="line">		worker.in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	chanDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Worker 7 received h</span><br><span class="line">Worker 5 received f</span><br><span class="line">Worker 0 received a</span><br><span class="line">Worker 1 received b</span><br><span class="line">Worker 1 received B</span><br><span class="line">Worker 4 received e</span><br><span class="line">Worker 9 received j</span><br><span class="line">Worker 8 received i</span><br><span class="line">Worker 2 received c</span><br><span class="line">Worker 0 received A</span><br><span class="line">Worker 6 received g</span><br><span class="line">Worker 3 received d</span><br><span class="line">Worker 9 received J</span><br><span class="line">Worker 6 received G</span><br><span class="line">Worker 7 received H</span><br><span class="line">Worker 2 received C</span><br><span class="line">Worker 4 received E</span><br><span class="line">Worker 8 received I</span><br><span class="line">Worker 3 received D</span><br><span class="line">Worker 5 received F</span><br></pre></td></tr></table></figure>


<p>使用Channel进行书的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用Select进行调度（重点）"><a href="#使用Select进行调度（重点）" class="headerlink" title="使用Select进行调度（重点）"></a>使用Select进行调度（重点）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func generator() chan int &#123;</span><br><span class="line">	out := make(chan int)</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		i := 0</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(</span><br><span class="line">				time.Duration(rand.Intn(1500)) *</span><br><span class="line">					time.Millisecond)</span><br><span class="line">			out &lt;- i</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func worker(id int, c chan int) &#123;</span><br><span class="line">	<span class="keyword">for</span> n := range c &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %d\n"</span>,</span><br><span class="line">			id, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createWorker(id int) chan&lt;- int &#123;</span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go worker(id, c)</span><br><span class="line">	<span class="built_in">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var c1, c2 = generator(), generator()</span><br><span class="line">	var worker = createWorker(0)</span><br><span class="line"></span><br><span class="line">	var values []int</span><br><span class="line">	tm := time.After(10 * time.Second)</span><br><span class="line">	tick := time.Tick(time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		var activeWorker chan&lt;- int</span><br><span class="line">		var activeValue int</span><br><span class="line">		<span class="keyword">if</span> len(values) &gt; 0 &#123;</span><br><span class="line">			activeWorker = worker</span><br><span class="line">			activeValue = values[0]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		select &#123;</span><br><span class="line">		<span class="keyword">case</span> n := &lt;-c1:</span><br><span class="line">			values = append(values, n)</span><br><span class="line">		<span class="keyword">case</span> n := &lt;-c2:</span><br><span class="line">			values = append(values, n)</span><br><span class="line">		<span class="keyword">case</span> activeWorker &lt;- activeValue:</span><br><span class="line">			values = values[1:]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(800 * time.Millisecond):</span><br><span class="line">			fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-tick:</span><br><span class="line">			fmt.Println(</span><br><span class="line">				<span class="string">"queue len ="</span>, len(values))</span><br><span class="line">		<span class="keyword">case</span> &lt;-tm:</span><br><span class="line">			fmt.Println(<span class="string">"bye"</span>)</span><br><span class="line">			<span class="built_in">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>WaitGroup<br>Mutex<br>Cond</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## 迷宫算法</span></span><br><span class="line">```bash</span><br></pre></td></tr></table></figure>

<h2 id="http标准库"><a href="#http标准库" class="headerlink" title="http标准库"></a>http标准库</h2><p>使用http客户端发送请求<br>使用http.Client控制请求头部等<br>使用httputil简化工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	request, err := http.NewRequest(</span><br><span class="line">		http.MethodGet,</span><br><span class="line">		<span class="string">"http://www.imooc.com"</span>, nil)</span><br><span class="line">	request.Header.Add(<span class="string">"User-Agent"</span>,</span><br><span class="line">		<span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1"</span>)</span><br><span class="line"></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		CheckRedirect: func(</span><br><span class="line">			req *http.Request,</span><br><span class="line">			via []*http.Request) error &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Redirect:"</span>, req)</span><br><span class="line">			<span class="built_in">return</span> nil</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pprof</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...../debug/pprof/</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof [地址]</span><br></pre></td></tr></table></figure>



<h2 id="其它标准库"><a href="#其它标准库" class="headerlink" title="其它标准库"></a>其它标准库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bufio</span><br><span class="line"><span class="built_in">log</span></span><br><span class="line">encoding/json</span><br><span class="line">regexp</span><br><span class="line">time</span><br><span class="line">strings/math/rand</span><br></pre></td></tr></table></figure>

<p>获取文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">godoc -http :8888</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://docscn.studygolang.com/</span><br></pre></td></tr></table></figure>



<h2 id="gin-amp-增加middleware"><a href="#gin-amp-增加middleware" class="headerlink" title="gin&amp;增加middleware"></a>gin&amp;增加middleware</h2><p>拉取gin和日志库zap</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br><span class="line">go get -u go.uber.org/zap</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/ping</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen tcp :8080: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use 问题解决</span><br><span class="line">命令行 lsof -i:8080 这里8080是我要释放的端口号</span><br><span class="line"></span><br><span class="line">可以看到，该端口被id为51217的进程所占用，这个时候直接在命令行输入</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 51217</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	logger, err := zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Use(func(c *gin.Context) &#123;</span><br><span class="line">		logger.Info(<span class="string">"incoming request"</span>, zap.String(<span class="string">"path"</span>, c.Request.URL.Path))</span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/hello"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"hello"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const keyRequestId = <span class="string">"requestId"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	logger, err := zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Use(func(c *gin.Context) &#123;</span><br><span class="line">		s := time.Now()</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		logger.Info(<span class="string">"incoming request"</span>,</span><br><span class="line">			zap.String(<span class="string">"path"</span>, c.Request.URL.Path),</span><br><span class="line">			zap.Int(<span class="string">"status"</span>, c.Writer.Status()),</span><br><span class="line">			zap.Duration(<span class="string">"elapsed"</span>, time.Now().Sub(s)))</span><br><span class="line">	&#125;, func(c *gin.Context) &#123;</span><br><span class="line">		c.Set(keyRequestId, rand.Int())</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		h := gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> rid, exists := c.Get(keyRequestId); exists &#123;</span><br><span class="line">			h[keyRequestId] = rid</span><br><span class="line">		&#125;</span><br><span class="line">		c.JSON(200, h)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">"/hello"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"hello"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`)</span><br><span class="line">	match := re.FindAllString(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[sam@gmail.com 5555@qq.com 5555@163.com]</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`([a-zA-Z0-9]+)@([a-zA-Z0-9]+)\.([a-zA-Z0-9]+)`)</span><br><span class="line">	match := re.FindAllStringSubmatch(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, m := range match &#123;</span><br><span class="line">		fmt.Println(m)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[sam@gmail.com sam gmail com] [5555@qq.com 5555 qq com] [5555@163.com 5555 163 com]]</span><br><span class="line">[sam@gmail.com sam gmail com]</span><br><span class="line">[5555@qq.com 5555 qq com]</span><br><span class="line">[5555@163.com 5555 163 com]</span><br></pre></td></tr></table></figure>

<h2 id="包管理-包引入"><a href="#包管理-包引入" class="headerlink" title="包管理(包引入)"></a>包管理(包引入)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init [crawler-single-task]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  crawler git:(master) ✗ cat go.mod                     </span><br><span class="line">module crawler-single-task</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        golang.org/x/net v0.0.0-20191207000613-e7e4b65ae663</span><br><span class="line">        golang.org/x/text v0.3.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>以项目当前目录为起点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">"crawler-single-task/engine"</span></span><br><span class="line">	<span class="string">"crawler-single-task/zhenai/parser"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="单任务爬虫要点笔记"><a href="#单任务爬虫要点笔记" class="headerlink" title="单任务爬虫要点笔记"></a>单任务爬虫要点笔记</h2><h3 id="转换-UTF-8-与-GBK-编码的文本"><a href="#转换-UTF-8-与-GBK-编码的文本" class="headerlink" title="转换 UTF-8 与 GBK 编码的文本"></a>转换 UTF-8 与 GBK 编码的文本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get golang.org/x/text</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">utf8Reader := transform.NewReader(resp.Body, simplifiedchinese.GBK.NewDecoder())</span><br></pre></td></tr></table></figure>

<h3 id="确定编码库"><a href="#确定编码库" class="headerlink" title="确定编码库"></a>确定编码库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get golang.org/x/net/html</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//确定编码</span><br><span class="line">func determinEncoding(r io.Reader) encoding.Encoding &#123;</span><br><span class="line">	bytes, err := bufio.NewReader(r).Peek(1024)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	e, _, _ := charset.DetermineEncoding(bytes, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//转码</span><br><span class="line">	e := determinEncoding(resp.Body)</span><br><span class="line">	utf8Reader := transform.NewReader(resp.Body, e.NewDecoder())</span><br></pre></td></tr></table></figure>

<h3 id="获取城市名和链接的方式"><a href="#获取城市名和链接的方式" class="headerlink" title="获取城市名和链接的方式"></a>获取城市名和链接的方式</h3><p>使用css选择器<code>$(&#39;#cityList&gt;dd&gt;a&#39;)</code></p>
<p>使用xpath</p>
<p>使用正则表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	re := regexp.MustCompile(`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`)</span><br><span class="line">	match := re.FindAllString(text, -1)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>第三方库httprouter</title>
    <url>/2020/02/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93httprouter/</url>
    <content><![CDATA[<p><a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>是一个高可用的http路由请求库。路由器通过请求方法和路径来匹配传入的请求。如果为该路径和方法注册了句柄，路由器会将请求委托给该函数。对于方法GET、POST、PUT、PATCH、DELETE和OPTIONS，存在注册句柄的快捷功能，对于所有其他方法路由器。可以使用手柄。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/julienschmidt/httprouter"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">"Welcome!\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Hello(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"hello, %s!\n"</span>, ps.ByName(<span class="string">"name"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    router := httprouter.New()</span><br><span class="line">    router.GET(<span class="string">"/"</span>, Index)</span><br><span class="line">    router.GET(<span class="string">"/hello/:name"</span>, Hello)</span><br><span class="line"></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, router))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang流媒体网站笔记</title>
    <url>/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/architecture.png" alt></p>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/api.png" alt></p>
<p>httprouter的使用</p>
<p>restlet测试插件 </p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="3-6"><a href="#3-6" class="headerlink" title="3-6"></a>3-6</h3><p>总体思路：<br>handleer-&gt;validation{1.request,2.user}-&gt;business login -&gt;response</p>
<ol>
<li>data model</li>
<li>error handler</li>
</ol>
<p>这个错误接口以后都可以这样写了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package defs</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Err struct &#123;</span><br><span class="line">	Error string `json:<span class="string">"error"</span>`</span><br><span class="line">	ErrorCode string `json:<span class="string">"error_code"</span>`  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ErrResponse struct &#123;</span><br><span class="line">	HttpSC int</span><br><span class="line">	Error Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	ErrorRequestBodyParseFailed = ErrResponse&#123;HttpSC: 400, Error: Err&#123;Error: <span class="string">"Request body is not correct"</span>, ErrorCode: <span class="string">"001"</span>&#125;&#125;</span><br><span class="line">	ErrorNotAuthUser = ErrResponse&#123;HttpSC: 401, Error: Err&#123;Error: <span class="string">"User authentication failed."</span>, ErrorCode: <span class="string">"002"</span>&#125;&#125;</span><br><span class="line">	ErrorDBError = ErrResponse&#123;HttpSC: 500, Error: Err&#123;Error: <span class="string">"DB ops failed"</span>, ErrorCode: <span class="string">"003"</span>&#125;&#125;</span><br><span class="line">	ErrorInternalFaults = ErrResponse&#123;HttpSC: 500, Error: Err&#123;Error: <span class="string">"Internal service error"</span>, ErrorCode: <span class="string">"004"</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="3-7"><a href="#3-7" class="headerlink" title="3-7"></a>3-7</h3><p>好好理解这里的数据库为什么这样设计</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table comments (</span><br><span class="line">	id varchar(64) not null,</span><br><span class="line">	video_id varchar(64),</span><br><span class="line">	author_id int(10),</span><br><span class="line">	content text,</span><br><span class="line">	time datetime default current_timestamp, primary key(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table sessions (</span><br><span class="line">	session_id tinytext not null,</span><br><span class="line">	TTL tinytext,</span><br><span class="line">	login_name text</span><br><span class="line">);</span><br><span class="line">alter table sessions add primary key (session_id(64));</span><br><span class="line"></span><br><span class="line">create table users (</span><br><span class="line">	id int unsigned not null auto_increment,</span><br><span class="line">	login_name varchar(64),</span><br><span class="line">	<span class="built_in">pwd</span> text not null,</span><br><span class="line">	unique key (login_name),</span><br><span class="line">	primary key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table video_del_rec (</span><br><span class="line">	video_id varchar(64) not null,</span><br><span class="line">	primary key (video_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table video_info (</span><br><span class="line">	id varchar(64) not null,</span><br><span class="line">	author_id int(10),</span><br><span class="line">	name text,</span><br><span class="line">	display_ctime text,</span><br><span class="line">	create_time datetime default current_timestamp,</span><br><span class="line">	primary key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p><code>第三范式(Third Normal Form,3rd NF)</code>就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。</p>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/sql-design.png" alt></p>
<h3 id="3-8"><a href="#3-8" class="headerlink" title="3-8"></a>3-8</h3><p>数据库连接还是参考自己写的这个吧<a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">demo</a>吧。</p>
<h3 id="3-10"><a href="#3-10" class="headerlink" title="3-10"></a>3-10</h3><p>api_test.go</p>
<p>参考<a href="https://samtake.github.io/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Golang练习笔记</a>23测试讲的更详细。</p>
<h3 id="3-12"><a href="#3-12" class="headerlink" title="3-12"></a>3-12</h3><p>实现和验证video<br><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/3-12.png" alt></p>
<h3 id="3-13"><a href="#3-13" class="headerlink" title="3-13"></a>3-13</h3><p>Comments</p>
<p> <img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/3-13-comments.png" alt><br>评论是需要列表出现的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func ListComments(vid string, from, to int) ([]*defs.Comment, error) &#123;</span><br><span class="line">	stmtOut, err := dbConn.Prepare(`SELECT comments.id, users.login_name, comments.content FROM comments </span><br><span class="line">		INNER JOIN users ON comments.author_id = users.id </span><br><span class="line">		WHERE comments.video_id = ? AND comments.time &gt; FROM_UNIXTIME(?) AND comments.time &lt;= FROM_UNIXTIME(?)</span><br><span class="line">		ORDER BY comments.time DESC`)</span><br><span class="line"></span><br><span class="line">	var res []*defs.Comment</span><br><span class="line">	</span><br><span class="line">	rows, err := stmtOut.Query(vid, from, to)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Printf(<span class="string">"%s"</span>, err)</span><br><span class="line">		<span class="built_in">return</span> res, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rows.<span class="function"><span class="title">Next</span></span>() &#123;</span><br><span class="line">		var id, name, content string</span><br><span class="line">		<span class="keyword">if</span> err := rows.Scan(&amp;id, &amp;name, &amp;content); err != nil &#123;</span><br><span class="line">			<span class="built_in">return</span> res, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c := &amp;defs.Comment&#123;Id: id, VideoId: vid, Author: name, Content: content&#125;</span><br><span class="line">		res = append(res, c)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer stmtOut.Close()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> res, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-15"><a href="#3-15" class="headerlink" title="3-15"></a>3-15</h3><p><code>session</code>会话，</p>
<p>session和cookie的区别？</p>
<p>session负责的流程图：<br><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/3-15-session.png" alt></p>
<h3 id="3-17"><a href="#3-17" class="headerlink" title="3-17"></a>3-17</h3><p>middleware</p>
<p>duck typing内容参考<a href="https://samtake.github.io/2020/02/22/Golang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Golang练习笔记</a>15。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> middleWareHandler struct &#123;</span><br><span class="line">	r *httprouter.Router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMiddleWareHandler(r *httprouter.Router) http.Handler &#123;</span><br><span class="line">	m := middleWareHandler&#123;&#125;</span><br><span class="line">	m.r = r</span><br><span class="line">	<span class="built_in">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m middleWareHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	//check session</span><br><span class="line">	validateUserSession(r)</span><br><span class="line"></span><br><span class="line">	m.r.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterHandlers() *httprouter.Router &#123;</span><br><span class="line">	router := httprouter.New()</span><br><span class="line">    router.POST(<span class="string">"/user"</span>, CreateUser)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//response</span><br><span class="line"><span class="built_in">type</span> SignedUp struct &#123;</span><br><span class="line">	Success bool `json:<span class="string">"success"</span>`</span><br><span class="line">	SessionId string `json:<span class="string">"session_id"</span>`</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#添了后缀，在使用时，会返回统一的json格式,如下：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"success"</span>:XXXXX,</span><br><span class="line">    <span class="string">"session_id"</span>:XXXX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4-1"></a>4-1</h3><p>Streaming（视频播放）：</p>
<ul>
<li>静态视频，非RTMP（直播的那些都是RTMP）</li>
<li>独立的服务，可独立部署</li>
<li>统一的api格式</li>
</ul>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4-3"></a>4-3</h3><p><code>流控</code><br><code>token bucket</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#共享通道 instead of shared memory</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ConnLimiter struct &#123;</span><br><span class="line">	concurrentConn int</span><br><span class="line">	bucket chan int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewConnLimiter(cc int) *ConnLimiter &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;ConnLimiter &#123;</span><br><span class="line">		concurrentConn: cc,</span><br><span class="line">		bucket: make(chan int, cc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cl *ConnLimiter) GetConn() bool &#123;</span><br><span class="line">	<span class="keyword">if</span> len(cl.bucket) &gt;= cl.concurrentConn &#123;</span><br><span class="line">		log.Printf(<span class="string">"Reached the rate limitation."</span>)</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cl.bucket &lt;- 1</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cl *ConnLimiter) <span class="function"><span class="title">ReleaseConn</span></span>() &#123;</span><br><span class="line">	c :=&lt;- cl.bucket</span><br><span class="line">	log.Printf(<span class="string">"New connction coming: %d"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5"><a href="#4-5" class="headerlink" title="4-5"></a>4-5</h3><p>在http middleware中嵌入流控</p>
<h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5-1"></a>5-1</h3><p><code>scheduler</code>任务调度器，某些不能马上处理的任务放到scheduler，让它定期或者延时触发。</p>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/5-1-scheduler.png" alt></p>
<h3 id="5-3"><a href="#5-3" class="headerlink" title="5-3"></a>5-3</h3><p>runner的生产消费者模型实现</p>
<h3 id="5-5"><a href="#5-5" class="headerlink" title="5-5"></a>5-5</h3><p>task</p>
<p>api-&gt;videoid-&gt;mysql<br>dispatcher-&gt;mysql-&gt;videoid-&gt;datachannel<br>executor-&gt;datachannel-&gt;videoid-&gt;delete video</p>
<h3 id="5-6"><a href="#5-6" class="headerlink" title="5-6"></a>5-6</h3><p>timer</p>
<p>setup-&gt;strat{runner task}</p>
<h3 id="5-7"><a href="#5-7" class="headerlink" title="5-7"></a>5-7</h3><p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/5-7-api.png" alt></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6-1"></a>6-1</h3><p>Go的模版引擎</p>
<ul>
<li>模版引擎是将html解析和元素预置替换生成最终页面的工具</li>
<li>Go的模版有两种text/template和html/template </li>
<li>Go的模版采用动态生成的模式</li>
</ul>
<p><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/6-1-html-template.png" alt></p>
<h3 id="6-2"><a href="#6-2" class="headerlink" title="6-2"></a>6-2</h3><p>前端代码架构<br><img src="/2020/02/21/Golang%E6%B5%81%E5%AA%92%E4%BD%93%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/6-2-web-document.png" alt></p>
<p>client.go就是起了proxy转发作用，避免跨域作用。</p>
<h3 id="6-3"><a href="#6-3" class="headerlink" title="6-3"></a>6-3</h3><p>静态页面渲染</p>
<h3 id="6-4"><a href="#6-4" class="headerlink" title="6-4"></a>6-4</h3><p>sh build.sh</p>
<h3 id="6-6-api透传！！！"><a href="#6-6-api透传！！！" class="headerlink" title="6-6 api透传！！！"></a>6-6 api透传！！！</h3><h3 id="6-7-proxy转发"><a href="#6-7-proxy转发" class="headerlink" title="6-7 proxy转发"></a>6-7 proxy转发</h3><p><code>net/url</code>  </p>
<p><code>net/http/httputil</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func proxyVideoHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">	u, _ := url.Parse(<span class="string">"http://"</span> + config.GetLbAddr() + <span class="string">":9000/"</span>)</span><br><span class="line">	proxy := httputil.NewSingleHostReverseProxy(u)</span><br><span class="line">	proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func proxyUploadHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">	u, _ := url.Parse(<span class="string">"http://"</span> + config.GetLbAddr() + <span class="string">":9000/"</span>)</span><br><span class="line">	proxy := httputil.NewSingleHostReverseProxy(u)</span><br><span class="line">	proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-11"><a href="#6-11" class="headerlink" title="6-11"></a>6-11</h3><p>js</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="7-4"><a href="#7-4" class="headerlink" title="7-4"></a>7-4</h3><p>公共配置，即各模块的config文件。</p>
<h3 id="7-5-vendor"><a href="#7-5-vendor" class="headerlink" title="7-5  vendor"></a>7-5  vendor</h3><h3 id="7-6-SLB讲解与配置"><a href="#7-6-SLB讲解与配置" class="headerlink" title="7-6 SLB讲解与配置"></a>7-6 SLB讲解与配置</h3><p>阿里云负载均衡配置。</p>
<h3 id="7-7"><a href="#7-7" class="headerlink" title="7-7"></a>7-7</h3><p>session容错</p>
<h3 id="7-8-ECS配置"><a href="#7-8-ECS配置" class="headerlink" title="7-8 ECS配置"></a>7-8 ECS配置</h3><h3 id="7-10-部署脚本"><a href="#7-10-部署脚本" class="headerlink" title="7-10 部署脚本"></a>7-10 部署脚本</h3><p>在bin文件夹添加conf.json文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"lb_addr"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">	<span class="string">"oss_addr"</span>: <span class="string">"oss.aliyun.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>buildprod.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build web and other services</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/api</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/api</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/scheduler</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/scheduler</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/streamserver</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/streamserver</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/work/src/github.com/avenssi/video_server/web</span><br><span class="line">env GOOS=linux GOARCH=amd64 go build -o ../bin/web</span><br></pre></td></tr></table></figure>


<p><code>deploy.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">cp -R ./templates ./bin/</span><br><span class="line"></span><br><span class="line">mkdir ./bin/videos</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"></span><br><span class="line">nohup ./api &amp;</span><br><span class="line">nohup ./scheduler &amp;</span><br><span class="line">nohup ./streamserver &amp;</span><br><span class="line">nohup ./web &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deploy finished"</span></span><br></pre></td></tr></table></figure>


<h3 id="7-11-部署"><a href="#7-11-部署" class="headerlink" title="7-11 部署"></a>7-11 部署</h3><p>sh  buildprod.sh 编译完成后提交二进制文件。或者提交代码到服务器上直接编译</p>
<p>检查对应server是否启动<code>ps aux | grep &lt;api?stream?scheduler?web&gt;</code></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Traefik</title>
    <url>/2020/02/19/Traefik/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>相对nginx，基于容器的微服务反向代理利器<a href="https://github.com/containous/traefik" target="_blank" rel="noopener">Traefik</a>支持动态的配置反向代理.</p>
<p><img src="/2020/02/19/Traefik/traefik-architecture.png" alt></p>
<p>如上图左侧公网域名可以通过Traefik监听API动态地转发到右侧的内网服务实例（例如backoffice1服务）。或者说是动态的路由转发。</p>
<p><code>frontend</code>用于控制访问的路由规则，支持单个规则及正则匹配。<br><code>backend</code>用于匹配一组服务实例，通过轮询方式来选择转发的目标。</p>
<h3 id="基于Docker-compose与Traefik1-x的容器化部署"><a href="#基于Docker-compose与Traefik1-x的容器化部署" class="headerlink" title="基于Docker-compose与Traefik1.x的容器化部署"></a>基于Docker-compose与Traefik1.x的容器化部署</h3><p>具体参考service_dc和traefik_dc<br><img src="/2020/02/19/Traefik/Traefik-setting.png" alt></p>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p>|<br>暂<br>|<br>无<br>|</p>
]]></content>
      <categories>
        <category>Traefik</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Traefik</tag>
      </tags>
  </entry>
  <entry>
    <title>go-micro</title>
    <url>/2020/02/19/go-micro/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>项目地址：<a href="https://github.com/micro/go-micro" target="_blank" rel="noopener">go-micro</a></p>
<p>go-micro提供的接口功能</p>
<p><code>服务发现</code>支持服务注册与发现，底层支持etcd、consul、k8s<br><code>负载均衡</code>rpc服务间的请求调度均衡策略<br><code>同步通信</code>基于RPC通信，支持单向、双向流通道模式<br><code>一步通信</code>提供pub、sub通信模型的接口<br><code>高级接口</code>比如服务发现，提供调用的接口是一致的</p>
<p><img src="/2020/02/19/go-micro/go-micro.png" alt></p>
<p><code>broker</code>异步通信<br><code>codec</code>消息编码，可以动态编码<br><code>registry</code>服务注册与发现<br><code>selector</code>负载均衡<br><code>transport</code> 基于RPC的通信模块接口</p>
<h3 id="账号系统微服务"><a href="#账号系统微服务" class="headerlink" title="账号系统微服务"></a>账号系统微服务</h3><p>新建一个文件<code>XXX.proto</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">package go.micro.service.user;</span><br><span class="line"></span><br><span class="line">service UserService &#123;</span><br><span class="line">    // 用户注册</span><br><span class="line">    rpc Signup(ReqSignup) returns (RespSignup) &#123;&#125;</span><br><span class="line">    // 用户登录</span><br><span class="line">    rpc Signin(ReqSignin) returns (RespSignin) &#123;&#125;</span><br><span class="line">    // 获取用户信息</span><br><span class="line">    rpc UserInfo(ReqUserInfo) returns (RespUserInfo) &#123;&#125;</span><br><span class="line">    // 获取用户文件</span><br><span class="line">    rpc UserFiles(ReqUserFile) returns (RespUserFile) &#123;&#125;</span><br><span class="line">   // 获取用户文件</span><br><span class="line">    rpc UserFileRename(ReqUserFileRename) returns (RespUserFileRename) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqSignup &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    string password = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespSignup &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string message = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqSignin &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    string password = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespSignin &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string token = 2;</span><br><span class="line">    string message = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqUserInfo &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespUserInfo &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string message =2;</span><br><span class="line">    string username =3;</span><br><span class="line">    string email = 4;</span><br><span class="line">    string phone = 5;</span><br><span class="line">    string signupAt = 6;</span><br><span class="line">    string lastActiveAt = 7;</span><br><span class="line">    int32 status = 8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqUserFile &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    int32 <span class="built_in">limit</span> = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespUserFile &#123;</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    string message =2;</span><br><span class="line">    bytes fileData = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ReqUserFileRename &#123;</span><br><span class="line">  string username = 1;</span><br><span class="line">  string filehash = 2;</span><br><span class="line">  string newFileName = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RespUserFileRename &#123;</span><br><span class="line">  int32 code = 1;</span><br><span class="line">  string message =2;</span><br><span class="line">  bytes fileData = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protoc --proto_path=service/account/proto --go_out=service/account/proto --micro_out=service/account/proto service/account/proto/user.proto</span><br></pre></td></tr></table></figure>

<p>这时候会生成两个文件<br><code>XXX.micro.go</code>以及<code>XXX.pb.go</code></p>
<p>handler调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package handler</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"filestore-server/common"</span></span><br><span class="line">	<span class="string">"filestore-server/config"</span></span><br><span class="line">	cfg <span class="string">"filestore-server/config"</span></span><br><span class="line">	proto <span class="string">"filestore-server/service/account/proto"</span></span><br><span class="line">	dbcli <span class="string">"filestore-server/service/dbproxy/client"</span></span><br><span class="line">	<span class="string">"filestore-server/util"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// User : 用于实现UserServiceHandler接口的对象</span><br><span class="line"><span class="built_in">type</span> User struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// GenToken : 生成token</span><br><span class="line">func GenToken(username string) string &#123;</span><br><span class="line">	// 40位字符:md5(username+timestamp+token_salt)+timestamp[:8]</span><br><span class="line">	ts := fmt.Sprintf(<span class="string">"%x"</span>, time.Now().Unix())</span><br><span class="line">	tokenPrefix := util.MD5([]byte(username + ts + <span class="string">"_tokensalt"</span>))</span><br><span class="line">	<span class="built_in">return</span> tokenPrefix + ts[:8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Signup : 处理用户注册请求</span><br><span class="line">func (u *User) Signup(ctx context.Context, req *proto.ReqSignup, res *proto.RespSignup) error &#123;</span><br><span class="line">	username := req.Username</span><br><span class="line">	passwd := req.Password</span><br><span class="line"></span><br><span class="line">	// 参数简单校验</span><br><span class="line">	<span class="keyword">if</span> len(username) &lt; 3 || len(passwd) &lt; 5 &#123;</span><br><span class="line">		res.Code = common.StatusParamInvalid</span><br><span class="line">		res.Message = <span class="string">"注册参数无效"</span></span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 对密码进行加盐及取Sha1值加密</span><br><span class="line">	encPasswd := util.Sha1([]byte(passwd + cfg.PasswordSalt))</span><br><span class="line">	// 将用户信息注册到用户表中</span><br><span class="line">	dbResp, err := dbcli.UserSignup(username, encPasswd)</span><br><span class="line">	<span class="keyword">if</span> err == nil &amp;&amp; dbResp.Suc &#123;</span><br><span class="line">		res.Code = common.StatusOK</span><br><span class="line">		res.Message = <span class="string">"注册成功"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		res.Code = common.StatusRegisterFailed</span><br><span class="line">		res.Message = <span class="string">"注册失败"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Signin : 处理用户登录请求</span><br><span class="line">func (u *User) Signin(ctx context.Context, req *proto.ReqSignin, res *proto.RespSignin) error &#123;</span><br><span class="line">	username := req.Username</span><br><span class="line">	password := req.Password</span><br><span class="line"></span><br><span class="line">	encPasswd := util.Sha1([]byte(password + config.PasswordSalt))</span><br><span class="line"></span><br><span class="line">	// 1. 校验用户名及密码</span><br><span class="line">	dbResp, err := dbcli.UserSignin(username, encPasswd)</span><br><span class="line">	<span class="keyword">if</span> err != nil || !dbResp.Suc &#123;</span><br><span class="line">		res.Code = common.StatusLoginFailed</span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 2. 生成访问凭证(token)</span><br><span class="line">	token := GenToken(username)</span><br><span class="line">	upRes, err := dbcli.UpdateToken(username, token)</span><br><span class="line">	<span class="keyword">if</span> err != nil || !upRes.Suc &#123;</span><br><span class="line">		res.Code = common.StatusServerError</span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 3. 登录成功, 返回token</span><br><span class="line">	res.Code = common.StatusOK</span><br><span class="line">	res.Token = token</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserInfo ： 查询用户信息</span><br><span class="line">func (u *User) UserInfo(ctx context.Context, req *proto.ReqUserInfo, res *proto.RespUserInfo) error &#123;</span><br><span class="line">	// 查询用户信息</span><br><span class="line">	dbResp, err := dbcli.GetUserInfo(req.Username)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		res.Code = common.StatusServerError</span><br><span class="line">		res.Message = <span class="string">"服务错误"</span></span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line">	// 查不到对应的用户信息</span><br><span class="line">	<span class="keyword">if</span> !dbResp.Suc &#123;</span><br><span class="line">		res.Code = common.StatusUserNotExists</span><br><span class="line">		res.Message = <span class="string">"用户不存在"</span></span><br><span class="line">		<span class="built_in">return</span> nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	user := dbcli.ToTableUser(dbResp.Data)</span><br><span class="line"></span><br><span class="line">	// 3. 组装并且响应用户数据</span><br><span class="line">	res.Code = common.StatusOK</span><br><span class="line">	res.Username = user.Username</span><br><span class="line">	res.SignupAt = user.SignupAt</span><br><span class="line">	res.LastActiveAt = user.LastActiveAt</span><br><span class="line">	res.Status = int32(user.Status)</span><br><span class="line">	// TODO: 需增加接口支持完善用户信息(email/phone等)</span><br><span class="line">	res.Email = user.Email</span><br><span class="line">	res.Phone = user.Phone</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个main.go作为单独的微服务启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/micro/go-micro"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"filestore-server/service/account/handler"</span></span><br><span class="line">	proto <span class="string">"filestore-server/service/account/proto"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    //创建一个service</span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		// service := k8s.NewService(</span><br><span class="line">		micro.Name(<span class="string">"go.micro.service.user"</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	// 初始化service, 解析命令行参数等</span><br><span class="line">	service.Init()</span><br><span class="line"></span><br><span class="line">	// 初始化dbproxy client</span><br><span class="line">	dbproxy.Init(service)</span><br><span class="line"></span><br><span class="line">	proto.RegisterUserServiceHandler(service.Server(), new(handler.User))</span><br><span class="line">	<span class="keyword">if</span> err := service.Run(); err != nil &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>go run service/account/main.go --registry=consul</code>指定注册中心为consul</p>
<p>打开浏览器，访问consul的web界面:<br><a href="localhost:8500/ui/dcl/services" target="_blank" rel="noopener">localhost:8500/ui/dcl/services</a></p>
<h3 id="网关微服务"><a href="#网关微服务" class="headerlink" title="网关微服务"></a>网关微服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package handler</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"filestore-server/common"</span></span><br><span class="line">	<span class="string">"filestore-server/util"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	micro <span class="string">"github.com/micro/go-micro"</span></span><br><span class="line"></span><br><span class="line">	cmn <span class="string">"filestore-server/common"</span></span><br><span class="line">	userProto <span class="string">"filestore-server/service/account/proto"</span></span><br><span class="line">	dlProto <span class="string">"filestore-server/service/download/proto"</span></span><br><span class="line">	upProto <span class="string">"filestore-server/service/upload/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	userCli userProto.UserService</span><br><span class="line">	upCli   upProto.UploadService</span><br><span class="line">	dlCli   dlProto.DownloadService</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	service := micro.NewService()</span><br><span class="line">	// 初始化， 解析命令行参数等</span><br><span class="line">	service.Init()</span><br><span class="line"></span><br><span class="line">	// 初始化一个account服务的客户端</span><br><span class="line">	userCli = userProto.NewUserService(<span class="string">"go.micro.service.user"</span>, service.Client())</span><br><span class="line">	// 初始化一个upload服务的客户端</span><br><span class="line">	upCli = upProto.NewUploadService(<span class="string">"go.micro.service.upload"</span>, service.Client())</span><br><span class="line">	// 初始化一个download服务的客户端</span><br><span class="line">	dlCli = dlProto.NewDownloadService(<span class="string">"go.micro.service.download"</span>, service.Client())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SignupHandler : 响应注册页面</span><br><span class="line">func SignupHandler(c *gin.Context) &#123;</span><br><span class="line">	c.Redirect(http.StatusFound, <span class="string">"/static/view/signup.html"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DoSignupHandler : 处理注册post请求</span><br><span class="line">func DoSignupHandler(c *gin.Context) &#123;</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line">	passwd := c.Request.FormValue(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">	resp, err := userCli.Signup(context.TODO(), &amp;userProto.ReqSignup&#123;</span><br><span class="line">		Username: username,</span><br><span class="line">		Password: passwd,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		c.Status(http.StatusInternalServerError)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">"code"</span>: resp.Code,</span><br><span class="line">		<span class="string">"msg"</span>:  resp.Message,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SigninHandler : 响应登录页面</span><br><span class="line">func SigninHandler(c *gin.Context) &#123;</span><br><span class="line">	c.Redirect(http.StatusFound, <span class="string">"/static/view/signin.html"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DoSigninHandler : 处理登录post请求</span><br><span class="line">func DoSigninHandler(c *gin.Context) &#123;</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line">	password := c.Request.FormValue(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">	rpcResp, err := userCli.Signin(context.TODO(), &amp;userProto.ReqSignin&#123;</span><br><span class="line">		Username: username,</span><br><span class="line">		Password: password,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		c.Status(http.StatusInternalServerError)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rpcResp.Code != cmn.StatusOK &#123;</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"msg"</span>:  <span class="string">"登录失败"</span>,</span><br><span class="line">			<span class="string">"code"</span>: rpcResp.Code,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 动态获取上传入口地址</span><br><span class="line">	upEntryResp, err := upCli.UploadEntry(context.TODO(), &amp;upProto.ReqEntry&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> upEntryResp.Code != cmn.StatusOK &#123;</span><br><span class="line">		log.Println(upEntryResp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 动态获取下载入口地址</span><br><span class="line">	dlEntryResp, err := dlCli.DownloadEntry(context.TODO(), &amp;dlProto.ReqEntry&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> dlEntryResp.Code != cmn.StatusOK &#123;</span><br><span class="line">		log.Println(dlEntryResp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 登录成功，返回用户信息</span><br><span class="line">	cliResp := util.RespMsg&#123;</span><br><span class="line">		Code: int(common.StatusOK),</span><br><span class="line">		Msg:  <span class="string">"登录成功"</span>,</span><br><span class="line">		Data: struct &#123;</span><br><span class="line">			Location      string</span><br><span class="line">			Username      string</span><br><span class="line">			Token         string</span><br><span class="line">			UploadEntry   string</span><br><span class="line">			DownloadEntry string</span><br><span class="line">		&#125;&#123;</span><br><span class="line">			Location:      <span class="string">"/static/view/home.html"</span>,</span><br><span class="line">			Username:      username,</span><br><span class="line">			Token:         rpcResp.Token,</span><br><span class="line">			UploadEntry:   upEntryResp.Entry,</span><br><span class="line">			DownloadEntry: dlEntryResp.Entry,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	c.Data(http.StatusOK, <span class="string">"application/json"</span>, cliResp.JSONBytes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserInfoHandler ： 查询用户信息</span><br><span class="line">func UserInfoHandler(c *gin.Context) &#123;</span><br><span class="line">	// 1. 解析请求参数</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line"></span><br><span class="line">	resp, err := userCli.UserInfo(context.TODO(), &amp;userProto.ReqUserInfo&#123;</span><br><span class="line">		Username: username,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		c.Status(http.StatusInternalServerError)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 3. 组装并且响应用户数据</span><br><span class="line">	cliResp := util.RespMsg&#123;</span><br><span class="line">		Code: 0,</span><br><span class="line">		Msg:  <span class="string">"OK"</span>,</span><br><span class="line">		Data: gin.H&#123;</span><br><span class="line">			<span class="string">"Username"</span>: username,</span><br><span class="line">			<span class="string">"SignupAt"</span>: resp.SignupAt,</span><br><span class="line">			// TODO: 完善其他字段信息</span><br><span class="line">			<span class="string">"LastActive"</span>: resp.LastActiveAt,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	c.Data(http.StatusOK, <span class="string">"application/json"</span>, cliResp.JSONBytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package route</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"filestore-server/service/apigw/handler"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Router : 网关api路由</span><br><span class="line">func Router() *gin.Engine &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.Static(<span class="string">"/static/"</span>, <span class="string">"./static"</span>)</span><br><span class="line"></span><br><span class="line">	// 注册</span><br><span class="line">	router.GET(<span class="string">"/user/signup"</span>, handler.SignupHandler)</span><br><span class="line">	router.POST(<span class="string">"/user/signup"</span>, handler.DoSignupHandler)</span><br><span class="line">	// 登录</span><br><span class="line">	router.GET(<span class="string">"/user/signin"</span>, handler.SigninHandler)</span><br><span class="line">	router.POST(<span class="string">"/user/signin"</span>, handler.DoSigninHandler)</span><br><span class="line">	// 用户查询</span><br><span class="line">	router.POST(<span class="string">"/user/info"</span>, handler.UserInfoHandler)</span><br><span class="line"></span><br><span class="line">	// 用户文件查询</span><br><span class="line">	router.POST(<span class="string">"/file/query"</span>, handler.FileQueryHandler)</span><br><span class="line">	// 用户文件修改(重命名)</span><br><span class="line">	router.POST(<span class="string">"/file/update"</span>, handler.FileMetaUpdateHandler)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.go</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"filestore-server/service/apigw/route"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := route.Router()</span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行<code>go run service/apigw/main.go --registry=consul</code>指定注册中心为consul</p>
<h3 id="文件上传微服务"><a href="#文件上传微服务" class="headerlink" title="文件上传微服务"></a>文件上传微服务</h3><p>文件上传需要用到RPC微服务间通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package rpc</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	cfg <span class="string">"filestore-server/service/upload/config"</span></span><br><span class="line">	upProto <span class="string">"filestore-server/service/upload/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Upload : upload结构体</span><br><span class="line"><span class="built_in">type</span> Upload struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// UploadEntry : 获取上传入口</span><br><span class="line">func (u *Upload) UploadEntry(</span><br><span class="line">	ctx context.Context,</span><br><span class="line">	req *upProto.ReqEntry,</span><br><span class="line">	res *upProto.RespEntry) error &#123;</span><br><span class="line"></span><br><span class="line">	res.Entry = cfg.UploadEntry</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	micro <span class="string">"github.com/micro/go-micro"</span></span><br><span class="line"></span><br><span class="line">	cfg <span class="string">"filestore-server/service/upload/config"</span></span><br><span class="line">	upProto <span class="string">"filestore-server/service/upload/proto"</span></span><br><span class="line">	<span class="string">"filestore-server/service/upload/route"</span></span><br><span class="line">	upRpc <span class="string">"filestore-server/service/upload/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">startRpcService</span></span>() &#123;</span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">"go.micro.service.upload"</span>), // 服务名称</span><br><span class="line">		micro.RegisterTTL(time.Second*10),     // TTL指定从上一次心跳间隔起，超过这个时间服务会被服务发现移除</span><br><span class="line">		micro.RegisterInterval(time.Second*5), // 让服务在指定时间内重新注册，保持TTL获取的注册时间有效</span><br><span class="line">	)</span><br><span class="line">	service.Init()</span><br><span class="line"></span><br><span class="line">	upProto.RegisterUploadServiceHandler(service.Server(), new(upRpc.Upload))</span><br><span class="line">	<span class="keyword">if</span> err := service.Run(); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">startApiService</span></span>() &#123;</span><br><span class="line">	router := route.Router()</span><br><span class="line">	router.Run(cfg.UploadServiceHost)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	// api 服务</span><br><span class="line">	go startApiService()</span><br><span class="line"></span><br><span class="line">	// rpc 服务</span><br><span class="line">	startRpcService()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="通过shell脚本启动整个项目的微服务-service-start-all-sh-根据实际情况修改所需要的文件目录"><a href="#通过shell脚本启动整个项目的微服务-service-start-all-sh-根据实际情况修改所需要的文件目录" class="headerlink" title="通过shell脚本启动整个项目的微服务./service/start-all.sh(根据实际情况修改所需要的文件目录)"></a>通过shell脚本启动整个项目的微服务<code>./service/start-all.sh</code>(根据实际情况修改所需要的文件目录)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查service进程</span></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    sleep 1</span><br><span class="line">    res=`ps aux | grep -v grep | grep <span class="string">"service/bin"</span> | grep <span class="variable">$1</span>`</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$res</span> != <span class="string">''</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"\033[32m 已启动 \033[0m"</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"\033[31m 启动失败 \033[0m"</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译service可执行文件</span></span><br><span class="line"><span class="function"><span class="title">build_service</span></span>() &#123;</span><br><span class="line">    go build -o service/bin/<span class="variable">$1</span> service/<span class="variable">$1</span>/main.go</span><br><span class="line">    resbin=`ls service/bin/ | grep <span class="variable">$1</span>`</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\033[32m 编译完成: \033[0m service/bin/<span class="variable">$resbin</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动service</span></span><br><span class="line"><span class="function"><span class="title">run_service</span></span>() &#123;</span><br><span class="line">    nohup ./service/bin/<span class="variable">$1</span> --registry=consul &gt;&gt; <span class="variable">$logpath</span>/<span class="variable">$1</span>.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line">    sleep 1</span><br><span class="line">    check_process <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建运行日志目录</span></span><br><span class="line">logpath=/Users/samtake/Documents/GitHub/www/data/<span class="built_in">log</span>/filestore-server <span class="comment">#/data/log/filestore-server</span></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$logpath</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到工程根目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/filestore-server</span><br><span class="line"><span class="comment">#cd /data/go/work/src/filestore-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微服务可以用supervisor做进程管理工具；</span></span><br><span class="line"><span class="comment"># 或者也可以通过docker/k8s进行部署</span></span><br><span class="line"></span><br><span class="line">services=<span class="string">"</span></span><br><span class="line"><span class="string">dbproxy</span></span><br><span class="line"><span class="string">upload</span></span><br><span class="line"><span class="string">download</span></span><br><span class="line"><span class="string">transfer</span></span><br><span class="line"><span class="string">account</span></span><br><span class="line"><span class="string">apigw</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行编译service</span></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> <span class="variable">$services</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    build_service <span class="variable">$service</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行启动service</span></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> <span class="variable">$services</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    run_service <span class="variable">$service</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'微服务启动完毕.'</span></span><br></pre></td></tr></table></figure>



<h3 id="go-micro学习资料"><a href="#go-micro学习资料" class="headerlink" title="go-micro学习资料"></a><code>go-micro</code>学习资料</h3><p>Go-Micro 基础篇 【1】Hello World:<a href="https://www.bilibili.com/video/av75269275?from=search&seid=13701687009895043479" target="_blank" rel="noopener">视频</a> &amp; <a href="https://github.com/micro-in-cn/learning-videos/blob/master/docs/hello-world/doc.md" target="_blank" rel="noopener">文档</a></p>
<p>#72 Go-Micro 编写微服务实战: <a href="https://www.bilibili.com/video/av79892065?from=search&seid=13701687009895043479" target="_blank" rel="noopener">视频地址</a></p>
<p><a href="https://github.com/micro-in-cn" target="_blank" rel="noopener">Micro 中国站</a></p>
]]></content>
      <categories>
        <category>微服务</category>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云OSS</title>
    <url>/2020/02/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    <content><![CDATA[<p><a href="https://help.aliyun.com/document_detail/31947.html?spm=a2c4g.11174283.6.1505.42967da2nUG4r7" target="_blank" rel="noopener">对象存储OSS</a></p>
<p><a href="https://help.aliyun.com/document_detail/87712.html?spm=a2c4g.11186623.6.890.7b7f3bdb5LHLCm" target="_blank" rel="noopener">SDK go 版本</a></p>
]]></content>
      <categories>
        <category>OSS</category>
      </categories>
      <tags>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang操作MySQL</title>
    <url>/2020/02/16/Golang%E6%93%8D%E4%BD%9CMySQL/</url>
    <content><![CDATA[<p>记录一个报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  goRedisDemo git:(master) ✗ go run main.go</span><br><span class="line"><span class="built_in">test</span> mySQL </span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x20 pc=0x10c1141]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">sync.(*Mutex).Lock(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/sync/mutex.go:74</span><br><span class="line">database/sql.(*DB).conn(0x0, 0x130f9e0, 0xc000018080, 0x1036801, 0xc000000180, 0x300000002, 0xc000000180)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1132 +0x41</span><br><span class="line">database/sql.(*DB).prepare(0x0, 0x130f9e0, 0xc000018080, 0x12c9f84, 0x69, 0x102da01, 0x203000, 0xc0000b3d78, 0xc0000b3d68)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1431 +0x58</span><br><span class="line">database/sql.(*DB).PrepareContext(0x0, 0x130f9e0, 0xc000018080, 0x12c9f84, 0x69, 0x30, 0x30, 0x128eaa0)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1404 +0x99</span><br><span class="line">database/sql.(*DB).Prepare(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1421</span><br><span class="line">goRedisDemo/db.OnFileUploadFinished(0x12bbb58, 0x8, 0x12bbb60, 0x8, 0x0, 0x0, 0x0, 0x0)</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/db/file.go:15 +0x77</span><br><span class="line">goRedisDemo/handler.UploadHandlerDB()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/handler/testDB.go:10 +0x76</span><br><span class="line">main.main()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/main.go:14 +0x7a</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br><span class="line">➜  goRedisDemo git:(master) ✗ go get database/sql</span><br><span class="line">➜  goRedisDemo git:(master) ✗ go get github.com/go-sql-driver/mysql</span><br><span class="line">➜  goRedisDemo git:(master) ✗ go run main.go                       </span><br><span class="line"><span class="built_in">test</span> mySQL </span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x20 pc=0x10c1141]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">sync.(*Mutex).Lock(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/sync/mutex.go:74</span><br><span class="line">database/sql.(*DB).conn(0x0, 0x130f9e0, 0xc0000b0008, 0x1036801, 0xc000000180, 0x300000002, 0xc000000180)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1132 +0x41</span><br><span class="line">database/sql.(*DB).prepare(0x0, 0x130f9e0, 0xc0000b0008, 0x12c9f84, 0x69, 0x102da01, 0x203000, 0xc0000dfd78, 0xc0000dfd68)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1431 +0x58</span><br><span class="line">database/sql.(*DB).PrepareContext(0x0, 0x130f9e0, 0xc0000b0008, 0x12c9f84, 0x69, 0x30, 0x30, 0x128eaa0)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1404 +0x99</span><br><span class="line">database/sql.(*DB).Prepare(...)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/database/sql/sql.go:1421</span><br><span class="line">goRedisDemo/db.OnFileUploadFinished(0x12bbb58, 0x8, 0x12bbb60, 0x8, 0x0, 0x0, 0x0, 0x0)</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/db/file.go:22 +0x77</span><br><span class="line">goRedisDemo/handler.UploadHandlerDB()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/handler/testDB.go:10 +0x76</span><br><span class="line">main.main()</span><br><span class="line">        /Users/samtake/Documents/GitHub/goRedisDemo/main.go:14 +0x7a</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.51cto.com/zhixinhu/1844734" target="_blank" rel="noopener">查了一下，原来这是Db变量定义的问题，:=只在当前方法内有效。</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile</title>
    <url>/2020/02/15/Dockerfile/</url>
    <content><![CDATA[<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h3 id="主要指令"><a href="#主要指令" class="headerlink" title="主要指令"></a>主要指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>定制的镜像都是基于 FROM 的镜像，例如nginx</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定下面的shell语句指定运行在哪个路径下</td>
</tr>
<tr>
<td>COPY</td>
<td>将宿主机下的目录文件复制到镜像中去</td>
</tr>
<tr>
<td>RUN</td>
<td>执行后面跟着的命令行命令</td>
</tr>
<tr>
<td>CMD</td>
<td>指定整个镜像运行起来后执行的脚本 (一般都是阻塞式的脚本)</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY src/  /app</span><br><span class="line">RUN <span class="built_in">echo</span> 321 &gt;&gt; 1.txt</span><br><span class="line">CMD tail -f 1.txt</span><br></pre></td></tr></table></figure>

<h3 id="COPY-vs-ADD"><a href="#COPY-vs-ADD" class="headerlink" title="COPY vs ADD"></a>COPY vs ADD</h3><p>两者功能差不多，但是ADD的源文件除了是本地文件资源，还可以是一个url</p>
<h3 id="CMD-vs-ENTRYPOINT"><a href="#CMD-vs-ENTRYPOINT" class="headerlink" title="CMD vs ENTRYPOINT"></a>CMD vs ENTRYPOINT</h3><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>
<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
<p>在 Dockerfile 文件的存放目录下，通过<code>docker build -t &lt;镜像名&gt;:&lt;版本号&gt;</code>命令来执行。</p>
<h4 id="当两者混用时"><a href="#当两者混用时" class="headerlink" title="当两者混用时"></a>当两者混用时</h4><ul>
<li>entrypoint非json，则以entrypoint为准。</li>
<li>如果entrypoint和cmd都是json，则以entrypoint+cmd拼接成的shell为准。</li>
</ul>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>expose仅仅只是声明端口。</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>标识（没实际作用）</p>
<h3 id="onbuild"><a href="#onbuild" class="headerlink" title="onbuild"></a>onbuild</h3><p><code>onbuild env C = 10</code></p>
<p>在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build </p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener">Dockerfile</a><br><a href="https://www.bilibili.com/video/av85895204?from=search&seid=4835159816508980526" target="_blank" rel="noopener">Dockerfile用法全解析</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Compose</title>
    <url>/2020/02/15/Docker-Compose/</url>
    <content><![CDATA[<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Mac 用户不需要单独安装 Compose，因为Docker 桌面版已经包含</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blogs docker-compose --version</span><br><span class="line">docker-compose version 1.24.1, build 4667896b</span><br></pre></td></tr></table></figure>

<p>Compose 使用的三个步骤：</p>
<p>1.通过Dockerfile定义容器环境，打包成镜像</p>
<p>2.通过docker-compose.yml定义各应用服务</p>
<p>3.通过docker-compose up命令来启动所有容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">   - <span class="string">"5000:5000"</span></span><br><span class="line">    volumes:</span><br><span class="line">   - .:/code</span><br><span class="line">    - logvolume01:/var/<span class="built_in">log</span></span><br><span class="line">    links:</span><br><span class="line">   - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">Docker Compose</a><br><a href="https://www.bilibili.com/video/av61131351?from=search&seid=5421358312704070453" target="_blank" rel="noopener">实战~如何组织一个多容器项目docker-compose</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2020/02/14/RPC/</url>
    <content><![CDATA[<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><img src="/2020/02/14/RPC/RPC.png" alt></p>
<h3 id="RPC与Restful接口的调用"><a href="#RPC与Restful接口的调用" class="headerlink" title="RPC与Restful接口的调用"></a>RPC与Restful接口的调用</h3><p>不关心调用方式，通过网络传输<br>RPC相对高效，http接口相对灵活 </p>
<p>restful接口更适合终端与服务端之间的交互，rpc更适合微服务的应用间通讯</p>
<h3 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h3><p>ProtoBuf是一种跨语言和跨平台的数据序列化协议；<br>与XML/JSON相比，序列化效率更快、体积更小、更安全；<br>与XML/JSON相比，可读性差、灵活性较低；<br>自带编译器，定义proto源文件，可编译成多种语言的代码；</p>
<h3 id="gRPC框架"><a href="#gRPC框架" class="headerlink" title="gRPC框架"></a>gRPC框架</h3><p><img src="/2020/02/14/RPC/gRPC.jpeg" alt></p>
<h3 id="框架go-micro"><a href="#框架go-micro" class="headerlink" title="框架go-micro"></a>框架go-micro</h3><p>专注于微服务的一种RPC框架；<br>提供分布式系统相关的接口集合；</p>
<p>服务发现：支持服务注册与发现</p>
<p>负载均衡：rpc服务间的请求调度均衡策略</p>
<p>同步通信：基于RPC通信，支持单项、双向流通信模式</p>
<p>异步通信：提供pub\sub通信模型的接口</p>
<p>高级接口：比如服务发现，提供调用的接口是一致的</p>
<p><img src="/2020/02/14/RPC/goMicro.png" alt></p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin基本了解</title>
    <url>/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>学习资料:<br><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin项目地址</a><br><a href="https://gin-gonic.com/zh-cn/" target="_blank" rel="noopener">gin中文文档</a><br><a href="https://www.imooc.com/learn/1175" target="_blank" rel="noopener">Gin入门实战</a><br><a href="https://github.com/samtake/gin-demo" target="_blank" rel="noopener">文中demo</a></p>
<h2 id="Gin运行流程"><a href="#Gin运行流程" class="headerlink" title="Gin运行流程"></a>Gin运行流程</h2><p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/gin.png" alt></p>
<p><code>engine</code>:实现了ServeHTTP接口的handler<br><code>methodTree</code>:根据http请求方法分别维护的路由树<br><code>routerGroup</code>:将路由表分组，方便中间件统一处理<br><code>Context</code>:Gin的上下文，在handler之间传递参数</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>Router ：路由规则定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	hdl <span class="string">"filestore-server/handler"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Router ：路由规则定义</span><br><span class="line">func Router() *gin.Engine &#123;</span><br><span class="line">	// gin framework</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	// 静态资源处理</span><br><span class="line">	router.Static(<span class="string">"/static/"</span>, <span class="string">"./static"</span>)</span><br><span class="line"></span><br><span class="line">	// 定义接口</span><br><span class="line">	router.GET(<span class="string">"/user/signup"</span>, hdl.SignupHandler)</span><br><span class="line">    router.POST(<span class="string">"/user/signup"</span>, hdl.DoSignupHandler)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>handler</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// SignupHandler : 处理用户注册请求</span><br><span class="line">func SignupHandler(c *gin.Context) &#123;</span><br><span class="line">	c.Redirect(http.StatusFound, <span class="string">"http://"</span>+c.Request.Host+<span class="string">"/static/view/signup.html"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// DoSignupHandler : 处理用户注册请求</span><br><span class="line">func DoSignupHandler(c *gin.Context) &#123;</span><br><span class="line">	username := c.Request.FormValue(<span class="string">"username"</span>)</span><br><span class="line">	passwd := c.Request.FormValue(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> len(username) &lt; 3 || len(passwd) &lt; 5 &#123;</span><br><span class="line">		c.JSON(http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">"msg"</span>: <span class="string">"Invalid parameter"</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 对密码进行加盐及取Sha1值加密</span><br><span class="line">	encPasswd := util.Sha1([]byte(passwd + pwdSalt))</span><br><span class="line">	// 将用户信息注册到用户表中</span><br><span class="line">	suc := dblayer.UserSignup(username, encPasswd)</span><br><span class="line">	<span class="keyword">if</span> suc &#123;</span><br><span class="line">		c.JSON(http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">"code"</span>:    0,</span><br><span class="line">				<span class="string">"msg"</span>:     <span class="string">"注册成功"</span>,</span><br><span class="line">				<span class="string">"data"</span>:    nil,</span><br><span class="line">				<span class="string">"forward"</span>: <span class="string">"/user/signin"</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">"code"</span>: 0,</span><br><span class="line">				<span class="string">"msg"</span>:  <span class="string">"注册失败"</span>,</span><br><span class="line">				<span class="string">"data"</span>: nil,</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终main.go可简洁为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	// gin framework</span><br><span class="line">	router := route.Router()</span><br><span class="line"></span><br><span class="line">	// 启动服务并监听端口</span><br><span class="line">	err := router.Run(config.UploadServiceHost)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Failed to start server, err:%s\n"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line">	r.Use(gin.Recovery())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"first"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"first ........."</span>)</span><br><span class="line">		c.JSON(200, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	authorized := r.Group(<span class="string">"/try"</span>)</span><br><span class="line"></span><br><span class="line">	authorized.POST(<span class="string">"/second"</span>, second)</span><br><span class="line">	authorized.POST(<span class="string">"/third"</span>, third)</span><br><span class="line"></span><br><span class="line">	// 嵌套路由组</span><br><span class="line">	testing := authorized.Group(<span class="string">"testing"</span>)</span><br><span class="line">	testing.GET(<span class="string">"/forth"</span>, fourth)</span><br><span class="line"></span><br><span class="line">	// 监听并在 0.0.0.0:8080 上启动服务</span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func second(c *gin.Context) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"second ........."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func third(c *gin.Context) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"third ........."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fourth(c *gin.Context) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"fourth ........."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  gin-demo git:(master) ✗ lsof -i tcp:8080    </span><br><span class="line">COMMAND     PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">QQ          327 samtake   29u  IPv4 0xfdcbb6b79716f31f      0t0  TCP huangloshansmbp:50202-&gt;157.255.13.190:http-alt (ESTABLISHED)</span><br><span class="line">QQ          327 samtake   48u  IPv4 0xfdcbb6b79716f31f      0t0  TCP huangloshansmbp:50202-&gt;157.255.13.190:http-alt (ESTABLISHED)</span><br><span class="line">Google      420 samtake   26u  IPv4 0xfdcbb6b793e58fb7      0t0  TCP localhost:51492-&gt;localhost:http-alt (ESTABLISHED)</span><br><span class="line">Postman   66875 samtake   67u  IPv4 0xfdcbb6b778668ca7      0t0  TCP localhost:51499-&gt;localhost:http-alt (ESTABLISHED)</span><br><span class="line">main      67553 samtake    3u  IPv6 0xfdcbb6b793ea9b8f      0t0  TCP *:http-alt (LISTEN)</span><br><span class="line">main      67553 samtake    7u  IPv6 0xfdcbb6b793eac3cf      0t0  TCP localhost:http-alt-&gt;localhost:51492 (ESTABLISHED)</span><br><span class="line">main      67553 samtake    8u  IPv6 0xfdcbb6b7912a55cf      0t0  TCP localhost:http-alt-&gt;localhost:51499 (ESTABLISHED)</span><br><span class="line">➜  gin-demo git:(master) ✗ <span class="built_in">kill</span> -9  67553      </span><br><span class="line">➜  gin-demo git:(master) ✗ go run start/main.go</span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">"debug"</span> mode. Switch to <span class="string">"release"</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /first                    --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] POST   /try/second               --&gt; main.second (3 handlers)</span><br><span class="line">[GIN-debug] POST   /try/third                --&gt; main.third (3 handlers)</span><br><span class="line">[GIN-debug] GET    /try/testing/forth        --&gt; main.fourth (3 handlers)</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br><span class="line">first .........</span><br><span class="line">[GIN] 2020/02/25 - 11:51:19 | 200 |     176.613µs |       127.0.0.1 | GET      /first</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/gin-first.png" alt></p>
<h2 id="1-请求路由"><a href="#1-请求路由" class="headerlink" title="1.请求路由"></a>1.请求路由</h2><h3 id="多种请求"><a href="#多种请求" class="headerlink" title="多种请求"></a>多种请求</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"get"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"get"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">"post"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"post"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.DELETE(<span class="string">"delete"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"delete"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Any(<span class="string">"/any"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"any"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>给我们创建的any请求几乎覆盖了所有种类的请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GIN-debug] GET    /get                      --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] POST   /post                     --&gt; main.main.func2 (3 handlers)</span><br><span class="line">[GIN-debug] DELETE /delete                   --&gt; main.main.func3 (3 handlers)</span><br><span class="line">[GIN-debug] GET    /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] POST   /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] PUT    /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] PATCH  /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] HEAD   /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] OPTIONS /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] DELETE /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] CONNECT /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] TRACE  /any                      --&gt; main.main.func4 (3 handlers)</span><br><span class="line">[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure>

<h3 id="静态文件夹"><a href="#静态文件夹" class="headerlink" title="静态文件夹"></a>静态文件夹</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	// 静态文件夹绑定+路由，有两种写法：</span><br><span class="line">	r.Static(<span class="string">"/assets"</span>, <span class="string">"./assets"</span>)</span><br><span class="line">	r.StaticFS(<span class="string">"/static"</span>, http.Dir(<span class="string">"static"</span>))</span><br><span class="line"></span><br><span class="line">	//又或者路由+资源</span><br><span class="line">	r.StaticFile(<span class="string">"/favicon.ico"</span>, <span class="string">"/favicon.ico"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>go build -o router_static &amp;&amp; ./router_static</code>这需要在routerstatic文件夹下运行，不然找不到资源文件，最后访问<code>http://localhost:8080/assets/a.html</code>以及<code>http://localhost:8080/static/b.html</code>测试即可。</p>
<h3 id="参数作为url"><a href="#参数作为url" class="headerlink" title="参数作为url"></a>参数作为url</h3><p>Get请求<code>http://localhost:8080/Sam/520</code>即可得到相应参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"520"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Sam"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-获取请求参数"><a href="#2-获取请求参数" class="headerlink" title="2.获取请求参数"></a>2.获取请求参数</h2><ul>
<li>获取get请求参数</li>
<li>获取post请求参数</li>
<li>获取body值</li>
<li>获取参数绑定结构体</li>
</ul>
<h3 id="泛绑定"><a href="#泛绑定" class="headerlink" title="泛绑定"></a>泛绑定</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/user/*action"</span>, func(c *gin.Context) &#123; //设置获取name和id的参数</span><br><span class="line">		c.String(200, <span class="string">"泛绑定～"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有user前缀的请求都能请求到：<code>http://localhost:8080/user/&lt;XXXX&gt;</code></p>
<h3 id="获取get参数"><a href="#获取get参数" class="headerlink" title="获取get参数"></a>获取get参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/testGetParam"</span>, func(c *gin.Context) &#123; //设置获取name和id的参数</span><br><span class="line">		param1 := c.Query(<span class="string">"parm1"</span>)</span><br><span class="line">		param2 := c.Query(<span class="string">"parm2"</span>)</span><br><span class="line"></span><br><span class="line">		c.String(http.StatusOK, <span class="string">"%s, %s"</span>, param1, param2)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET <span class="string">'http://127.0.0.1:8080/testGetParam?parm1=11111'</span> </span><br><span class="line">11111, %  </span><br><span class="line">➜  ~ curl -X GET <span class="string">'http://127.0.0.1:8080/testGetParam?parm1=11111&amp;parm2=2222'</span></span><br><span class="line">11111, 2222%</span><br></pre></td></tr></table></figure>



<h3 id="获取body内容"><a href="#获取body内容" class="headerlink" title="获取body内容"></a>获取body内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.POST(<span class="string">"/parmBody"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		bodyBytes, err := ioutil.ReadAll(c.Request.Body)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			c.String(http.StatusBadRequest, err.Error())</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">		c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes)) //重新回写到缓存才能拿到parm1 parm2</span><br><span class="line">		parm1 := c.PostForm(<span class="string">"parm1"</span>)</span><br><span class="line">		parm2 := c.PostForm(<span class="string">"parm2"</span>)</span><br><span class="line">		c.String(http.StatusOK, <span class="string">"%s %s %s"</span>, parm1, parm2, string(bodyBytes))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X POST <span class="string">'http://127.0.0.1:8080/parmBody'</span> -d <span class="string">'parm1=value1&amp;parm2=value2'</span> </span><br><span class="line">value1 value2 parm1=value1&amp;parm2=value2%                                                                                                                               </span><br><span class="line">➜  ~ curl -X POST <span class="string">'http://127.0.0.1:8080/parmBody'</span> -d <span class="string">'&#123;"parm1":"value1","parm2":"value2"&#125;'</span></span><br><span class="line">  &#123;<span class="string">"parm1"</span>:<span class="string">"value1"</span>,<span class="string">"parm2"</span>:<span class="string">"value2"</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取bind参数"><a href="#获取bind参数" class="headerlink" title="获取bind参数"></a>获取bind参数</h3><p>同时响应post和get，同时访问到同一个回调方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct &#123;</span><br><span class="line">	Name     string    `form:<span class="string">"name"</span>` //设置tag `form`可以由参数转变成结构体</span><br><span class="line">	Address  string    `form:<span class="string">"address"</span>`</span><br><span class="line">	Birthday time.Time `form:<span class="string">"birthday"</span> time_format:<span class="string">"2006-01-03"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, testHandler)</span><br><span class="line">	r.POST(<span class="string">"/test"</span>, testHandler)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testHandler(c *gin.Context) &#123;</span><br><span class="line">	var person Person</span><br><span class="line">	//根据请求content-type来作不同的binding操作</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBind(&amp;person); err == nil &#123;</span><br><span class="line">		c.String(200, <span class="string">"%v"</span>, person)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.String(200, <span class="string">"person bind error"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET  <span class="string">'http://127.0.0.1:8080/test?name=samtake&amp;adress=gd'</span></span><br><span class="line">&#123;samtake  0001-01-01 00:00:00 +0000 UTC&#125;</span><br><span class="line">➜  ~ curl -X GET  <span class="string">'http://127.0.0.1:8080/test?name=samtake&amp;address=gd'</span></span><br><span class="line">&#123;samtake gd 0001-01-01 00:00:00 +0000 UTC&#125;%  </span><br><span class="line">➜  ~ curl -X POST  <span class="string">'http://127.0.0.1:8080/test?name=samtake&amp;address=gd&amp;birthday=2008-09-09'</span></span><br><span class="line">&#123;samtake gd 2008-09-01 09:00:00 +0800 CST&#125;%   </span><br><span class="line">➜  ~ curl -X POST  <span class="string">'http://127.0.0.1:8080/test'</span>  -d <span class="string">'name=samtake&amp;address=gd&amp;birthday=2008-09-09'</span></span><br><span class="line">&#123;samtake gd 2008-09-01 09:00:00 +0800 CST&#125;%   </span><br><span class="line">➜  ~ curl -H <span class="string">"Content-Type:application/json"</span>  -X POST <span class="string">"http://127.0.0.1:8080/test"</span>  -d <span class="string">'&#123;"name":"wang"&#125;'</span></span><br><span class="line">&#123;wang  0001-01-01 00:00:00 +0000 UTC&#125;%</span><br></pre></td></tr></table></figure>


<p>这里有个坑：如果时间格式写成像<code>time_format:&quot;2006-01-03&quot;</code>这种会报错，解析不了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">person <span class="built_in">bind</span> error%!(EXTRA *time.ParseError=parsing time <span class="string">"2008-00-08"</span> as <span class="string">"2011-01-03"</span>: cannot parse <span class="string">"-00-08"</span> as <span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>


<h2 id="验证请求参数"><a href="#验证请求参数" class="headerlink" title="验证请求参数"></a>验证请求参数</h2><ul>
<li>结构体验证</li>
<li>自定义验证</li>
<li>支持多语言错误信息</li>
</ul>
<h3 id="结构体验证"><a href="#结构体验证" class="headerlink" title="结构体验证"></a>结构体验证</h3><p><a href="https://godoc.org/gopkg.in/go-playground/validator.v9" target="_blank" rel="noopener">validate规则</a><br>binding条件满足</p>
<p>坑的记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct &#123;</span><br><span class="line">	Age     int    `form:<span class="string">"age"</span>  binding:<span class="string">"required,gt=10"</span>`</span><br><span class="line">	Name    string `form:<span class="string">"name"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">	Address string `form:<span class="string">"address"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/validate-form.png" alt></p>
<p>正确的完整源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct &#123;</span><br><span class="line">	Age     int    `form:<span class="string">"Age"</span>  binding:<span class="string">"required,gt=10"</span>`</span><br><span class="line">	Name    string `form:<span class="string">"Name"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">	Address string `form:<span class="string">"Address"</span> binding:<span class="string">"required"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, testHandler)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testHandler(c *gin.Context) &#123;</span><br><span class="line">	var person Person</span><br><span class="line">	//根据请求content-type来作不同的binding操作</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBind(&amp;person); err != nil &#123;</span><br><span class="line">		c.String(500, <span class="string">"%v"</span>, err)</span><br><span class="line">		c.Abort()</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.String(200, <span class="string">"%v"</span>, person)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET  <span class="string">"http://127.0.0.1:8080/test?age=19&amp;name=samtake&amp;address=gd"</span></span><br><span class="line">Key: <span class="string">'Person.Age'</span> Error:Field validation <span class="keyword">for</span> <span class="string">'Age'</span> failed on the <span class="string">'required'</span> tag</span><br><span class="line">Key: <span class="string">'Person.Name'</span> Error:Field validation <span class="keyword">for</span> <span class="string">'Name'</span> failed on the <span class="string">'required'</span> tag</span><br><span class="line">Key: <span class="string">'Person.Address'</span> Error:Field validation <span class="keyword">for</span> <span class="string">'Address'</span> failed on the <span class="string">'required'</span> tag% </span><br><span class="line">➜  ~ curl -X GET  <span class="string">"http://127.0.0.1:8080/test?Age=19&amp;Name=samtake&amp;Address=gd"</span></span><br><span class="line">&#123;19 samtake gd&#125;%</span><br></pre></td></tr></table></figure>

<h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">	&quot;github.com/gin-gonic/gin/binding&quot;</span><br><span class="line">	&quot;gopkg.in/go-playground/validator.v9&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Booking struct &#123;</span><br><span class="line">	CheckIn  time.Time `form:&quot;check_in&quot;  binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-01&quot;`</span><br><span class="line">	CheckOut time.Time `form:&quot;check_out&quot;  binding:&quot;required,gtfield=checkIn&quot; time_format:&quot;2006-01-01&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func customFunc(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string) bool &#123;</span><br><span class="line">	if date, ok := field.Interface().(time.Time); ok &#123;</span><br><span class="line">		today := time.Now()</span><br><span class="line">		if date.Unix() &gt; today.Unix() &#123;</span><br><span class="line">			return true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">		v.RegisterValidation(&quot;bookabledate&quot;, customFunc)</span><br><span class="line">	&#125;</span><br><span class="line">	r.GET(&quot;/bookable&quot;, testHandler)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testHandler(c *gin.Context) &#123;</span><br><span class="line">	var b Booking</span><br><span class="line">	if err := c.ShouldBind(&amp;b); err != nil &#123;</span><br><span class="line">		c.JSON(500, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(200, gin.H&#123;&quot;message&quot;: &quot;ok!&quot;, &quot;booking&quot;: b&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个报错，我自己也还没弄明白，然而我看了下源码，上面的使用方法是正确的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">validCustom/validCustom.go:30:24: cannot use customFunc (<span class="built_in">type</span> func(*validator.Validate, reflect.Value, reflect.Value, reflect.Value, reflect.Typ</span><br><span class="line">e, reflect.Kind, string) bool) as <span class="built_in">type</span> validator.Func <span class="keyword">in</span> argument to v.RegisterValidation</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// RegisterValidation adds a validation with the given tag</span><br><span class="line">//</span><br><span class="line">// NOTES:</span><br><span class="line">// - <span class="keyword">if</span> the key already exists, the previous validation <span class="keyword">function</span> will be replaced.</span><br><span class="line">// - this method is not thread-safe it is intended that these all be registered prior to any validation</span><br><span class="line">func (v *Validate) RegisterValidation(tag string, fn Func) error &#123;</span><br><span class="line">	<span class="built_in">return</span> v.RegisterValidationCtx(tag, wrapFunc(fn))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持多语言错误信息"><a href="#支持多语言错误信息" class="headerlink" title="支持多语言错误信息"></a>支持多语言错误信息</h3><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul>
<li>使用Gin中间件</li>
<li>自定义<code>ip白名单</code>中间件</li>
</ul>
<h3 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h3><p><code>Logger</code>日志<br><code>Recovery</code>捕获panic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	f, _ := os.Create(<span class="string">"gin.log"</span>)</span><br><span class="line">	gin.DefaultWriter = io.MultiWriter(f)</span><br><span class="line">	gin.DefaultErrorWriter = io.MultiWriter(f)</span><br><span class="line"></span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(gin.Logger(),gin.Recovery())</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		name := c.DefaultQuery(<span class="string">"name"</span>, <span class="string">"default_name"</span>)</span><br><span class="line">		c.String(200, <span class="string">"%s"</span>, name)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p><code>r.User(IPAuthMiddleware())</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func IPAuthMiddleware() gin.HandlerFunc &#123;</span><br><span class="line">	<span class="built_in">return</span> func(c *gin.Context) &#123;</span><br><span class="line">		ipList := []string&#123;</span><br><span class="line">			<span class="string">"127.0.0.1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		flag := <span class="literal">false</span></span><br><span class="line">		clientIP := c.ClientIP()</span><br><span class="line">		<span class="keyword">for</span> _, host := range ipList &#123;</span><br><span class="line">			<span class="keyword">if</span> clientIP == host &#123;</span><br><span class="line">				flag = <span class="literal">true</span></span><br><span class="line">				<span class="built_in">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !flag &#123;</span><br><span class="line">			c.String(401, <span class="string">"%s,not in iplist"</span>, clientIP)</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(IPAuthMiddleware())</span><br><span class="line">	r.Use(gin.Logger(), gin.Recovery())</span><br><span class="line">	r.GET(<span class="string">"/test"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.String(200, <span class="string">"%s"</span>, <span class="string">"hello test"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Gin延展"><a href="#Gin延展" class="headerlink" title="Gin延展"></a>Gin延展</h2><ul>
<li>服务器优雅关停</li>
<li>模版渲染</li>
<li>自动证书配置</li>
</ul>
<h3 id="服务器关停"><a href="#服务器关停" class="headerlink" title="服务器关停"></a>服务器关停</h3><p><img src="/2020/02/14/Gin%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/gin-server-stop.png" alt></p>
<h3 id="模版渲染"><a href="#模版渲染" class="headerlink" title="模版渲染"></a>模版渲染</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLGlob(<span class="string">"template/*"</span>)</span><br><span class="line">	r.GET(<span class="string">"/index"</span>, func(c *gin.Context) &#123;</span><br><span class="line">		c.HTML(200, <span class="string">"index.html"</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"index.html"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl -X GET  <span class="string">"http://127.0.0.1:8080/index"</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">        index.html</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">&lt;/html&gt;%                                                                        </span><br><span class="line">➜  ~</span><br></pre></td></tr></table></figure>

<h3 id="自动证书配置"><a href="#自动证书配置" class="headerlink" title="自动证书配置"></a>自动证书配置</h3><h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><p>项目地址：<br><a href="https://github.com/e421083458/gin_scaffold" target="_blank" rel="noopener">gin_scaffold</a><br><a href="https://github.com/e421083458/golang_common" target="_blank" rel="noopener">golang_common</a><br><a href="https://github.com/e421083458/vue-admin" target="_blank" rel="noopener">vue-admin</a></p>
<h3 id="轻量级Golang类库"><a href="#轻量级Golang类库" class="headerlink" title="轻量级Golang类库"></a>轻量级Golang类库</h3><p>GORM:<a href="https://gorm.io/zh_CN/" target="_blank" rel="noopener">https://gorm.io/zh_CN/</a><br>redigo:<a href="https://godoc.org/github.com/gomodule/redigo/redis" target="_blank" rel="noopener">https://godoc.org/github.com/gomodule/redigo/redis</a></p>
<p>├── README.md<br>├── conf   配置文件夹<br>│   └── dev<br>│       ├── base.toml<br>│       ├── mysql_map.toml<br>│       └── redis_map.toml<br>├── controller 控制器<br>│   └── demo.go<br>├── dao DB数据访问层<br>│   └── demo.go<br>├── dto  Bind结构体层<br>│   └── demo.go<br>├── gin_scaffold.inf.log  info日志<br>├── gin_scaffold.wf.log warning日志<br>├── go.mod go module管理文件<br>├── go.sum<br>├── main.go<br>├── middleware 中间件层<br>│   ├── panic.go<br>│   ├── response.go<br>│   ├── token_auth.go<br>│   └── translation.go<br>├── public  公共文件<br>│   ├── log.go<br>│   ├── mysql.go<br>│   └── validate.go<br>├── router  路由层<br>│   ├── httpserver.go<br>│   └── route.go<br>└── tmpl</p>
<h3 id="输出格式统一封装"><a href="#输出格式统一封装" class="headerlink" title="输出格式统一封装"></a>输出格式统一封装</h3><h3 id="自定义中间件日志打印"><a href="#自定义中间件日志打印" class="headerlink" title="自定义中间件日志打印"></a>自定义中间件日志打印</h3><h3 id="请求数据绑定结构体与校验"><a href="#请求数据绑定结构体与校验" class="headerlink" title="请求数据绑定结构体与校验"></a>请求数据绑定结构体与校验</h3>]]></content>
      <categories>
        <category>Gin</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Gin</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Docker安装RabbitMQ</title>
    <url>/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h3 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /Users/samtake/Documents/GitHub/www/rabbitmq目录可自定义，主要用于目录挂载</span></span><br><span class="line">➜  ~ mkdir -p /Users/samtake/Documents/GitHub/www/rabbitmq</span><br><span class="line">➜  ~ docker run -d --hostname rabbit-node1 --name rabbit-node1 -p 5672:5672 -p15672:15672 -v /Users/samtake/Documents/GitHub/www/rabbitmq:/var/lib/rabbitmq rabbitmq:management</span><br><span class="line">Unable to find image <span class="string">'rabbitmq:management'</span> locally</span><br><span class="line">management: Pulling from library/rabbitmq</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>报错提示,手动添加一下docker分享目录即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The path /www/rabbitmq</span><br><span class="line">is not shared from OS X and is not known to Docker.</span><br><span class="line">You can configure shared paths from Docker -&gt; Preferences... -&gt; File Sharing.</span><br><span class="line">See https://docs.docker.com/docker-for-mac/osxfs/<span class="comment">#namespaces for more info.</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ docker ps | grep rabbit</span><br><span class="line">75d0ec6821fc        rabbitmq:management   <span class="string">"docker-entrypoint.s…"</span>   About a minute ago   Up About a minute   4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp   rabbit-node1</span><br></pre></td></tr></table></figure>


<p>浏览器打开登录rabbitmq, 入口:<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a><br>默认用户名: guest 密码: guest</p>
<h3 id="RabbitMQ的UI界面使用测试"><a href="#RabbitMQ的UI界面使用测试" class="headerlink" title="RabbitMQ的UI界面使用测试"></a>RabbitMQ的UI界面使用测试</h3><h3 id="RabbitMQ的工作原理和转发模式"><a href="#RabbitMQ的工作原理和转发模式" class="headerlink" title="RabbitMQ的工作原理和转发模式"></a>RabbitMQ的工作原理和转发模式</h3><p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/RabbitMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt></p>
<p>名词解析：<br><code>exchange</code>:消息交换机，决定消息按什么规则，路由到哪个队列。<br><code>queue</code>:消息载体，每个消息都会被投到一个或多个队列。<br><code>binding</code>:绑定，把exchange和queue按照路由规则绑定起来。<br><code>routing key</code>:路由关键字，exchange根据这关键字来投递消息。<br><code>channel</code>:消息通道，客户端的每个连接建立多个channnel。<br><code>producer</code>:消息生产者，用于投递消息的程序。<br><code>consumer</code>:消息消费者，用于接收消息的程序。</p>
<p>exchange的工作模式<br><code>fanout</code>:类似广播，转发到所有绑定交换机的queue。<br><code>direct</code>:类似单播，routing key 和bingding key完美匹配。<br><code>topic</code>:类似组播，转发到符合通配符的queue。<br><code>headers</code>:请求头与消息匹配，才能接收消息。</p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/fanout.png" alt></p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/direct.png" alt></p>
<p><img src="/2020/02/12/%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85RabbitMQ/topic.jpeg" alt></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>1.配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">	// AsyncTransferEnable : 是否开启文件异步转移(默认同步)</span><br><span class="line">	AsyncTransferEnable = <span class="literal">true</span></span><br><span class="line">	// RabbitURL : rabbitmq服务的入口url</span><br><span class="line">	RabbitURL = <span class="string">"amqp://guest:guest@127.0.0.1:5672/"</span></span><br><span class="line">	// TransExchangeName : 用于文件transfer的交换机</span><br><span class="line">	TransExchangeName = <span class="string">"uploadserver.trans"</span></span><br><span class="line">	// TransOSSQueueName : oss转移队列名</span><br><span class="line">	TransOSSQueueName = <span class="string">"uploadserver.trans.oss"</span></span><br><span class="line">	// TransOSSErrQueueName : oss转移失败后写入另一个队列的队列名</span><br><span class="line">	TransOSSErrQueueName = <span class="string">"uploadserver.trans.oss.err"</span></span><br><span class="line">	// TransOSSRoutingKey : routingkey</span><br><span class="line">	TransOSSRoutingKey = <span class="string">"oss"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>2.生产者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	// 是否开启异步转移功能，开启时才初始化rabbitMQ连接</span><br><span class="line">	<span class="keyword">if</span> !config.AsyncTransferEnable &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="function"><span class="title">initChannel</span></span>() &#123;</span><br><span class="line">		channel.NotifyClose(notifyClose)</span><br><span class="line">	&#125;</span><br><span class="line">	// 断线自动重连</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> msg := &lt;-notifyClose:</span><br><span class="line">				conn = nil</span><br><span class="line">				channel = nil</span><br><span class="line">				log.Printf(<span class="string">"onNotifyChannelClosed: %+v\n"</span>, msg)</span><br><span class="line">				initChannel()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initChannel() bool &#123;</span><br><span class="line">	//1.判断channel是否已经创建</span><br><span class="line">	<span class="keyword">if</span> channel != nil &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.获得rabbitMQ的一个连接</span><br><span class="line">	conn, err := amqp.Dial(config.RabbitURL)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//3.打开一个channel，用于消息的发布与接收等</span><br><span class="line">	channel, err = conn.Channel()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Publish : 发布消息</span><br><span class="line">func Publish(exchange, routingKey string, msg []byte) bool &#123;</span><br><span class="line">	//1.判断channel是否正常</span><br><span class="line">	<span class="keyword">if</span> !<span class="function"><span class="title">initChannel</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.执行消息发布</span><br><span class="line">	err := channel.Publish(</span><br><span class="line">		exchange,</span><br><span class="line">		routingKey,</span><br><span class="line">		<span class="literal">false</span>, // 如果没有对应的queue, 就会丢弃这条消息</span><br><span class="line">		<span class="literal">false</span>, //</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ContentType: <span class="string">"text/plain"</span>, //明文编码</span><br><span class="line">			Body:        msg,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.消费者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">done</span> chan bool</span><br><span class="line"></span><br><span class="line">// StartConsume : 开始监听队列，获取消息</span><br><span class="line">func StartConsume(qName, cName string, callback func(msg []byte) bool) &#123;</span><br><span class="line">	//1.通过channel.Consume获得消息信道</span><br><span class="line">	msgs, err := channel.Consume(</span><br><span class="line">		qName,</span><br><span class="line">		cName,</span><br><span class="line">		<span class="literal">true</span>,  //自动应答</span><br><span class="line">		<span class="literal">false</span>, // 非唯一的消费者</span><br><span class="line">		<span class="literal">false</span>, // rabbitMQ只能设置为<span class="literal">false</span></span><br><span class="line">		<span class="literal">false</span>, // noWait, <span class="literal">false</span>表示会阻塞直到有消息过来</span><br><span class="line">		nil)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">done</span> = make(chan bool)</span><br><span class="line"></span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		// 2.循环读取channel的数据</span><br><span class="line">		<span class="keyword">for</span> d := range msgs &#123;</span><br><span class="line">			//3.调用callback方法来处理新的消息</span><br><span class="line">			processErr := callback(d.Body)</span><br><span class="line">			<span class="keyword">if</span> processErr &#123;</span><br><span class="line">				// TODO: 将任务写入另一个队列，用于异常情况的重试</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// 接收<span class="keyword">done</span>的信号, 没有信息过来则会一直阻塞，避免该函数退出</span><br><span class="line">	&lt;-<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">	// 关闭通道</span><br><span class="line">	channel.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// StopConsume : 停止监听队列</span><br><span class="line">func <span class="function"><span class="title">StopConsume</span></span>() &#123;</span><br><span class="line">	<span class="keyword">done</span> &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">demo</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2020/02/12/Redis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="Docker-安装-Redis"><a href="#Docker-安装-Redis" class="headerlink" title="Docker 安装 Redis"></a>Docker 安装 Redis</h3><p><code>docker pull redis:latest</code><br>取最新版的 Redis 镜像</p>
<p><code>docker images</code><br>查看是否已安装了 redis</p>
<p>运行 redis 容器<br><code>docker run -itd --name redis-test -p 6379:6379 redis</code><br>或者运行redis并设置密码<br><code>docker run -d --name myredis -p 6379:6379 redis --requirepass &quot;mypassword&quot;</code></p>
<p>其中-p 6379:6379：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。</p>
<p><code>docker ps</code> 查看容器的运行信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Desktop docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                               NAMES</span><br><span class="line">d1f67d1e5fda        redis               <span class="string">"docker-entrypoint.s…"</span>   About a minute ago   Up About a minute   0.0.0.0:6379-&gt;6379/tcp              redis-test</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   8 hours ago          Up 8 hours          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br></pre></td></tr></table></figure>


<p>最后，通过过 redis-cli 连接测试使用 redis 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Desktop docker <span class="built_in">exec</span> -it redis-test /bin/bash</span><br><span class="line">root@d1f67d1e5fda:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> <span class="built_in">test</span> 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作；</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素；读取单个或者多个元素；进行修剪，只保留一个范围内的元素；</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素；</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、删除单个键值对；获取所有键值对；检查某个健是否存在；</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键的排名；</td>
</tr>
</tbody></table>
<h4 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取存储在给定健中的值</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定健中的值</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定健中的值（这个命令可以用于所有类型）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name longshan</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"longshan"</span></span><br><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h4 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>rpush</td>
<td>获取存储在给定键中的值</td>
</tr>
<tr>
<td>lrange</td>
<td>设置存储在给定键中的值</td>
</tr>
<tr>
<td>lindex</td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）</td>
</tr>
<tr>
<td>lpop</td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0-1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'lrange'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"item1"</span></span><br><span class="line">2) <span class="string">"item2"</span></span><br><span class="line">3) <span class="string">"item3"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'lrange'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 1</span><br><span class="line"><span class="string">"item2"</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line"><span class="string">"item1"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"item2"</span></span><br><span class="line">2) <span class="string">"item3"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><p>命令    | 行为<br>-|-|-<br>sadd    | 添加一个或多个元素到集合里<br>smembers |    获取集合里面的所有元素<br>sismember |    确定一个给定的值是一个集合的成员<br>srem    | 从集合里删除一个或多个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> item3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smember <span class="built_in">set</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `smember`, with args beginning with: `<span class="built_in">set</span>`, </span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"item3"</span></span><br><span class="line">2) <span class="string">"item1"</span></span><br><span class="line">3) <span class="string">"item2"</span></span><br><span class="line">127.0.0.1:6379&gt; sismember <span class="built_in">set</span> item5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> item2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smenbers <span class="built_in">set</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `smenbers`, with args beginning with: `<span class="built_in">set</span>`, </span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"item3"</span></span><br><span class="line">2) <span class="string">"item1"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h4 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h4><p>命令    | 行为<br>-|-|-<br>hset    | 设置 hash 里面一个字段的值<br>hget    | 获取 hash 中域的值<br>hgetall    | 从 hash 中读取全部的域和值<br>hdel    | 删除一个或多个域</p>
<h4 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h4><p>命令    | 行为<br>-|-|-<br>ZADD    | 添加到有序 set 的一个或多个成员，或更新的分数，如果它已经存在<br>ZRANGE    | 根据指定的 index 返回，返回 sorted set 的成员列表<br>ZRANGEBYSCORE    | 返回有序集合中指定分数区间内的成员，分数由低到高排序。<br>ZREM    | 从排序的集合中删除一个或多个成员</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>缓存 - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</p>
</li>
<li><p>计数器 - Redis 这种内存数据库能支持计数器频繁的读写操作。</p>
</li>
<li><p>应用限流 - 限制一个网站访问流量。</p>
</li>
<li><p>消息队列 - 使用 List 数据类型，它是双向链表。</p>
</li>
<li><p>查找表 - 使用 HASH 数据类型。</p>
</li>
<li><p>交集运算 - 使用 SET 类型，例如求两个用户的共同好友。</p>
</li>
<li><p>排行榜 - 使用 ZSET 数据类型。</p>
</li>
<li><p>分布式 Session - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</p>
</li>
<li><p>分布式锁 - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
</li>
</ul>
<h3 id="通过go语言使用Redis"><a href="#通过go语言使用Redis" class="headerlink" title="通过go语言使用Redis"></a>通过go语言使用Redis</h3><p>1.设置一下Redis密码然后测试连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  egoshop docker rm -f cd93e4361dff                                                 </span><br><span class="line">cd93e4361dff</span><br><span class="line"></span><br><span class="line">➜  egoshop docker run -d --name myredis -p 6379:6379 redis --requirepass <span class="string">"mypassword"</span></span><br><span class="line">f21ed92618bc5a48a95a05fcf73d1fb911b3020616dfd4950b4827dc9559814e</span><br><span class="line">➜  egoshop docker ps                                                                 </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">f21ed92618bc        redis               <span class="string">"docker-entrypoint.s…"</span>   3 seconds ago       Up 1 second         0.0.0.0:6379-&gt;6379/tcp              myredis</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   10 hours ago        Up 10 hours         0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br><span class="line">➜  egoshop docker <span class="built_in">exec</span> -it myredis /bin/bash</span><br><span class="line">root@f21ed92618bc:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; auth <span class="string">"mypassword"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>2.创建连接池</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func newRedisPool() *redis.Pool &#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;redis.Pool&#123;</span><br><span class="line">		MaxIdle:     50,</span><br><span class="line">		MaxActive:   30,</span><br><span class="line">		IdleTimeout: 300 * time.Second,</span><br><span class="line">		Dial: func() (redis.Conn, error) &#123;</span><br><span class="line">			// 1. 打开连接</span><br><span class="line">			c, err := redis.Dial(<span class="string">"tcp"</span>, redisHost)</span><br><span class="line">			<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">				<span class="built_in">return</span> nil, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 2. 访问认证</span><br><span class="line">			<span class="keyword">if</span> _, err = c.Do(<span class="string">"AUTH"</span>, redisPass); err != nil &#123;</span><br><span class="line">				c.Close()</span><br><span class="line">				<span class="built_in">return</span> nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">return</span> c, nil</span><br><span class="line">		&#125;,</span><br><span class="line">		TestOnBorrow: func(conn redis.Conn, t time.Time) error &#123;</span><br><span class="line">			<span class="keyword">if</span> time.Since(t) &lt; time.Minute &#123;</span><br><span class="line">				<span class="built_in">return</span> nil</span><br><span class="line">			&#125;</span><br><span class="line">			_, err := conn.Do(<span class="string">"PING"</span>)</span><br><span class="line">			<span class="built_in">return</span> err</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	pool = newRedisPool()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RedisPool() *redis.Pool &#123;</span><br><span class="line">	<span class="built_in">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">UploadHandler</span></span>() &#123;</span><br><span class="line">	// 获得redis的一个连接</span><br><span class="line">	rConn := rPool.RedisPool().Get()</span><br><span class="line">	defer rConn.Close()</span><br><span class="line"></span><br><span class="line">	// 将初信息写入到redis缓存</span><br><span class="line">	rConn.Do(<span class="string">"sadd"</span>, <span class="string">"set"</span>, <span class="string">"uploadHandler"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.查看是否有添加数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"upload1"</span></span><br><span class="line">2) <span class="string">"uploadHandler"</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/samtake/goRedisDemo" target="_blank" rel="noopener">具体demo源码</a></p>
<p>参考资料<br><a href="https://www.runoob.com/redis/redis-intro.html" target="_blank" rel="noopener">Redis 简介</a><br><a href="https://www.runoob.com/docker/docker-install-redis.html" target="_blank" rel="noopener">Docker 安装 Redis</a><br><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1581497616&ver=2153&signature=wJL6PdenqSUgK7dgiXas*bbrDcJzwBzrYoKKYFFfsxW*dYcRnVHqpFKbcYqLDd-bp7DY50iIvxGq8jNMAbQXau-uLB0hPqUJc4erX3MDhbuOrvvtCbw7KY3147aW3KBr&new=1" target="_blank" rel="noopener">Redis 入门指南</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat使用资料</title>
    <url>/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p>实操一下</p>
<p>通过docker来启动一个mysql容器应用<br><code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</code></p>
<h3 id="通过docker-exec-it-容器id-bash-来操作mysql"><a href="#通过docker-exec-it-容器id-bash-来操作mysql" class="headerlink" title="通过docker exec -it 容器id bash 来操作mysql"></a>通过docker exec -it 容器id bash 来操作mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  blogs docker ps                      </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">0eee2c1708be        mysql:5.7           <span class="string">"docker-entrypoint.s…"</span>   41 minutes ago      Up 41 minutes       0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   happy_chandrasekhar</span><br><span class="line">➜  blogs docker <span class="built_in">exec</span> -it  0eee2c1708be bash            </span><br><span class="line">root@0eee2c1708be:/<span class="comment"># mysql -uroot -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 765627</span><br><span class="line">Server version: 5.7.29 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; status;</span><br><span class="line">--------------</span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.29, <span class="keyword">for</span> Linux (x86_64) using  EditLine wrapper</span><br><span class="line"></span><br><span class="line">Connection id:		765627</span><br><span class="line">Current database:	</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not <span class="keyword">in</span> use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		<span class="string">''</span></span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.7.29 MySQL Community Server (GPL)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	latin1</span><br><span class="line">Db     characterset:	latin1</span><br><span class="line">Client characterset:	latin1</span><br><span class="line">Conn.  characterset:	latin1</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			1 hour 2 min 0 sec</span><br><span class="line"></span><br><span class="line">Threads: 2  Questions: 6  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.001</span><br><span class="line">--------------</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>


<h3 id="在navicat中使用sql语句创建表"><a href="#在navicat中使用sql语句创建表" class="headerlink" title="在navicat中使用sql语句创建表"></a>在navicat中使用sql语句创建表</h3><p>1.进行命令行操作</p>
<p><img src="/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/navicate-console.jpeg" alt></p>
<p>2.输入mysql<br><img src="/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/navicate-soule-mysql.png" alt></p>
<p>3.右键refresh一下即可见到刚才新建的表tbl_user<br><img src="/2020/02/12/Navicat%E4%BD%BF%E7%94%A8%E8%B5%84%E6%96%99/tbl_user.png" alt></p>
<h3 id="通过navicat连接MySQL"><a href="#通过navicat连接MySQL" class="headerlink" title="通过navicat连接MySQL"></a>通过navicat连接MySQL</h3><p>创建数据库时，一般字符集选择utf8，排序规则选择utf8_general_ci </p>
<p><a href="https://zhuanlan.zhihu.com/p/44348694" target="_blank" rel="noopener">在Navicat中如何新建数据库和表并做查询</a><br><a href="https://www.navicat.com.cn/manual/online_manual/cn/navicat/win_manual/index.html#/about_0" target="_blank" rel="noopener">Navicat使用手册</a> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中通过Docker安装配置MySQL主从节点</title>
    <url>/2020/02/09/Ubuntu%E4%B8%AD%E9%80%9A%E8%BF%87Docker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="1-拉取MySQL5-7镜像到本地"><a href="#1-拉取MySQL5-7镜像到本地" class="headerlink" title="1.拉取MySQL5.7镜像到本地"></a>1.拉取MySQL5.7镜像到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你只需要跑一个mysql实例，不做主从，那么执行以下命令即可，不用再做后面的参考步骤: docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 </span></span><br><span class="line"><span class="comment"># 然后用shell或客户端软件通过配置( 用户名:root 密码:132456 IP:你的本机ip 端口:3306)来登录即可</span></span><br></pre></td></tr></table></figure>

<h3 id="2-准备MySQL的配置文件"><a href="#2-准备MySQL的配置文件" class="headerlink" title="2.准备MySQL的配置文件"></a>2.准备MySQL的配置文件</h3><p>MySQL5.7安装之后的默认配置文件在/etc/mysql/my.cnf，而自定义的配置文件一般放在/etc/mysql/config.d这个路径下。<br>在本地host主机上自定义的某个目录下（如/data/mysql/conf/），先创建两个文件master.conf和slave.conf，分别用于配置主从两个节点。</p>
<ul>
<li>/data/mysql/conf/master.conf<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysqld] </span><br><span class="line">log_bin = <span class="built_in">log</span> <span class="comment">#开启二进制日志，用于从节点的历史复制回放 </span></span><br><span class="line">collation-server = utf8_unicode_ci </span><br><span class="line">init-connect=<span class="string">'SET NAMES utf8'</span> </span><br><span class="line">character-set-server = utf8 </span><br><span class="line">server_id = 1 <span class="comment">#需保证主库和从库的server_id不同， 假设主库设为1 </span></span><br><span class="line">replicate-do-db=fileserver <span class="comment">#需要复制的数据库名，需复制多个数据库的话则重复设置这个选项</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>/data/mysql/conf/slave.conf<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysqld] </span><br><span class="line">log_bin = <span class="built_in">log</span> <span class="comment">#开启二进制日志，用于从节点的历史复制回放 </span></span><br><span class="line">collation-server = utf8_unicode_ci </span><br><span class="line">init-connect=<span class="string">'SET NAMES utf8'</span> </span><br><span class="line">character-set-server = utf8 </span><br><span class="line">server_id = 2 <span class="comment">#需保证主库和从库的server_id不同， 假设从库设为2 </span></span><br><span class="line">replicate-do-db=fileserver <span class="comment">#需要复制的数据库名，需复制多个数据库的话则重复设置这个选项</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-Docker分别运行MySQL主-从两个容器"><a href="#3-Docker分别运行MySQL主-从两个容器" class="headerlink" title="3. Docker分别运行MySQL主/从两个容器"></a>3. Docker分别运行MySQL主/从两个容器</h3><p>将mysql主节点运行起来 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/mysql/datam </span><br><span class="line">docker run -d --name mysql-master -p 13306:3306 -v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /data/mysql/datam:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>
<p>运行参数说明:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">–name mysql-master: 容器的名称设为mysql-master </span><br><span class="line">-p 13306:3306: 将host的13306端口映射到容器的3306端口 </span><br><span class="line">-v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf ： master.conf配置文件挂载 </span><br><span class="line">-v /data/mysql/datam:/var/lib/mysql ： mysql容器内数据挂载到host的/data/mysql/datam， 用于持久化 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 : mysql的root登录密码为123456</span><br></pre></td></tr></table></figure>

<p> 将mysql从节点运行起来<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/mysql/datas </span><br><span class="line">docker run -d --name mysql-slave -p 13307:3306 -v /data/mysql/conf/slave.conf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /data/mysql/datas:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure></p>
<p> 运行参数说明: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">–name mysql-slave: 容器的名称设为mysql-slave </span><br><span class="line">-p 13307:3306: 将host的13307端口映射到容器的3306端口 </span><br><span class="line">-v /data/mysql/conf/master.conf:/etc/mysql/mysql.conf.d/mysqld.cnf ： master.conf配置文件挂载</span><br><span class="line">-v /data/mysql/datam:/var/lib/mysql ： mysql容器内数据挂载到host的/data/mysql/datam， 用于持久化 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 : mysql的root登录密码为123456</span><br></pre></td></tr></table></figure>

<h3 id="4-登录MySQL主节点配置同步信息"><a href="#4-登录MySQL主节点配置同步信息" class="headerlink" title="4.登录MySQL主节点配置同步信息"></a>4.登录MySQL主节点配置同步信息</h3><p>宿主机安装mysql客户端 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y mysql-client</span><br></pre></td></tr></table></figure>

<p>登录mysql </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.1.xx 是你本机的内网ip </span></span><br><span class="line">mysql -u root -h 192.168.1.xx -P13306 -p123456</span><br></pre></td></tr></table></figure>

<p>在mysql client中执行 (创建用于访问主节点来同步数据的帐号) </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create user slave identified by <span class="string">'slave'</span>; </span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'slave'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'slave'</span>; </span><br><span class="line">mysql&gt; flush privileges; </span><br><span class="line">mysql&gt; create database fileserver default character <span class="built_in">set</span> utf8mb4;</span><br></pre></td></tr></table></figure>
<p>再获取status, 得到类似如下的输出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status\G; </span><br><span class="line">*************************** 1. row *************************** </span><br><span class="line">File: log.000025 </span><br><span class="line">Position: 155 Binlog_Do_DB: </span><br><span class="line">Binlog_Ignore_DB: </span><br><span class="line">Executed_Gtid_Set: 1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>


<h3 id="5-登录MySQL从节点配置同步信息"><a href="#5-登录MySQL从节点配置同步信息" class="headerlink" title="5.登录MySQL从节点配置同步信息"></a>5.登录MySQL从节点配置同步信息</h3><ul>
<li><p>查看mysql master的容器独立ip地址 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> mysql-master </span><br><span class="line"><span class="comment"># 比如输出得到: 172.17.0.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另开一个tab登录mysql </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.1.xx 是你本机的内网ip </span></span><br><span class="line">mysql -u root -h 192.168.1.xx -P13307 -p123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>在mysql client中操作: </p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave; </span><br><span class="line">mysql&gt; create database fileserver default character <span class="built_in">set</span> utf8mb4; </span><br><span class="line"><span class="comment">#注意其中的日志文件和数值要和上面show master status的值对应 </span></span><br><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST=<span class="string">'前两个步骤中获得的mysql master ip'</span>,MASTER_PORT=3306,MASTER_USER=<span class="string">'slave'</span>,MASTER_PASSWORD=<span class="string">'slave'</span>,MASTER_LOG_FILE=<span class="string">'log.000025'</span>,MASTER_LOG_POS=155; </span><br><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure>

<p>再获取status, 正常应该得到类似如下的输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status \G; </span><br><span class="line">// ... </span><br><span class="line">Slave_IO_Running: Yes </span><br><span class="line">Slave_SQL_Running: Yes </span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>



<p>到这时说明主从配置已经完成，可以尝试在主mysql的fileserver数据库里建表操作下，然后在从节点上检查数据是否已经同步过来。</p>
<h3 id="几个指令"><a href="#几个指令" class="headerlink" title="几个指令"></a>几个指令</h3><p><code>sudo netstat -antup -antup | grep docker</code> 查看docker占用端口<br><code>ifconfig</code> 查看本机ip</p>
<h3 id="通过docker-compose方式实现"><a href="#通过docker-compose方式实现" class="headerlink" title="通过docker compose方式实现"></a>通过docker compose方式实现</h3><p><a href="https://github.com/mayinghan/mysql-master-slave-service" target="_blank" rel="noopener">https://github.com/mayinghan/mysql-master-slave-service</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Docker启动MySQL容器</title>
    <url>/2019/12/20/%E9%80%9A%E8%BF%87docker%E5%90%AF%E5%8A%A8mysql%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>拉取mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<p>在后台启动mysql容器(–name指定了容器的名称，方便之后进入容器的命令行，MYSQL_ROOT_PASSWORD=hls123指定了mysql的root密码，-d表示在后台运行)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --name=mysql -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>

<p>进入容器bash并进入mysql命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br></pre></td></tr></table></figure>
<p>验证容器状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>



<p>创建mysql容器 1master+1个slave</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=mysql-master -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>

<p>–name 为容器指定名称，这里是mysql-master</p>
<p>-p 将容器的指定端口映射到主机的指定端口，这里是将容器的3306端口映射到主机的3306端口</p>
<p>-e 设置环境变量，这里是指定root账号的密码为hls123</p>
<p>-d 后台运行容器，并返回容器ID</p>
<p>docker run –name=mysql-master -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql:[版本号]<br>mysql:版本号 指定运行的mysql版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=mysql-slave1 -it -p 3307:3306 -e MYSQL_ROOT_PASSWORD=hls123 -d mysql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习</title>
    <url>/2019/12/11/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>安装<br>1.通过<a href="官网">wwww.docker.com</a>下载桌面版docker<br>2.<a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">配置Docker镜像站</a><br>3.执行<code>docker run hello-world</code>，看输出完美运行～</p>
<p>基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>常用操作</p>
<p>拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//下载官方nginx镜像源，等同于docker pull docker.io/nginx</span><br><span class="line">//也等同于docker pull docker.io/nginx.io/nginx:latest</span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//下载国内镜像源的ubuntu镜像，并制定版本</span><br><span class="line">docker pull registry.docker-cn.com/library/ubuntu:18.04</span><br></pre></td></tr></table></figure>

<p>推送镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//推送镜像到docker hub,需要先注册账号</span><br><span class="line">docker push &lt;你的用户名&gt;/&lt;你打包时定义的镜像名&gt;:&lt;标签，版本号&gt;</span><br><span class="line"></span><br><span class="line">//推送镜像到私有镜像库，需要提前搭建好仓库服务（比如用harbor来搭建）</span><br><span class="line">docker push &lt;私有镜像库域名，如a.b.com&gt;/&lt;项目名称&gt;/镜像名:&lt;标签&gt;</span><br></pre></td></tr></table></figure>

<p>打包镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//提前准备好一个Dockerfile，在Dockerfile相同路径下执行：</span><br><span class="line">docker build -t &lt;指定一个完整的镜像名，比如testdemo:v1.0&gt;</span><br><span class="line">//即可打包出一个本地镜像，然后再通过docker push 就可以推送到远端镜像仓库</span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d //-d 表示通过daemon方式来启动</span><br><span class="line">-p 13306:3306 //端口映射，将host主机的13306端口和docker容器的3306端口映射起来</span><br><span class="line">-v /etc/mysql:/var/mysql //目录挂载，将容器内的/var/mysql目录挂载到host主机的/etc/mysql目录，可以实现容器内这个目录下的数据持久化，mysql为镜像名（指定加载哪个镜像）</span><br></pre></td></tr></table></figure>

<p>重启或停止或删除容器应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps  //列出目前正在运行的容器列表</span><br><span class="line">docker ps -a //列出所有的容器列表</span><br><span class="line">docker start &lt;容器id&gt;  //通过容器id来重启某个容器，批量操作的话，直接在参数后面再跟对应容器id即可</span><br><span class="line">docker stop &lt;容器id&gt;  //通过容器id来关闭某个容器，批量操作的话，直接在参数后面再跟对应容器id即可</span><br><span class="line">docker rm &lt;容器id&gt;  //通过容器id来删除掉某个已经停止的容器</span><br><span class="line">docker rm -f &lt;容器id&gt;  //通过容器id来删除掉某个正在运行的容器</span><br><span class="line">docker container rm  [trusting_newton]</span><br></pre></td></tr></table></figure>

<p>删除本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmo &lt;镜像id&gt;</span><br><span class="line">docker rmi -f &lt;镜像id&gt; //强制删除</span><br></pre></td></tr></table></figure>

<p>查看容器日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f &lt;容器id&gt;</span><br><span class="line">docker inspect &lt;容器id&gt; //从返回结果中找到LogPath,运行的历史日志会在这个文件里找到</span><br></pre></td></tr></table></figure>

<p>进入容器内</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt;  /bin/bash  //进入容器内并进入它的shell终端</span><br><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt; &lt;shell命令&gt;  //在容器内执行shell命令</span><br><span class="line">docker  <span class="built_in">exec</span>  -it &lt;容器id&gt; ls -l        //查看容器内系统跟目录下所有文件或文件夹</span><br><span class="line"><span class="comment"># 进入容器后，可以直接通过exit命令推出容器</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器Linux下安装Docker社区版-Centos7为例"><a href="#服务器Linux下安装Docker社区版-Centos7为例" class="headerlink" title="服务器Linux下安装Docker社区版(Centos7为例)"></a>服务器Linux下安装Docker社区版(Centos7为例)</h3><ul>
<li>yum源使用阿里云的源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"><span class="comment"># 下载阿里云的yum源</span></span><br><span class="line">wget http<span class="string">"mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="string">mv CentOS-Base.repo CentOS-Base.repo.back</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mv Centos-7.repo CentOS-Base.repo</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重置yum源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo http://mirros.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装docker</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看阿里云上docker 源信息</span></span><br><span class="line">yum list docker-ce</span><br><span class="line"><span class="comment">#安装docker最新社区版</span></span><br><span class="line">yum -y install docker-ce</span><br><span class="line"><span class="comment">#查看docker信息</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment">#查看docker详细状态信息</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>








<p>参考资料<br><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">Docker — 从入门到实践</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2019/12/11/ElasticSearch/</url>
    <content><![CDATA[<p>ElasticSearch：全文搜索引擎，它可以快速存储，搜索和分析海量数据，用户包括：维基百科、Stack Overflow、GitHub</p>
<p>特点：不需要简表，配置字段等；只需要存json的文档；</p>
<p>通过docker安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span> docker.elastic.co/elasticsearch/elasticsearch:7.5.0</span><br></pre></td></tr></table></figure>

<p>安装成功之后访问<code>http://localhost:9200/</code>即可见到对应信息</p>
<p>链接参考<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html" target="_blank" rel="noopener">docker安装ElasticSearch</a></p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang云存储实战</title>
    <url>/2019/12/10/Golang%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="3mysql"><a href="#3mysql" class="headerlink" title="3mysql"></a>3mysql</h3><p>数据库分表<br>水平分表：假设分成256张文件表，按文件Sha1值后两位来切分，则以：tb_${FILE_SHA1}[:-2]的规则到对应表进行存取。</p>
<p>// OnFileUploadFinished : 文件上传完成，保存meta （插入）<br>// GetFileMeta : 从mysql获取文件元信息（查询）<br>// UpdateFileLocation : 更新文件的存储地址(如文件被转移了)  （更新）<br>涉及源码：db(file.go   mysql(conn.go))</p>
<p>使用MySQL小结：<br>通过sql.DB来管理数据连接对象<br>通过sql.Open来创建协程安全的sql.DB<br>优先使用Prepared Statement</p>
<h3 id="4-1用户系统用户表设计-注册和登录"><a href="#4-1用户系统用户表设计-注册和登录" class="headerlink" title="4-1用户系统用户表设计(注册和登录)"></a>4-1用户系统用户表设计(注册和登录)</h3><p>由于原有情况下,唯一索引用在了字段phone上. 而当前插入表的sql语句中, user_name才是应该要保持唯一的, 因此相对于视频所演示的建表语句进行了更新, 具体如下: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tbl_user` ( </span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT, </span><br><span class="line">    `user_name` varchar(64) NOT NULL DEFAULT <span class="string">''</span> COMMENT <span class="string">'用户名'</span>, </span><br><span class="line">    `user_pwd` varchar(256) NOT NULL DEFAULT <span class="string">''</span> COMMENT <span class="string">'用户encoded密码'</span>, </span><br><span class="line">    `email` varchar(64) DEFAULT <span class="string">''</span> COMMENT <span class="string">'邮箱'</span>, </span><br><span class="line">    `phone` varchar(128) DEFAULT <span class="string">''</span> COMMENT <span class="string">'手机号'</span>, </span><br><span class="line">    `email_validated` tinyint(1) DEFAULT 0 COMMENT <span class="string">'邮箱是否已验证'</span>, </span><br><span class="line">    `phone_validated` tinyint(1) DEFAULT 0 COMMENT <span class="string">'手机号是否已验证'</span>, </span><br><span class="line">    `signup_at` datetime DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'注册日期'</span>, </span><br><span class="line">    `last_active` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">'最后活跃时间戳'</span>, </span><br><span class="line">    `profile` text COMMENT <span class="string">'用户属性'</span>, </span><br><span class="line">    `status` int(11) NOT NULL DEFAULT <span class="string">'0'</span> COMMENT <span class="string">'账户状态(启用/禁用/锁定/标记删除等)'</span>, </span><br><span class="line">    PRIMARY KEY (`id`), </span><br><span class="line">    UNIQUE KEY `idx_username` (`user_name`), </span><br><span class="line">    KEY `idx_status` (`status`) </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>

<p>登录<br>// 1. 校验用户名及密码<br>// 2. 生成访问凭证(token)<br>// 3. 登录成功后重定向到首页<br>涉及源码：<br>db(user.go )<br>handle(user.go)</p>
<p>访问鉴权（验证token的拦截器）<br>handler(auth.go)</p>
<h3 id="5-hash算法对比以及秒传原理"><a href="#5-hash算法对比以及秒传原理" class="headerlink" title="5.hash算法对比以及秒传原理"></a>5.hash算法对比以及秒传原理</h3><h3 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6.Redis"></a>6.Redis</h3><p>分块上传与断点续传<br>分块上传：文件切成多块，独立上传，上传完成后合并（初始化上传-&gt;上传分块（并行）-&gt;通知上传完成）<br>断点续传：传输暂停或一场终端后，可基于原来进度重传</p>
<p>小文件不建议分块上传<br>可以并行上传分块，并且可以无序传输<br>分块上传能极大提高传输效率<br>减少传输失败后重试的流量和时间</p>
<p>初始化分块信息<br>上传分块<br>通知分块上传完成<br>取消上传分块<br>查看分块上传的整体状态</p>
<p>涉及源码：<br>cache(redis(conn.go))</p>
<p>handler(mpupload.go)</p>
<h3 id="7-Ceph"><a href="#7-Ceph" class="headerlink" title="7.Ceph"></a>7.Ceph</h3><p>Ceph:redhat开源出来的分布式存储系统</p>
<h3 id="8-阿里云对象存储OSS"><a href="#8-阿里云对象存储OSS" class="headerlink" title="8.阿里云对象存储OSS"></a>8.阿里云对象存储OSS</h3><h3 id="9-RabbitMQ"><a href="#9-RabbitMQ" class="headerlink" title="9.RabbitMQ"></a>9.RabbitMQ</h3><p>RabbitMQ:一种开源的消息代理</p>
<h3 id="10-微服务"><a href="#10-微服务" class="headerlink" title="10.微服务"></a>10.微服务</h3><p><img src="/2019/12/10/Golang%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" alt="微服务架构图"></p>
<h4 id="基于gin改造用户service"><a href="#基于gin改造用户service" class="headerlink" title="基于gin改造用户service"></a>基于gin改造用户service</h4><h4 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h4><h3 id="源码说明"><a href="#源码说明" class="headerlink" title="源码说明:"></a>源码说明:</h3><ul>
<li>master分支: 通过原生net/http实现各接口功能</li>
<li>gin分支: 通过Gin框架来改造(微服务化章节之后主要基于Gin框架来进行演示)</li>
<li>pkg分支: 通过go-bindata等工具实现静态资源打包的一个示例</li>
<li>第九章(RabbitMQ异步存储)章节的代码，可以下载标签为<code>v0.3</code>的版本</li>
<li>第八章(OSS)及之前章节的代码，可以下载标签为<code>v0.2</code>的版本</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>Go入门: <a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="noopener">语言之旅</a></li>
<li>MySQL: <a href="https://chhy2009.github.io/document/mysql-reference-manual.pdf" target="_blank" rel="noopener">偶然翻到的一位大牛翻译的使用手册</a></li>
<li>Redis: <a href="http://redisdoc.com/" target="_blank" rel="noopener">命令手册</a></li>
<li>Ceph: <a href="http://ceph.org.cn/" target="_blank" rel="noopener">中文社区</a> <a href="http://docs.ceph.org.cn/" target="_blank" rel="noopener">中文文档</a></li>
<li>RabbitMQ: <a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">英文官方</a> <a href="http://rabbitmq.mr-ping.com/" target="_blank" rel="noopener">一个中文版文档</a></li>
<li>阿里云OSS: <a href="https://help.aliyun.com/product/31815.html?spm=a2c4g.750001.3.1.47287b13LQI3Ah" target="_blank" rel="noopener">文档首页</a></li>
<li>gRPC: <a href="http://doc.oschina.net/grpc?t=56831" target="_blank" rel="noopener">官方文档中文版</a></li>
<li>k8s: <a href="https://www.kubernetes.org.cn/docs" target="_blank" rel="noopener">中文社区</a></li>
<li>我的手记博客 <a href="http://www.imooc.com/u/6198190" target="_blank" rel="noopener">http://www.imooc.com/u/6198190</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>AFN表单形式提交图片</title>
    <url>/2019/11/15/AFN%E8%A1%A8%E5%8D%95%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BA%A4%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>PromiseKit</title>
    <url>/2019/11/05/PromiseKit/</url>
    <content><![CDATA[<h1 id="then-and-done"><a href="#then-and-done" class="headerlink" title="then and done"></a><code>then</code> and <code>done</code></h1><p>典型使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这段代码使用了<code>completion handlers</code>，它将如下所示:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> creds = creds &#123;</span><br><span class="line">        fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> image = image &#123;</span><br><span class="line">                <span class="keyword">self</span>.imageView = image</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>then</code> 只是构造<code>completion handlers</code>的另一种方式, 但也远不止如此。在我们理解的最初阶段，它主要有助于可读性。上面的<code>promise链</code>很容易浏览和理解:一个异步操作一行一行地通向另一个。鉴于Swift的当前状态，它尽可能接近程序代码。</p>
<p><code>done</code> 和 <code>then</code> ，但是你不能返回一个<code>promise</code>. 这通常是链条中<code>success</code>部分的终点. 上面, 您可以看到我们在 <code>done</code> 时收到了最终的图像，并使用它来设置用户界面。</p>
<p>两种实现方法的比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Creds</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Compared with:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(completion: <span class="params">(Creds?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">                        <span class="comment">// ^^ ugh. Optionals. Double optionals.</span></span><br></pre></td></tr></table></figure>

<p>区别在于，对于<code>Promise</code>，您的函数返回<code>Promise</code>，而不是接受和运行回调。链中的每个<code>handler</code>都会返回一个<code>Promise</code>。<code>Promise</code>对象定义了<code>then</code>方法，该方法在链的执行之前等待<code>Promise</code>的完成。锁链按程序解决，一次一个<code>Promise</code>。</p>
<p><code>Promise</code> 代表异步任务的返回值。它有一个表示它包装的对象类型的类型。例如，在上面的例子中，<code>login</code>是一个返回<code>Promise</code>的函数，该<code>Promise</code>将代表Creds实例。</p>
<blockquote>
<p><em>Note</em>: <code>done</code> is new to PromiseKit 5. We previously defined a variant of <code>then</code> that<br>did not require you to return a promise. Unfortunately, this convention often confused<br>Swift and led to odd and hard-to-debug error messages. It also made using PromiseKit<br>more painful. The introduction of <code>done</code> lets you type out promise chains that<br>compile without additional qualification to help the compiler figure out type information.</p>
</blockquote>
<hr>
<p>您可能会注意到，与completion模式不同，promise链似乎<br>忽略errors。事实并非如此！事实上，它有相反的效果:promise<br>链使得errors处理更容易访问，也使得errors更难忽略。</p>
<h1 id="catch"><a href="#catch" class="headerlink" title="catch"></a><code>catch</code></h1><p>有了promise，errors就会沿着promise链级联，确保你的应用程序<br>健壮，代码清晰:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    login()</span><br><span class="line">&#125;.then &#123; creds <span class="keyword">in</span></span><br><span class="line">    fetch(avatar: creds.user)</span><br><span class="line">&#125;.done &#123; image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.imageView = image</span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// any errors in the whole chain land here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Swift emits a warning if you forget to <code>catch</code> a chain. But we’ll<br>talk about that in more detail later.</p>
</blockquote>
<p>每个promise都是一个对象，代表一个单独的异步任务。<br>如果任务失败， promise就会变成rejected。 Chains that contain rejected<br>包含rejected的promise链跳过所有后续的promise。相反，执行下一个捕获。<br>(严格来说，所有后续的捕获处理程序都会被执行。)</p>
<p><code>completion handler</code>与<code>promise</code>的比较</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>guard</code>和<code>error handler</code>的使用有所帮助，但是promise链<br>可读性不言自明。</p>
<h1 id="ensure"><a href="#ensure" class="headerlink" title="ensure"></a><code>ensure</code></h1><p>我们已经学会了合成异步性。接下来，让我们扩展:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> login()</span><br><span class="line">&#125;.then &#123;</span><br><span class="line">    fetch(avatar: $<span class="number">0</span>.user)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView = $<span class="number">0</span></span><br><span class="line">&#125;.ensure &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管你的链条的结果是什么——失败还是成功 <code>ensure</code><br>handler 总是被调用.</p>
<p><code>ensure</code>模式与其等价的完成处理程序进行比较:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Error)</span></span> &#123;</span><br><span class="line">    <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login &#123; creds, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> creds = creds <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">    fetch(avatar: creds.user) &#123; image, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123; <span class="keyword">return</span> handle(error: error!) &#125;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">        <span class="type">UIApplication</span>.shared.isNetworkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对某人来说，修改这个代码并忘记取消设置是非常容易的<br>导致错误的活动指示器。有了promises，这种类型的错误是<br>几乎不可能:Swift编译器拒绝你在没有<br>使用promises。您几乎不需要审查拉动式请求。</p>
<blockquote>
<p><em>Note</em>: PromiseKit has perhaps capriciously switched between the names <code>always</code><br>and <code>ensure</code> for this function several times in the past. Sorry about this. We suck.</p>
</blockquote>
<p>You can also use <code>finally</code> as an <code>ensure</code> that terminates the promise chain and does not return a value:<br>您也可以使用<code>finally</code>作为结束的promise链且不返回值的<code>ensure</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spinner(visible: true)</span><br><span class="line"></span><br><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.catch &#123;</span><br><span class="line">    //…</span><br><span class="line">&#125;.finally &#123;</span><br><span class="line">    self.spinner(visible: false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h1><p>对多个异步操作的completion handlers反应是缓慢的，意味着连续执行:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operation1 &#123; result1 <span class="keyword">in</span></span><br><span class="line">    operation2 &#123; result2 <span class="keyword">in</span></span><br><span class="line">        finish(result1, result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速(<em>parallel</em>)路径代码使代码不太清晰</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result1: …!</span><br><span class="line"><span class="keyword">var</span> result2: …!</span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">group.enter()</span><br><span class="line">group.enter()</span><br><span class="line">operation1 &#123;</span><br><span class="line">    result1 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">operation2 &#123;</span><br><span class="line">    result2 = $<span class="number">0</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    finish(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用Promises就更清晰了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    when(fulfilled: operation1(), operation2())</span><br><span class="line">&#125;.done &#123; result1, result2 <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>when</code> promise代表：等待它们解决并返回包含结果的promise。</p>
<p>与任何promise链一样，如果任何组件promise失败，该链将调用下一个<code>catch</code>。</p>
<h1 id="PromiseKit-Extensions"><a href="#PromiseKit-Extensions" class="headerlink" title="PromiseKit Extensions"></a>PromiseKit Extensions</h1><p>当我们使用PromiseKit, 我们是想想通过promise来实现<br>异步行为。因此，只要有可能，我们会对苹果的APIs进行扩展，重新构建<br>promise方面的应用编程接口。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">CLLocationManager</span>.promise()</span><br><span class="line">&#125;.then &#123; location <span class="keyword">in</span></span><br><span class="line">    <span class="type">CLGeocoder</span>.reverseGeocode(location)</span><br><span class="line">&#125;.done &#123; placemarks <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.placemark.text = <span class="string">"\(placemarks.first)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用这些扩展，您需要指定子代码:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">"PromiseKit"</span></span><br><span class="line">pod <span class="string">"PromiseKit/CoreLocation"</span></span><br><span class="line">pod <span class="string">"PromiseKit/MapKit"</span></span><br></pre></td></tr></table></figure>

<p>All of these extensions are available at the <a href="https://github.com/PromiseKit" target="_blank" rel="noopener">PromiseKit organization</a>.<br>Go there to see what’s available and to read the source code and documentation. Every file and function<br>has been copiously documented.</p>
<blockquote>
<p>We also provide extensions for common libraries such as <a href="https://github.com/PromiseKit/Alamofire-" target="_blank" rel="noopener">Alamofire</a>.</p>
</blockquote>
<h1 id="Making-Promises"><a href="#Making-Promises" class="headerlink" title="Making Promises"></a>Making Promises</h1><p>The standard extensions will take you a long way, but sometimes you’ll still need to start chains<br>of your own. Maybe you’re using a third party API that doesn’t provide promises, or perhaps you wrote<br>your own asynchronous system. Either way, it’s easy to add promises. If you look at the code of the<br>standard extensions, you’ll see that it uses the same approach  described below.</p>
<p>标准的扩展会让你走很长一段路，但是有时候你仍然需要启动链<br>你自己的。也许你使用的是不提供promises的第三方应用编程接口，或者你写道<br>你自己的异步系统。不管怎样，添加promises都很容易。如果你看看<br>标准扩展，您会看到它使用了下面描述的相同方法。</p>
<p>Let’s say we have the following method:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(completion: <span class="params">(String?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>

<p>How do we convert this to a promise? Well, it’s easy:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; fetch(completion: $<span class="number">0</span>.resolve) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You may find the expanded version more readable:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result, error <span class="keyword">in</span></span><br><span class="line">            seal.resolve(result, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>seal</code> object that the <code>Promise</code> initializer provides to you defines<br>many methods for handling garden-variety completion handlers. It even<br>covers a variety of rarer situations, thus making it easy for you to add<br>promises to an existing codebase.</p>
<blockquote>
<p><em>Note</em>: We tried to make it so that you could just do <code>Promise(fetch)</code>, but we<br>were not able to make this simpler pattern work universally without requiring<br>extra disambiguation for the Swift compiler. Sorry; we tried.</p>
</blockquote>
<blockquote>
<p><em>Note</em>: In PMK 4, this initializer provided two parameters to your closure:<br><code>fulfill</code> and <code>reject</code>. PMK 5 and 6 give you an object that has both <code>fulfill</code> and<br><code>reject</code> methods, but also many variants of the method <code>resolve</code>. You can<br>typically just pass completion handler parameters to <code>resolve</code> and let Swift figure<br>out which variant to apply to your particular case (as shown in the example above).</p>
</blockquote>
<blockquote>
<p><em>Note</em> <code>Guarantees</code> (below) have a slightly different initializer (since they<br>cannot error) so the parameter to the initializer closure is just a closure. Not<br>a <code>Resolver</code> object. Thus do <code>seal(value)</code> rather than <code>seal.fulfill(value)</code>. This<br>is because there is no variations in what guarantees can be sealed with, they can<br><em>only</em> fulfill.</p>
</blockquote>
<h1 id="Guarantee-lt-T-gt"><a href="#Guarantee-lt-T-gt" class="headerlink" title="Guarantee&lt;T&gt;"></a><code>Guarantee&lt;T&gt;</code></h1><p>Since PromiseKit 5, we have provided <code>Guarantee</code> as a supplementary class to<br><code>Promise</code>. We do this to complement Swift’s strong error handling system.</p>
<p>Guarantees <em>never</em> fail, so they cannot be rejected. A good example is <code>after</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    after(seconds: 0.1)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    // there is no way to add a `catch` because after cannot fail.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift warns you if you don’t terminate a regular <code>Promise</code> chain (i.e., not<br>a <code>Guarantee</code> chain). You’re expected to silence this warning by supplying<br>either a <code>catch</code> or a <code>return</code>. (In the latter case, you will then have to <code>catch</code><br>at the point where you receive that promise.)</p>
<p>Use <code>Guarantee</code>s wherever possible so that your code has error handling where<br>it’s required and no error handling where it’s not required.</p>
<p>In general, you should be able to use <code>Guarantee</code>s and <code>Promise</code>s interchangeably,<br>We have gone to great lengths to try and ensure this, so please open a ticket<br>if you find an issue.</p>
<hr>
<p>If you are creating your own guarantees the syntax is simpler than that of promises;</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span> &#123; seal <span class="keyword">in</span></span><br><span class="line">        fetch &#123; result <span class="keyword">in</span></span><br><span class="line">            seal(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which could be reduced to:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Guarantee</span>(resolver: fetch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map-compactMap-etc"><a href="#map-compactMap-etc" class="headerlink" title="map, compactMap, etc."></a><code>map</code>, <code>compactMap</code>, etc.</h1><p><code>then</code> provides you with the result of the previous promise and requires you to return<br>another promise.</p>
<p><code>map</code> provides you with the result of the previous promise and requires you to return<br>an object or value type.</p>
<p><code>compactMap</code> provides you with the result of the previous promise and requires you<br>to return an <code>Optional</code>. If you return <code>nil</code>, the chain fails with<br><code>PMKError.compactMap</code>.</p>
<blockquote>
<p><em>Rationale</em>: Before PromiseKit 4, <code>then</code> handled all these cases, and it was<br>painful. We hoped the pain would disappear with new Swift versions. However,<br>it has become clear that the various pain points are here to stay. In fact, we<br>as library authors are expected to disambiguate at the naming level of our API.<br>Therefore, we have split the three main kinds of <code>then</code> into <code>then</code>, <code>map</code> and<br><code>done</code>. After using these new functions, we realized this is much nicer in practice,<br>so we added <code>compactMap</code> as well (modeled on <code>Optional.compactMap</code>).</p>
</blockquote>
<p><code>compactMap</code> facilitates quick composition of promise chains. For example:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    <span class="type">URLSession</span>.shared.dataTask(.promise, with: rq)</span><br><span class="line">&#125;.compactMap &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject($<span class="number">0</span>.data) <span class="keyword">as</span>? [<span class="type">String</span>]</span><br><span class="line">&#125;.done &#123; arrayOfStrings <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// Foundation.JSONError if JSON was badly formed</span></span><br><span class="line">    <span class="comment">// PMKError.compactMap if JSON was of different type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>Tip</em>: We also provide most of the functional methods you would expect for sequences,<br>e.g., <code>map</code>, <code>thenMap</code>, <code>compactMapValues</code>, <code>firstValue</code>, etc.</p>
</blockquote>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h1><p>We provide <code>get</code> as a <code>done</code> that returns the value fed to <code>get</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.<span class="keyword">get</span> &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.done &#123; foo <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// same foo!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="tap"><a href="#tap" class="headerlink" title="tap"></a><code>tap</code></h1><p>We provide <code>tap</code> for debugging. It’s the same as <code>get</code> but provides the<br><code>Result&lt;T&gt;</code> of the <code>Promise</code> so you can inspect the value of the chain at this<br>point without causing any side effects:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">firstly &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;.tap &#123;</span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;.done &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Supplement"><a href="#Supplement" class="headerlink" title="Supplement"></a>Supplement</h1><h2 id="firstly"><a href="#firstly" class="headerlink" title="firstly"></a><code>firstly</code></h2><p>We’ve used <code>firstly</code> several times on this page, but what is it, really? In fact,<br>it is just <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener">syntactic sugar</a>.<br>You don’t really need it, but it </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>PromiseKit</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/11/04/Vue/</url>
    <content><![CDATA[<h1 id="Vue初体验"><a href="#Vue初体验" class="headerlink" title="Vue初体验"></a>Vue初体验</h1><p><a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">Vue官网</a></p>
<p>在教程安装里给出了多种引入方式，具体<a href="[教程安装]（https://cn.vuejs.org/v2/guide/installation.html）">点击这里</a></p>
<h2 id="直接-lt-script-gt-引入"><a href="#直接-lt-script-gt-引入" class="headerlink" title="直接&lt;/script&gt;引入"></a>直接<code>&lt;/script&gt;</code>引入</h2><p>在编辑器上输入html回车，这时候就会自动补全以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>引入 Vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p> 在页面输出hello Vue,用浏览器打开文件并检验效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;hello Vue&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>可以之后我们改造源文件让它与Vue产生关联：new 一个Vue实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,  //挂载到指定节点上</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &apos;Hello Vue!&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>所挂载的节点需要添加一个id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>最终源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,  //挂载到指定节点上</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &apos;Hello Vue!&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>此时用浏览器打开即可见到显示Hello Vue!</p>
<p>参考官方demo <a href="https://scrimba.com/p/pXKqta/cQ3QVcr" target="_blank" rel="noopener">链接</a></p>
<h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><p>添加显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;addMethod&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot; v-model=&quot;info&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;button&quot; name=&quot;button&quot; @click=&quot;handleClick&quot;&gt;add&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>v-model是Vue里面的双向绑定，</li>
<li>v-for是循环遍历</li>
<li>@click=”handleClick” 绑定方法</li>
<li>console.log(this.info) 打印信息，如何查看打印输出：浏览器-右键-检查-Console</li>
<li>handleClick方法生命在methods对象里面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &lt;div class=&quot;addMethod&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot; v-model=&quot;info&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;button&quot; name=&quot;button&quot; @click=&quot;handleClick&quot;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,  //挂载到指定节点上</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &apos;Hello Vue!&apos;,</span><br><span class="line">        info: &apos;&apos;,</span><br><span class="line">        list:[],</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick()&#123;</span><br><span class="line">          //console</span><br><span class="line">          this.list.push(this.info)</span><br><span class="line">          this.info = &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用自定义组件"><a href="#使用自定义组件" class="headerlink" title="使用自定义组件"></a>使用自定义组件</h2><p>定义名为 todo-item 的新组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;todo-item&apos;,&#123;</span><br><span class="line">      props:[&apos;item&apos;],</span><br><span class="line">      template: &apos;&lt;li class=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建一个 todo-item 组件的实例，并传递属性值 <code>v-bind:item=&quot;item&quot;</code>或者简写成<code>:item=&quot;item&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;todo-item v-for=&quot;item in list&quot; :item=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/todo-item&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style media=&quot;screen&quot;&gt;</span><br><span class="line">      .item &#123;</span><br><span class="line">        color:red;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    &lt;div class=&quot;addMethod&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot; v-model=&quot;info&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;button&quot; name=&quot;button&quot; @click=&quot;handleClick&quot;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;todo-item v-for=&quot;item in list&quot; :item=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/todo-item&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    Vue.component(&apos;todo-item&apos;,&#123;</span><br><span class="line">      props:[&apos;item&apos;],</span><br><span class="line">      template: &apos;&lt;li class=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,  //挂载到指定节点上</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &apos;Hello Vue!&apos;,</span><br><span class="line">        info: &apos;&apos;,</span><br><span class="line">        list:[],</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick()&#123;</span><br><span class="line">          console.log(this.info)</span><br><span class="line">          this.list.push(this.info)//往list数组添加数据</span><br><span class="line">          this.info = &apos;&apos;//每次点击add的同时，清空输入框</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>以上操作有几个缺点</p>
<ul>
<li>全局定义：强制要求每个component中的命名不得重复</li>
<li>字符串模版：缺乏语法高亮，在html有多行的时候，需要用\</li>
<li>不支持CSS：意味着当html和JavaScript组件化时，CSS明显被遗漏</li>
<li>没有构建步骤：限制只能用html和ES5 JavaScript,而不能使用预处理器，如Pug(formerly Jade)和Babel，即每次都需要手动在浏览器上刷新，没有自动热更新。</li>
</ul>
<h2 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h2><p>安装Vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure>

<p>安装命令行工具 (CLI)<a href="https://cli.vuejs.org/zh/guide/installation.html" target="_blank" rel="noopener">Vue CLI</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>

<p>出现安装问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm WARN deprecated joi@14.3.1: This module has moved and is now available at @hapi/joi. Please update your dependencies as this version is no longer maintained an may contain bugs and security issues.</span><br><span class="line">npm WARN deprecated topo@3.0.3: This module has moved and is now available at @hapi/topo. Please update your dependencies as this version is no longer maintained an may contain bugs and security issues.</span><br><span class="line">npm WARN deprecated hoek@6.1.3: This module has moved and is now available at @hapi/hoek. Please update your dependencies as this version is no longer maintained an may contain bugs and security issues.</span><br><span class="line">npm WARN deprecated cross-spawn-async@2.2.5: cross-spawn no longer requires a build toolchain, use it instead</span><br><span class="line">npm ERR! Unexpected end of JSON input while parsing near &apos;...TGOVzYcDOP1jLScCp0ACN&apos;</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /Users/sam/.npm/_logs/2019-04-29T01_23_19_163Z-debug.log</span><br></pre></td></tr></table></figure>
<p>清楚一下缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure>
<p>运行<code>vue --version</code>出现版本信息则说明安装成功</p>
<p>创建新项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create my-app</span><br></pre></td></tr></table></figure>


<p>使用默认安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue CLI v3.7.0</span><br><span class="line">? Please pick a preset: (Use arrow keys)</span><br><span class="line">❯ default (babel, eslint)</span><br><span class="line">  Manually select features</span><br></pre></td></tr></table></figure>


<p>启动项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; my-app@0.1.0 serve /Users/sam/Documents/studyUp/my-app</span><br><span class="line">&gt; vue-cli-service serve</span><br><span class="line"></span><br><span class="line"> INFO  Starting development server...</span><br><span class="line"> 98% after emitting CopyPlugin                                                .</span><br><span class="line"> DONE  Compiled successfully in 6412ms                               上午9:53:14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  App running at:</span><br><span class="line">  - Local:   http://localhost:8080/</span><br><span class="line">  - Network: http://192.168.43.116:8080/</span><br><span class="line"></span><br><span class="line">  Note that the development build is not optimized.</span><br><span class="line">  To create a production build, run npm run build.</span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">打开localhost:8080即可见到效果。</span><br><span class="line"></span><br><span class="line">![image.png](https://upload-images.jianshu.io/upload_images/3850802-8fcdd44c56b23d35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line"></span><br><span class="line">1 	node_modules 整个项目的依赖</span><br><span class="line"></span><br><span class="line">2	pubic ico 图标</span><br><span class="line"></span><br><span class="line">3	pubic index.html 整个项目的载体&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  跟上面👆直接`&lt;/script&gt;`引入的div一样</span><br><span class="line"></span><br><span class="line">4	src 整个项目的源代码</span><br><span class="line"></span><br><span class="line">5	Main.js  项目入口文件</span><br><span class="line"></span><br><span class="line">6	babel.config.js  babel配置</span><br><span class="line"></span><br><span class="line">7	package.json 依赖包版本</span><br><span class="line"></span><br><span class="line">8	说明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将上面的直接&lt;/script&gt;引入的demo改成单文件形式👇三个模块独立</span><br><span class="line"></span><br><span class="line">- 模版 template</span><br><span class="line">- 逻辑 script</span><br><span class="line">- 样式 style</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;样式作用域只在该文件内有效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在App.vue文件的模版中替换`div`内容,新建主件TodoItem.vue,在App.vue引入并使用</span><br></pre></td></tr></table></figure>
<template>
  <li class="item"></li>
</template>

<script>
export default {
  props: ['item'],
}
</script>

<style scoped>
.item {
    color: red;
}
</style>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<template>
  <div id="app">
    
    <div class="addMethod">
      <input type="text" name value v-model="info">
      <button type="button" name="button" @click="handleClick">add</button>
    </div>
    <ul>
      <todo-item v-for="item in list" :key="item" :item="item"></todo-item>
    </ul>
  </div>
</template>

<script>
import TodoItem from './components/TodoItem.vue' //引入TodoItem
export default {
  name: 'app',
  data() {
    return {
        message: 'hello vue',
        info: '',
        list: [],
    }
  },

  methods: {
    handleClick() {
        this.list.push(this.info)
        this.info = ''
    }
  },

  components: {
    TodoItem,       //注册TodoItem
  }

}
</script>

<style>
</style>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><todo-item v-for="item in list" :key="item" :item="item"></todo-item></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面👆是通过属性来传递item，下面👇改成插槽的方式</span><br></pre></td></tr></table></figure>
<p><span style="font-size:20px"></span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">此时解析由`&lt;li class=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;`改成</span><br></pre></td></tr></table></figure>
<li class="item">
  <slot></slot>
</li>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">或者给插槽一个名字(具名插槽)</span><br></pre></td></tr></table></figure>
<todo-item v-for="item in list" :key="item">
    <template id v-slot:item>
           <span style="font-size:20px"></span>
   </template>
</todo-item>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<template>
  <li class="item">
    <slot name="item"></slot>
  </li>
</template>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">作用域插槽(使用场景：由子控件传递值给父控件，供父控件使用修改显示，选中由红变蓝)</span><br></pre></td></tr></table></figure>
<todo-item v-for="item in list" :key="item">
   <template id v-slot:item="itemProps"> 获取checked的值
      <span :style="{fontSize:'20px', color: itemProps.checked ? 'red' : 'blue' }"></span>
   </template>
</todo-item>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<template>
  <li class="item">
    <input type="checkbox" v-model="checked">
    <slot name="item" v-bind></slot> //将checked 传递出去
  </li>
</template>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">动手复制代码跑来看看效果吧 👇👇👇👇👇👇👇👇👇</span><br></pre></td></tr></table></figure>
<template>
  <li class="item">
    <input type="checkbox" v-model="checked">
    <slot name="item" v-bind="{checked}"></slot>
  </li>
</template>

<script>
export default {
  props: ['item'],
  data() {
    return {
      checked:false
    }
  }
}
</script>

<style scoped>
.item {
    color: red;
}
</style>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<template>
  <div id="app">
    
    <div class="addMethod">
      <input type="text" name value v-model="info">
      <button type="button" name="button" @click="handleClick">add</button>
    </div>
    <ul>
      <todo-item v-for="item in list" :key="item">
        <template id v-slot:item="itemProps">
          <span :style="{fontSize:'20px', color: itemProps.checked ? 'red' : 'blue' }"></span>
        </template>
      </todo-item>
    </ul>
  </div>
</template>

<script>
import TodoItem from './components/TodoItem.vue' //引入TodoItem
export default {
  name: 'app',
  data() {
    return {
        message: 'hello vue',
        info: '',
        list: [],
    }
  },

  methods: {
    handleClick() {
        this.list.push(this.info)
        this.info = ''
    }
  },

  components: {
    TodoItem,       //注册TodoItem
  }

}
</script>

<style>
</style>
<pre><code>atom插件安装依次点击：atom-prefencence-install
- vue-autocomplete
- atom-beautify  代码格式键美化(control+command+b)
- atom-ternjs     js补全
- emmet            自定义代码块
- file-icons
- highlight-selected    选择某段代码自动高亮相同代码
- language-vue    vue语法











</code></pre>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>C++重温</title>
    <url>/2019/11/04/C++%E9%87%8D%E6%B8%A9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC</title>
    <url>/2019/11/04/WebRTC/</url>
    <content><![CDATA[<h1 id="WebRTC介绍"><a href="#WebRTC介绍" class="headerlink" title="WebRTC介绍"></a>WebRTC介绍</h1><p><a href="[https://webrtc.org/](https://webrtc.org/)">WebRTC</a>一个由google开源的音视频处理+即时通讯的开源库，优秀的多媒体、跨平台框架。它极其庞大复杂，换句话来说功能很强大，然后就是WebRTC只是定义了客户端的规范，至于服务器可以根据自己的业务场景来实现，一般应用于：</p>
<ul>
<li>音视频会议、在线教育</li>
<li>照相机</li>
<li>音乐播放器</li>
<li>共享远程桌面</li>
<li>录制</li>
<li>实施人脸识别</li>
<li>游戏</li>
<li>文件传输工具</li>
<li>P2P网络加速</li>
<li>即时通讯工具</li>
</ul>
<h1 id="WebRTC-1-对-1-音视频实时通话"><a href="#WebRTC-1-对-1-音视频实时通话" class="headerlink" title="WebRTC 1 对 1 音视频实时通话"></a>WebRTC 1 对 1 音视频实时通话</h1><p><img src="/2019/11/04/WebRTC/webrtc1-1to1.png" alt="过程示意图"></p>
<p>即两个 WebRTC 终端（上图中的两个大方框）、一个 Signal（信令）服务器和一个 STUN/TURN 服务器。</p>
<p><code>WebRTC 终端</code>负责音视频采集、编解码、NAT 穿越、音视频数据传输。步骤流程如下：</p>
<ul>
<li>获取权限（摄像头、麦克风）</li>
<li>本地视频的采集与展示</li>
<li>创建<code>RTCPeerConnection</code></li>
<li>媒体协商</li>
<li>远端视频的展示</li>
</ul>
<p><code>Signal 服务器</code>负责信令处理，如加入房间、离开房间、媒体协商消息的传递等。<br><code>STUN/TURN 服务器</code>负责获取 WebRTC 终端在公网的 IP 地址，以及 NAT 穿越失败后的数据中转。</p>
<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p><code>Full Cone</code> 完全锥型NAT<br>当 host 主机通过 NAT 访问外网的 B 主机时，就会在 NAT 上打个“洞”，所有知道这个“洞”的主机都可以通过它与内网主机上的侦听程序通信。<br><code>所谓的“打洞”就是在 NAT 上建立一个内外网的映射表。</code><br>大多数人都选用<code>UDP</code>作为打洞协议.</p>
<p><img src="/2019/11/04/WebRTC/webrtc10-full-cone.png" alt></p>
<p><code>ip restricted</code>IP 限制锥型NAT<br>host 主机在 NAT 上“打洞”后，NAT 会对穿越洞口的 IP 地址做限制。只有登记的 IP 地址才可以通过。</p>
<p>IP 限制锥型 NAT 的映射表是一个 5 元组，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	内网 IP，</span><br><span class="line">	内网端口，</span><br><span class="line">	映射的外网 IP，</span><br><span class="line">	映射的外网端口，</span><br><span class="line">	被访问主机的 IP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/WebRTC/webrtc10-ip-restricted.png" alt></p>
<p><code>port restrected</code> 端口限制型NAT</p>
<p>不光在 NAT 上对打洞的 IP 地址做了限制，而且还对具体的端口做了限制。因此，端口限制型 NAT 的映射表是一个 6 元组，其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	内网 IP，</span><br><span class="line">	内网端口，</span><br><span class="line">	映射的外网 IP，</span><br><span class="line">	映射的外网端口，</span><br><span class="line">	被访问主机的 IP,</span><br><span class="line">	被访问主机的端口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/WebRTC/webrtc10-port-restrcted.png" alt></p>
<p><code>symmetric</code> 对成型NAT<br>host 主机访问 B 时它在 NAT 上打了一个“洞”，而这个“洞”只有 B 主机上提供服务的端口发送的数据才能穿越，这一点与端口限制型 NAT 是一致的。</p>
<p>但它与端口限制型 NAT 最大的不同在于，如果 host 主机访问 A 时，它会在 NAT 上重新开一个“洞”，而不会使用之前访问 B 时打开的“洞”。也就是说对称型 NAT 对每个连接都使用不同的端口，甚至更换 IP 地址，而端口限制型 NAT 的多个连接则使用同一个端口，这对称型 NAT 与端口限制型 NAT 最大的不同.</p>
<p><img src="/2019/11/04/WebRTC/webrtc10-symmetric.png" alt></p>
<p><code>NAT 类型检测</code>步骤</p>
<ul>
<li>判断是否有 NAT 防护</li>
<li>探测 NAT 环境</li>
</ul>
<p><img src="/2019/11/04/WebRTC/webrtc10-nat-check.png" alt></p>
<h1 id="STUN协议"><a href="#STUN协议" class="headerlink" title="STUN协议"></a>STUN协议</h1><ul>
<li>STUN存在的目的就是进行NAT穿越。</li>
<li>STUN是典型的客户端/服务器模式，即：客户端发送请求，服务端进行相应。</li>
</ul>
<p>STUN有着两套规范，分别是：<br><code>RFC3489</code>Simple Traversal of UDP Through NAT</p>
<p>RFC3489定义属性<br>| 属性 | 作用 |  |<br>| :—–| :— | :—- |<br>| 0x001 | mapped-address | 获取客户端映射地址 |<br>| 0x002 | response-address | 指明对于mapped-address的相应应该由哪里发送 |<br>| 0x003 | change-request | 请求服务端使用不同的IP和端口发送响应 |<br>| 0x004 | souce-address | 制定服务器的IP和端口 |<br>| 0x005 | change-addresss | 它是change-addresss请求的响应 |<br>| 0x006 | user-name | 用于安全验证 |<br>| 0x007 | password | 用于安全验证 |<br>| 0x008 | message-integrity | 消息完整性验证 |<br>| 0x009 | error-code | 错误码 |<br>| 0x00a | unknow-attributes | 未知属性 |<br>| 0x00b | peflected-from | 拒约 |</p>
<p><code>RFC5389</code>Session Traversal Utilities for NAT（它是UDP和TCP都有用到的）</p>
<h1 id="TURN协议"><a href="#TURN协议" class="headerlink" title="TURN协议"></a>TURN协议</h1><ul>
<li>目的是解决堆成NAT无法穿越的问题</li>
<li>其建立在STUN之上，消息格式使用STUN格式消息</li>
<li>TURN Client要求服务端分配一个公共IP和Port用于接收或发送数据</li>
</ul>
<p><img src="/2019/11/04/WebRTC/turn-demo.png" alt></p>
<h1 id="ICE框架"><a href="#ICE框架" class="headerlink" title="ICE框架"></a>ICE框架</h1><ul>
<li>收集Candidate（本机所有IP和制定端口）</li>
<li>对Candidate Pair 排序</li>
<li>连通性检查</li>
</ul>
<p>什么是 Candidate?<br>它表示 WebRTC 与远端通信时使用的协议、IP 地址和端口，一般由以下字段组成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	IP: xxx.xxx.xxx.xxx,</span><br><span class="line">	port: number,</span><br><span class="line">	<span class="built_in">type</span>: host/srflx/relay,</span><br><span class="line">	priority: number,</span><br><span class="line">	protocol: UDP/TCP,</span><br><span class="line">	usernameFragment: string</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，候选者类型中的 host 表示本机候选者，srflx 表示内网主机映射的外网的地址和端口，relay 表示中继候选者。</p>
<h1 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h1><p><code>SDP</code>session description protocol，它是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息。</p>
<h1 id="RTP-RTCP"><a href="#RTP-RTCP" class="headerlink" title="RTP/RTCP"></a>RTP/RTCP</h1><p> 一般情况下，在实时互动直播系统传输音视频数据流时，我们并不直接将音视频数据流交给 UDP 传输，而是先给音视频数据加个 RTP 头，然后再交给 UDP 进行传输。</p>
<p>在使用 RTP 包传输数据时，难免会发生丢包、乱序、抖动等问题，但在处理这些问题之前，它首先要让各端都知道它们自己的网络质量到底是怎样的，这就是 RTCP 的作用。</p>
<p>各协议头字段如下，SSRC为共享媒体流的源。</p>
<p><img src="/2019/11/04/WebRTC/RTP-protocol-header.png" alt="RTP"></p>
<p><img src="/2019/11/04/WebRTC/RTCP-protocol-header.png" alt="RTCP"></p>
]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg</title>
    <url>/2019/11/04/FFmpeg/</url>
    <content><![CDATA[<h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p><a href="http://ffmpeg.org/download.html" target="_blank" rel="noopener">FFmpeg</a>是一个音视频处理库，提供了如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>源码安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  GitHub git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git ffmpeg</span><br><span class="line">Cloning into <span class="string">'ffmpeg'</span>...</span><br><span class="line">remote: Counting objects: 588505, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (120835/120835), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 588505 (delta 471727), reused 581424 (delta 466456)</span><br><span class="line">Receiving objects: 100% (588505/588505), 138.43 MiB | 2.74 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (471727/471727), <span class="keyword">done</span>.</span><br><span class="line">Checking out files: 100% (7264/7264), <span class="keyword">done</span>.</span><br><span class="line">➜  GitHub <span class="built_in">cd</span> ffmpeg </span><br><span class="line">➜  ffmpeg git:(master) ls</span><br><span class="line">CONTRIBUTING.md  LICENSE.md       ffbuild          libpostproc</span><br><span class="line">COPYING.GPLv2    MAINTAINERS      fftools          libswresample</span><br><span class="line">COPYING.GPLv3    Makefile         libavcodec       libswscale</span><br><span class="line">COPYING.LGPLv2.1 README.md        libavdevice      presets</span><br><span class="line">COPYING.LGPLv3   RELEASE          libavfilter      tests</span><br><span class="line">CREDITS          compat           libavformat      tools</span><br><span class="line">Changelog        configure        libavresample</span><br><span class="line">INSTALL.md       doc              libavutil</span><br><span class="line">➜  ffmpeg git:(master) ./configure --<span class="built_in">help</span></span><br><span class="line">➜  ffmpeg git:(master) ./configure --<span class="built_in">help</span> | more </span><br><span class="line">Usage: configure [options]</span><br><span class="line">Options: [defaults <span class="keyword">in</span> brackets after descriptions]</span><br><span class="line"></span><br><span class="line">➜  ffmpeg git:(master) ./configure --prefix=/usr/<span class="built_in">local</span>/ffmpeg --<span class="built_in">enable</span>-gpl  --<span class="built_in">enable</span>-nonfree  --<span class="built_in">enable</span>-libfdk-aac  --<span class="built_in">enable</span>-libx264   --<span class="built_in">enable</span>-libx265  --<span class="built_in">enable</span>-filter=delogo  --<span class="built_in">enable</span>-debug  --<span class="built_in">disable</span>-optimizations --<span class="built_in">enable</span>-libspeex  --<span class="built_in">enable</span>-videotoolbox  --<span class="built_in">enable</span>-shared  --<span class="built_in">enable</span>-pthreads  --<span class="built_in">enable</span>-version3  --<span class="built_in">enable</span>-hardcoded-tables --cc=clang --host-cflags=  --host-ldflags=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">报错、报错、报错、报错、</span><br><span class="line">nasm/yasm not found or too old. Use --<span class="built_in">disable</span>-x86asm <span class="keyword">for</span> a crippled build.</span><br><span class="line">ERROR: libfdk_aac not found</span><br><span class="line">ERROR: speex not found using pkg-config</span><br><span class="line">ERROR: libx264 not found</span><br><span class="line"></span><br><span class="line">前面三种都可以通过brew install来解决，但是libx264怎么搞都拉不下。。。</span><br></pre></td></tr></table></figure>

<p>通过brew安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ffmpeg git:(master) brew install ffmpeg</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Installing dependencies <span class="keyword">for</span> ffmpeg: aom,,,,</span><br><span class="line"></span><br><span class="line">==&gt; Caveats</span><br><span class="line">gettext is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because macOS provides the BSD gettext library &amp; some software gets confused <span class="keyword">if</span> both are <span class="keyword">in</span> the library path.</span><br><span class="line"></span><br><span class="line">If you need to have gettext first <span class="keyword">in</span> your PATH run:</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/gettext/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find gettext you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/gettext/lib"</span></span><br><span class="line">  <span class="built_in">export</span> CPPFLAGS=<span class="string">"-I/usr/local/opt/gettext/include"</span></span><br><span class="line">==&gt; Caveats</span><br><span class="line">libffi is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because some formulae require a newer version of libffi.</span><br><span class="line"></span><br><span class="line">For compilers to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/libffi/lib"</span></span><br><span class="line"></span><br><span class="line">For pkg-config to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> PKG_CONFIG_PATH=<span class="string">"/usr/local/opt/libffi/lib/pkgconfig"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==&gt; Caveats</span><br><span class="line">==&gt; gettext</span><br><span class="line">gettext is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because macOS provides the BSD gettext library &amp; some software gets confused <span class="keyword">if</span> both are <span class="keyword">in</span> the library path.</span><br><span class="line"></span><br><span class="line">If you need to have gettext first <span class="keyword">in</span> your PATH run:</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/gettext/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find gettext you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/gettext/lib"</span></span><br><span class="line">  <span class="built_in">export</span> CPPFLAGS=<span class="string">"-I/usr/local/opt/gettext/include"</span></span><br><span class="line"></span><br><span class="line">==&gt; libffi</span><br><span class="line">libffi is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because some formulae require a newer version of libffi.</span><br><span class="line"></span><br><span class="line">For compilers to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/libffi/lib"</span></span><br><span class="line"></span><br><span class="line">For pkg-config to find libffi you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> PKG_CONFIG_PATH=<span class="string">"/usr/local/opt/libffi/lib/pkgconfig"</span></span><br><span class="line"></span><br><span class="line">==&gt; unbound</span><br><span class="line">To have launchd start unbound now and restart at startup:</span><br><span class="line">  sudo brew services start unbound</span><br><span class="line">==&gt; glib</span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/<span class="built_in">local</span>/etc/bash_completion.d</span><br><span class="line">==&gt; tesseract</span><br><span class="line">This formula contains only the <span class="string">"eng"</span>, <span class="string">"osd"</span>, and <span class="string">"snum"</span> language data files.</span><br><span class="line">If you need any other supported languages, run `brew install tesseract-lang`.</span><br></pre></td></tr></table></figure>


<p><code>brew info ffmpeg</code>可以看到x264, x265这些包都是有安装的。升级则通过<code>brew update &amp;&amp; brew upgrade ffmpeg</code>.</p>
<p>第二种方式安装连环境变量都不需要设置，完美极了。</p>
<h1 id="目录及作用"><a href="#目录及作用" class="headerlink" title="目录及作用"></a>目录及作用</h1><ul>
<li>libavcodec： 提供了一系列编码器的实现。</li>
<li>libavformat： 实现在流协议，容器格式及其本IO访问。</li>
<li>libavutil： 包括了hash器，解码器和各利工具函数。</li>
<li>libavfilter： 提供了各种音视频过滤器。</li>
<li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li>
<li>libswresample： 实现了混音和重采样。</li>
<li>libswscale： 实现了色彩转换和缩放工能。</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>音／视频流</code> 在音视频领域，我们把一路音／视频称为一路流。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p>
<p><code>容器</code> 我们一般把 MP4､ FLV、MOV等文件格式称之为容器。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p>
<p><code>channel</code> 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基础01</title>
    <url>/2019/11/01/Swift%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="使用let关键字来声明常量"><a href="#使用let关键字来声明常量" class="headerlink" title="使用let关键字来声明常量"></a>使用let关键字来声明常量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="使用var关键字来声明变量"><a href="#使用var关键字来声明变量" class="headerlink" title="使用var关键字来声明变量"></a>使用var关键字来声明变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var temp = 0</span><br><span class="line">temp = 10</span><br></pre></td></tr></table></figure>
<h3 id="可以在一行中声明多个变量或常量，用逗号分隔"><a href="#可以在一行中声明多个变量或常量，用逗号分隔" class="headerlink" title="可以在一行中声明多个变量或常量，用逗号分隔"></a>可以在一行中声明多个变量或常量，用逗号分隔</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var x=0.1, y=10.1, z=1.0</span><br></pre></td></tr></table></figure>
<h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><p>在声明一个变量或常量的时候提供类型标注，来明确变量或常量能够储存值的类型</p>
<p>添加类型标注的方法是在变量或常量的名字后边加一个冒号，再跟一个空格，最后加上要使用的类型名称</p>
<p>可以在一行中定义多个相关的变量为相同类型，用逗号分隔，只要在最后的变量名字后边加上类型标注</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var msg: String</span><br><span class="line">msg = <span class="string">"message"</span></span><br></pre></td></tr></table></figure>

<h3 id="变量和常量命名"><a href="#变量和常量命名" class="headerlink" title="变量和常量命名"></a>变量和常量命名</h3><p>几乎可以使用任何自负，甚至包括Unicode字符</p>
<p>不能包括空白字符、数学符号、箭头、保留的（或无效的）Unicode码位、连线和制表符。也不能以数字开头。</p>
<h3 id="打印常量和变量"><a href="#打印常量和变量" class="headerlink" title="打印常量和变量"></a>打印常量和变量</h3><p>print</p>
<p>字符串插值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">"show string"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"显示str\(str)"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>8，16，32，64位编码的有符号和无符号整数（例如：UInt8,Int8）</p>
<p>通过min和max属性访问每个整数类型的最小值和最大值</p>
<p>Int，拥有与当前平台的原生字相同的长度；UInt，与平台长度相关的无符号整数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"UInt8 min \(UInt8.min), UInt8 max \(UInt8.max)"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p> Double 64位浮点数，至少有15位数字的精度</p>
<p> Float 32位浮点数，至少有6位数字的精度</p>
<h3 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h3><p>表示true和false</p>
<p>Swift的类型安全机制会阻止你用一个非布尔量的值替代掉Bool</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p><img src="/2019/11/01/Swift%E5%9F%BA%E7%A1%8001/Swift_%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4.png" alt="Swift_数值范围"></p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p> 类型别名是一个为已存在类型定义的一个可选择的名字<br> <code>typealias</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typealias AudioSample = UInt8</span><br><span class="line"><span class="built_in">let</span> sample: AudioSample = 32</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><h3 id="使用Tuple组合多个值"><a href="#使用Tuple组合多个值" class="headerlink" title="使用Tuple组合多个值"></a>使用Tuple组合多个值</h3><p>元组把多个值合并成单一的复合型的值</p>
<p>元组内的值可以是任何类型，而且可以不必是同一类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.0)</span><br><span class="line"><span class="built_in">print</span>(error.1)</span><br></pre></td></tr></table></figure>
<h3 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h3><p>元组中的每一个元素可以制定对应的元素名称</p>
<p>如果没有制定名称的元素也可以使用下标的方式来引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (error: 1,  errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">print</span>(error.error)</span><br><span class="line"><span class="built_in">print</span>(error.errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="Tuple修改"><a href="#Tuple修改" class="headerlink" title="Tuple修改"></a>Tuple修改</h3><p>用var定义的元组就是可变元组，let定义的就是不可变元组</p>
<p><code>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</code></p>
<p>可以对可变元组的元素进行修改，但是不能改变其类型</p>
<p>Any类型可以改为任何类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var error:(errorCode: Int, errorMsg:Any) = (errorCode: 1, errorMsg: <span class="string">"没有权限"</span>)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMsg = 3</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>可以将一个元组的内容分解成单独的常量或变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (error, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<p>如果只需要使用其中的一部分数据，不需要的数据可以用下划线<code>_</code>代替</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> error = (1, <span class="string">"没有权限"</span>)</span><br><span class="line"><span class="built_in">let</span> (_, errorMsg) = error</span><br><span class="line"><span class="built_in">print</span>(errorMsg)</span><br></pre></td></tr></table></figure>
<h3 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h3><p>使用Tuple为函数返回多个值</p>
<p>返回值的Tuple可以在函数的返回类型部分被命名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func requestWithUrl(url: String) -&gt; (errorCode: Int, errorMsg: String) &#123;</span><br><span class="line">    <span class="built_in">return</span> (1, <span class="string">"没有权限"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> error = requestWithUrl(url: <span class="string">""</span>)</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>通过在变量类型后面加<code>?</code>表示：这里有一个值，它表示x，或者这里根本没有值</p>
<p>可以通过给可选变量赋值一个nil来将之设置为没有值</p>
<p>在Swift中，nil不是指针，他是值缺失的一种特殊类型，任何类型的可选类项都可以设置成nil而不仅仅是对西那个类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = nil</span><br></pre></td></tr></table></figure>

<h3 id="Optional-if"><a href="#Optional-if" class="headerlink" title="Optional-if"></a>Optional-if</h3><p>可选项是没法直接食用的，需要用!展开之后才能使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> str != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h3><p>可以使用可选项的绑定来判断是否包含值，如果包含就把值赋给一个临时的常量或者变量</p>
<p>可选绑定可以与if和while的语句使用来检查可选项内部的值，并赋值给一个变量或常量 </p>
<p>同一个if语句中包含多个可选项绑定时，用逗号分隔开即可。如果人一个选项绑定结果是nil或者布尔值为false，那么整个if判断会被看作false</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> actualStr = str &#123;</span><br><span class="line">    <span class="built_in">let</span> cont = str!.count</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-隐式展开"><a href="#Optional-隐式展开" class="headerlink" title="Optional-隐式展开"></a>Optional-隐式展开</h3><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行展开</p>
<p>通过在声明的类型后边添加一个叹号<code>!</code>而非问好来书写隐式展开可选项</p>
<p>隐式展开可选项主要被用于Swift类的初始化过程中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String! = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str!.count</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<h3 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h3><p>可选项后面加问号</p>
<p>如果可选项不为nil，返回一个可选项结果，否则返回nil</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str : String? = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">let</span> cont = str?.count</span><br><span class="line"><span class="keyword">if</span> count != nil &#123;</span><br><span class="line">    <span class="built_in">let</span> lastIndex = count! - 1</span><br><span class="line">    <span class="built_in">print</span>(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var emptyString = <span class="string">""</span></span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(Noting<span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字符串字面亮是被双引号<code>&quot;</code>包裹的固定顺序的文本字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var str = <span class="string">"some string"</span></span><br></pre></td></tr></table></figure>

<h3 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h3><p>字多行符串字面量是被三个双引号<code>&quot;&quot;&quot;</code>引起来的一系列字符</p>
<p>开始和结束默认不会有换行符</p>
<p>反斜杠只会在代码阅读上方便，输出时没有实际的换行功能<code>\</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">""</span><span class="string">"var emptyString = "</span><span class="string">" \</span></span><br><span class="line"><span class="string">var anotherEmptyString = String() \</span></span><br><span class="line"><span class="string">if emptyString.isEmpty &#123; \</span></span><br><span class="line"><span class="string">    print(Noting"</span>) \</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">print(str)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h3><p>转义特殊字符</p>
<p>任意的Unicode标量  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展字符串分隔符"><a href="#扩展字符串分隔符" class="headerlink" title="扩展字符串分隔符"></a>扩展字符串分隔符</h3><p>在字符串字面量中放置扩展分隔符来在字符串中包含特殊字符而不让它们真的生效</p>
<p>将字符串放在双引号内并由井号#包裹</p>
<p>如果字符串里有”#则首尾需要两个##(首尾##与包含的”#不一样即可)</p>
<p>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的#号数量的#号，并在前面添加转义符号\</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\n\n444"#</span></span><br><span class="line"><span class="built_in">let</span> str = <span class="comment">#"122\#n\n444"#</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的可变形"><a href="#字符串的可变形" class="headerlink" title="字符串的可变形"></a>字符串的可变形</h3><p>var 可修改<br>let 不可修改</p>
<h3 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h3><p>String 值在传递给方法或者函数的时候会被复制过去</p>
<p>赋值给常量和变量的时候也是一样</p>
<h3 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h3><p>for-in 循环遍历String中的每一个独立的Character</p>
<p>Character类型</p>
<p>String值可以通过传入Character 数组来构造</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"abcdef"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> tempCharacters: [Character] = [<span class="string">"d"</span>,<span class="string">"f"</span>,<span class="string">"d"</span>,<span class="string">"h"</span>]</span><br><span class="line"><span class="built_in">let</span> str = String(tempCharacters)</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>通过加运算符<code>+</code>创建新字符串</p>
<p>使用加赋值符号<code>+=</code>在已经存在的String值末尾追加一个String值</p>
<p>使用String类型的<code>append()</code>方法来给一个String变量的末尾追加character值</p>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p><code>\(some)</code> some代表：混合常量、变量、字面量和表达式的字符串面量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="comment">#"1 * 3 = \#(1*3)."#)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>每个String值都有相关的索引类型，String.index，它相当于每个Character在字符串重的位置</p>
<p>startIndex属性来访问String中第一个Character的位置。endIndex属性就是String中最后一个字符后的位置</p>
<p>endIndex属性并不是字符串下表脚本的合法实际参数</p>
<p>如果String为空，则startIndex与endIndex相等</p>
<p>使用index(before:)和index(after:)方法来访问给定索引的前后</p>
<p>要访问给定索引更远的索引，你可以使用index(_:offsetBy:)</p>
<p>使用indices属性来访问字符串中每个字符的索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> hello = <span class="string">"hello"</span></span><br><span class="line">hello[hello.startIndex]</span><br><span class="line">hello[hello.index(before: hello.endIndex)]</span><br><span class="line">hello[hello.index(after: hello.startIndex)]</span><br><span class="line"><span class="built_in">let</span> index = hello.index(hello.startIndex, offsetBy: 2)</span><br><span class="line">hello[index]</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入字符，使用insert(_:at:)方法</p>
<p>插入另一个字符串的内容到特定的索引，使用insert(contentsOs:at:)方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, at: welcome.endIndex)</span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf: <span class="string">"ererer"</span>, at: welcome.index(before: welcome.endIndex))</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>移除字符串remove(at:)</p>
<p>移除特定范围的字符串removeSubrange(range)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> range = welcome.index(welcome.endIndex, offsetBy: -1)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br></pre></td></tr></table></figure>

<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>使用下表或者累死prefix(_:)的方法得到的子字符串是SubString类型</p>
<p>SubString拥有String的大部分方法</p>
<p>SubString可以转成String类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> index3 = hello.lastIndex(of: <span class="string">"o"</span>) ?? hello.endIndex</span><br><span class="line"><span class="built_in">let</span> begin = hello[..&lt;index3]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> newHello = String(begin)</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>字符串和字符相等性(==和==)</p>
<p>前缀相等hasPrefix(_:)</p>
<p>后缀相等hasSuffix(_:)</p>
<h2 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a>赋值和算术运算符</h2><p>一元运算符、二元运算符、三元运算符</p>
<p>赋值运算符不会返回值</p>
<h2 id="如何处理算术结果溢出"><a href="#如何处理算术结果溢出" class="headerlink" title="如何处理算术结果溢出"></a>如何处理算术结果溢出</h2><p>在默认情况下，当一个整数赋超过它容量的值时，Swift会报错而不是生成一个无效的数，给我们操作过大或者过小的数的时候提供了额外的安全性</p>
<p>同时提供了三个算术溢出运算符来让系统支持整数溢出的运算</p>
<p>溢出加法<code>&amp;+</code></p>
<p>溢出减法<code>&amp;-</code></p>
<p>溢出乘法<code>&amp;*</code></p>
<h3 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h3><p>溢出也会发生在有符号整形数值上</p>
<p>对于无符号与有符号整形数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
<h2 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符??"></a>合并空值运算符<code>??</code></h2><p>合并空值运算符(a??b)如果选项a有值则展开，如果没有值，是nil，则返回默认值b</p>
<p>表达式a必须是一个可选类型。表达式b必须与a的存储类型相同。</p>
<p>实际上它就是相当于三目运算符<code>_?_:_</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func addTwoNum(num1: Int?, num2: Int2?) -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> (num1 ?? 0) +(num2 ?? 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><h3 id="闭区间运算符a-b"><a href="#闭区间运算符a-b" class="headerlink" title="闭区间运算符a...b"></a>闭区间运算符<code>a...b</code></h3><p>定义了从a到b的一组范围，并且包含a和b</p>
<p>a的值不能大于b的值</p>
<h3 id="半开区间运算符a-lt-b"><a href="#半开区间运算符a-lt-b" class="headerlink" title="半开区间运算符a..&lt;b"></a>半开区间运算符<code>a..&lt;b</code></h3><p>定义了从a到b但不包含b的区间</p>
<p>a的值不能大于b的值，如果a与b的值相等，那返回的区间将会是空的</p>
<h3 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h3><p>比如说，一个包含数组所有的元素的区间，从索引2到数组的结束。在这种情况下，你可以省略区间运算符一侧的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[2...] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[...2] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倒序索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (0..&lt;10&gt;).<span class="function"><span class="title">reversed</span></span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间运算符在字符串上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> range = welcome.startIndex...welcome.index(welcome.endIndex, offsetBy: -6)</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(welcome)]</span><br></pre></td></tr></table></figure>

<p>区间运算符在比较类型上的运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> welcome = <span class="string">"hello,world"</span></span><br><span class="line"><span class="built_in">let</span> interval = <span class="string">"a"</span>...<span class="string">"z"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> welcome &#123;</span><br><span class="line">    <span class="keyword">if</span> !interval.contains(String(c)) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(c)不是小写字母"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符"></a>位取反运算符</h3><p>位取反运算符(~)是对所有位的数字进行取反操作</p>
<h3 id="位与运算符"><a href="#位与运算符" class="headerlink" title="位与运算符"></a>位与运算符</h3><p>位与运算符(&amp;)是对两个数的比特位进行合并。它会返回一个新的数，只有当这两个数都是1的时候才能返回1。</p>
<h3 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符"></a>位或运算符</h3><p>位或运算符(|)是对两个数的比特位进行比较。它会返回一个新的数，只要两个操作位任意一个为1时，那么对应的位数就为1。</p>
<h3 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符"></a>位异或运算符</h3><p>位异或运算符(^))，当两个操作数的对应位不相同时，那么该数对应的位数就为1。</p>
<h3 id="位左移和右移运算符"><a href="#位左移和右移运算符" class="headerlink" title="位左移和右移运算符"></a>位左移和右移运算符</h3><p>位左移(&lt;&lt;)和右移运算符(&gt;&gt;)可以吧所有位数的数字向左或向右移动一个确定的位数。</p>
<p>位座椅和右移具有给整数乘以或除以二的效果。将一个数左移一位相当于把这个数翻倍，将一个数右移一位相当于把这个数减半。</p>
<h3 id="无符号整数的唯一操作"><a href="#无符号整数的唯一操作" class="headerlink" title="无符号整数的唯一操作"></a>无符号整数的唯一操作</h3><p>用0填充左移或右移后产生的空白位</p>
<h3 id="有符号整数的移位操作"><a href="#有符号整数的移位操作" class="headerlink" title="有符号整数的移位操作"></a>有符号整数的移位操作</h3><p>第一位表示整数还是负数（0正数，1负数）</p>
<h3 id="位运算符应用"><a href="#位运算符应用" class="headerlink" title="位运算符应用"></a>位运算符应用</h3><ul>
<li>两个数字交换</li>
<li>求赋符号整形数二进制中1的个数</li>
<li>判断一个整数是否为为2的整数次幂</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"new page title"</span></span><br></pre></td></tr></table></figure>


<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"></span><br><span class="line">$ hexo d --g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<p>Markdown 表格<br><code>-:</code> 设置内容和标题栏居右对齐。<br><code>:-</code> 设置内容和标题栏居左对齐。<br><code>:-:</code> 设置内容和标题栏居中对齐。</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
]]></content>
  </entry>
</search>
